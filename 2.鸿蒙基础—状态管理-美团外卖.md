<h2 id="6409fc62">1.自定义构建函数</h2>
<h3 id="892e2cb3">1. 构建函数-[@Builder ](/Builder ) </h3>
:::info
如果你不想在直接抽象组件，ArkUI还提供了一种更**轻量**的UI元素复用机制 `@Builder`，可以将重复使用的UI元素抽象成一个方法，在 `build` 方法里调用。称之为**自定义构建函数**

:::



:::color1
只要使用Builder修饰符修饰的内容，都可以做成对应的UI描述

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709371095540-caeb1d80-f801-4c26-abda-a7be1612930e.png)

```typescript
@Entry
@Component
struct BuilderCase {
  @State
  list: string[] = ["A", "B","C", "D", "E", "F"]

  @Builder
  getItemBuilder (itemName: string) {
    Row() {
      Text(`${itemName}. 选项`)
    }
    .height(60)
    .backgroundColor("#ffe0dede")
    .borderRadius(8)
    .width("100%")
    .padding({
      left: 20,
      right: 20
    })
  }

  build() {
    Column({ space: 10 }) {
      ForEach(this.list, (item: string) => {
        this.getItemBuilder(item)
      })
    }
    .padding(20)
  }
}
```

+ 用法- 使用@Builder修饰符修饰

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702093111373-6e72af0c-0ef4-49ef-a0e1-80a53fbfcb50.png)

```typescript

@Entry
@Component
struct BuilderCase02 {
  build() {
    Row() {
      Column() {
        Row() {
          Row() {
            Text("异常时间")
            Text("2023-12-12")
          }
          .width('100%')
          .justifyContent(FlexAlign.SpaceBetween)
          .padding({
            left: 15,
            right: 15
          })
          .borderRadius(8)
          .height(40)
          .backgroundColor(Color.White)
        }.padding({
          left: 10,
          right: 10
        })

      }
      .width('100%')
    }
    .height('100%')
    .backgroundColor('#ccc')
  }
}
```

:::info
假设你有N个这样的单个元素，但是重复的去写会浪费大量的代码，丧失代码的可读性，此时我们就可以使用

builder构建函数

:::

1. 全局定义- @Builder function name () {}

```typescript
@Builder
function getCellContent(leftTitle: string, rightValue: string) {
  Row() {
    Row() {
      Text(leftTitle)
      Text(rightValue)
    }
    .width('100%')
    .justifyContent(FlexAlign.SpaceBetween)
    .padding({
      left: 15,
      right: 15
    })
    .borderRadius(8)
    .height(40)
    .backgroundColor(Color.White)
  }.padding({
    left: 10,
    right: 10
  })

}
```

+ 在组件中使用

```typescript
  Column({ space: 10 }) {
        getCellContent("异常时间", "2023-12-12")
        getCellContent("异常位置", "回龙观")
        getCellContent("异常类型", "漏油")
      }
      .width('100%')
```



:::color2
Next里面最大的变化就是全局的自定义Builder函数可以被引用，也就是你的一些公共的builder函数可以抽提出来，像使用函数那样来复用一些样式

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702093353690-9f59f47e-40a7-40ca-a403-3bedf8f208de.png)



:::info
全局自定义函数的问题

+ 全局的自定义构建函数可以被整个应用获取，不允许使用this和bind方法。
+ 如果不涉及组件状态变化，建议使用全局的自定义构建方法。
+ 如果数据是响应式的-此时该函数不会自动渲染-哪怕是全局自定义函数，**<font style="color:#DF2A3F;">可以被其他文件引用</font>**

:::

+ 案例

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706171395256-844c82ea-46c9-4287-a106-5d105075b6da.png)

:::color2
上图中，是tabs组件中的tabbar属性，支持自定义builder,意味着我们可以定制它的样式

:::

+ 准备八个图标放到资源目录下

[图片.zip](https://weiqi123.yuque.com/attachments/yuque/0/2024/zip/32778948/1727514811380-53d2ea86-301a-4502-8f7b-17a985c090a5.zip)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706171734694-8a32c600-8a29-414a-b399-011e49320643.png)

+ 新建一个页面， 声明一个interface并建立四个数据的状态

```typescript
interface TabInterface {
  name: string
  icon: ResourceStr
  selectIcon: ResourceStr
  title: string
}
```

+ 循环生成对应的TabContent

```typescript
@Entry
@Component
struct TabBarBuilderCase {
  @State
  list: TabInterface[] = [{
    icon: $r("app.media.ic_public_message"),
    selectIcon: $r('app.media.ic_public_message_filled'),
    name: 'wechat',
    title: '微信',
  }, {
    icon: $r('app.media.ic_public_contacts_group'),
    selectIcon: $r('app.media.ic_public_contacts_group_filled'),
    name: 'connect',
    title: '联系人',
  }, {
    icon: $r('app.media.ic_gallery_discover'),
    selectIcon: $r('app.media.ic_gallery_discover_filled'),
    name: 'discover',
    title: '发现',
  }, {
    icon: $r('app.media.ic_public_contacts'),
    selectIcon: $r('app.media.ic_public_contacts_filled'),
    name: 'my',
    title: '我的',
  }]


  build() {
    Tabs() {
     ForEach(this.list, (item: TabInterface) => {
       TabContent() {
         Text(item.title)
       }
       .tabBar(item.title)
     })
    }
    .barPosition(BarPosition.End)
  }
}
interface TabInterface {
  name: string
  icon: ResourceStr
  selectIcon: ResourceStr
  title: string
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706172231464-6a905272-e378-4b97-9386-a52e38115a4c.png)

:::color2
此时，如果我们想实现图中对应的效果，就需要使用自定义Builder来做，因为TabContent的tabBar属性支持CustomBuilder类型，CustomBuilder类型就是builder修饰的函数

:::

+ 在当前组件中声明一个builder函数

```typescript
 @Builder
  CommonTabBar (item: TabInterface) {
    Column () {
      Image(item.icon)
        .width(20)
        .height(20)
      Text(item.title)
        .fontSize(12)
        .fontColor("#1AAD19")
        .margin({
          top: 5
        })
    }
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706173267648-5036f4e3-a26f-478e-a8d5-596d94cd0865.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706173276675-86c793c9-37f5-43b3-be1b-7028f7b91883.png)

+ 定义一个数据来绑定当前tabs的激活索引

```typescript
  @State
  currentIndex: number = 0
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706173364205-d9513615-9a18-4b44-9b61-3c1c893a0075.png)

+ 根据当前激活索引设置不同的颜色的图标

```typescript
 @Builder
  CommonTabBar (item: TabInterface) {
    Column () {
      Image(item.name === this.list[this.currentIndex].name ? item.selectIcon : item.icon)
        .width(20)
        .height(20)
      Text(item.title)
        .fontSize(12)
        .fontColor(item.name === this.list[this.currentIndex].name ? "#1AAD19": "#2A2929")
        .margin({
          top: 5
        })
    }
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1706173486889-a2424120-4f0a-433d-a65f-37594de4b03f.png)

<h3 id="vT76e">2. 瀑布流组件-WaterFlow和Builder的一个案例</h3>
:::color1
Builder修饰符

用来修饰函数的

:::

```typescript
// 组件内的builder修饰器
@Builder
abc () {
  
}
```

+ 全局builder修饰符

```typescript
@Builder
function abc () {
  
}
```

:::success
全局和局部都可以接收参数

**<font style="color:#DF2A3F;">Next版本中和4.0的区别-Next版本中可以实现builder全局函数的导入导出，可以实现复用</font>**

**<font style="color:#DF2A3F;">Next版本中如何涉及到状态的更新-不要用全局的builder函数</font>**

**<font style="color:#DF2A3F;">全局的builder函数只能做一些 静态的渲染复用，如果要实现动态的更新很复杂</font>**

:::

 

:::success
WaterFlow和Grid布局非常的类似

:::



:::color1
<font style="color:rgba(0, 0, 0, 0.9);">瀑布流容器，由“行”和“列”分割的单元格所组成，通过容器自身的排列规则，将不同大小的“项目”自上而下，如瀑布般紧密布局。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">说明</font>**

<font style="color:rgba(0, 0, 0, 0.9);">该组件从API Version 9 开始支持。后续版本如有新增内容，则采用上角标单独标记该内容的起始版本。</font>

<h2 id="zuEDM"><font style="color:rgba(0, 0, 0, 0.9);">子组件</font></h2>
<font style="color:rgba(0, 0, 0, 0.9);">包含</font>[FlowItem](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-flowitem-0000001774121278)<font style="color:rgba(0, 0, 0, 0.9);">子组件。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">说明</font>**

<font style="color:rgba(0, 0, 0, 0.9);">WaterFlow子组件的visibility属性设置为None时不显示，但该子组件周围的columnsGap、rowsGap、margin仍会生效。</font>

:::

+ 使用

:::color1
<h2 id="a4yi9"><font style="color:rgba(0, 0, 0, 0.9);">接口</font></h2>
<font style="color:rgba(0, 0, 0, 0.9);">WaterFlow(options?: WaterFlowOptions)</font>

**<font style="color:rgba(0, 0, 0, 0.9);">参数：</font>**

:::

| **<font style="color:rgba(0, 0, 0, 0.9);">参数名</font>** | **<font style="color:rgba(0, 0, 0, 0.9);">参数类型</font>** | **<font style="color:rgba(0, 0, 0, 0.9);">必填</font>** | **<font style="color:rgba(0, 0, 0, 0.9);">参数描述</font>** |
| --- | --- | --- | --- |
| <font style="color:rgba(0, 0, 0, 0.9);">options</font> | [WaterFlowOptions](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-waterflow-0000001774280974#ZH-CN_TOPIC_0000001774280974__waterflowoptions%E5%AF%B9%E8%B1%A1%E8%AF%B4%E6%98%8E) | <font style="color:rgba(0, 0, 0, 0.9);">是</font> | <font style="color:rgba(0, 0, 0, 0.9);">瀑布流组件参数。</font> |


<h4 id="AZMSU"><font style="color:rgba(0, 0, 0, 0.9);">WaterFlowOptions对象说明</font></h4>
| **<font style="color:rgba(0, 0, 0, 0.9);">参数名</font>** | **<font style="color:rgba(0, 0, 0, 0.9);">参数类型</font>** | **<font style="color:rgba(0, 0, 0, 0.9);">必填</font>** | **<font style="color:rgba(0, 0, 0, 0.9);">参数描述</font>** |
| --- | --- | --- | --- |
| <font style="color:rgba(0, 0, 0, 0.9);">footer</font> | [CustomBuilder](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-types-0000001774121374#ZH-CN_TOPIC_0000001774121374__custombuilder8) | <font style="color:rgba(0, 0, 0, 0.9);">否</font> | <font style="color:rgba(0, 0, 0, 0.9);">设置WaterFlow尾部组件。</font> |
| <font style="color:rgba(0, 0, 0, 0.9);">scroller</font> | [Scroller](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll-0000001821000913#ZH-CN_TOPIC_0000001821000913__scroller) | <font style="color:rgba(0, 0, 0, 0.9);">否</font> | <font style="color:rgba(0, 0, 0, 0.9);">可滚动组件的控制器，与可滚动组件绑定。</font><br/>**<font style="color:rgba(0, 0, 0, 0.9);">说明：</font>**<font style="color:rgba(0, 0, 0, 0.9);">不允许和其他滚动类组件，如：</font>[List](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-list-0000001774121286)<font style="color:rgba(0, 0, 0, 0.9);">、</font>[Grid](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-grid-0000001821000901)<font style="color:rgba(0, 0, 0, 0.9);">、</font>[Scroll](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-container-scroll-0000001821000913)<font style="color:rgba(0, 0, 0, 0.9);">等绑定同一个滚动控制对象。</font> |




:::success
CustomBuilder ？

意味着可以传入一个用Builder修饰符修饰的函数-来自定义结构的部分

:::

+ waterflow的基本使用

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1722927243614-6f20753c-6e25-4572-b27a-3edebdb66e89.png)

```typescript
@Entry
@Component
struct WaterFlowCase {
  @State message: string = 'Hello World';

  build() {
    WaterFlow() {
      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(150)
      }

      FlowItem() {
        Column() {
          Image("https://p2.cri.cn/M00/8A/A0/rBABCmav932AAI_aAAAAAAAAAAA751.786x1024.jpg")
            .objectFit(ImageFit.Cover)
            .width("100%")
            .height("100%")
        }
        .height(200)
      }
    }
    .columnsTemplate("1fr 1fr")
    .rowsGap(20)
    .padding(20)
    .columnsGap(20)
  }
}
```





:::color1
waterFlow和Grid布局类似，同样支持columnsTemplate和rowsTemplate通过 fr的形式对行和列进行分割

:::

+ 例子-做一个瀑布流的图片预览器

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709629622878-ad420bf6-9653-4203-a9cf-ae0b22dcc5ad.png)



```typescript
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct GoodWaterFlowCase {
  @State list: GoodItem[] = [
    {
      "id": 1,
      "goods_name": "班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣",
      "goods_img": "/pages/05/assets/1.webp",
      "goods_price": 108,
      "goods_count": 1,
    },
    {
      "id": 2,
      "goods_name": "嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮",
      "goods_img": "/pages/05/assets/2.webp",
      "goods_price": 129,
      "goods_count": 1,
    },
    {
      "id": 3,
      "goods_name": "思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套",
      "goods_img": "/pages/05/assets/3.webp",
      "goods_price": 198,
      "goods_count": 1,
    },
    {
      "id": 4,
      "goods_name": "思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套",
      "goods_img": "/pages/05/assets/4.webp",
      "goods_price": 99,
      "goods_count": 1,
    },
    {
      "id": 5,
      "goods_name": "幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮",
      "goods_img": "/pages/05/assets/5.webp",
      "goods_price": 156,
      "goods_count": 1,
    },
    {
      "id": 6,
      "goods_name": "ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女",
      "goods_img": "/pages/05/assets/6.webp",
      "goods_price": 142.8,
      "goods_count": 1,
    },
    {
      "id": 7,
      "goods_name": "幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套",
      "goods_img": "/pages/05/assets/7.webp",
      "goods_price": 219,
      "goods_count": 2,
    },
    {
      "id": 8,
      "goods_name": "依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套",
      "goods_img": "/pages/05/assets/8.webp",
      "goods_price": 178,
      "goods_count": 1,
    },
    {
      "id": 9,
      "goods_name": "芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬",
      "goods_img": "/pages/05/assets/9.webp",
      "goods_price": 128,
      "goods_count": 1,
    },
    {
      "id": 10,
      "goods_name": "Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫",
      "goods_img": "/pages/05/assets/10.webp",
      "goods_price": 153,
      "goods_count": 1,
    }
  ]
  @State
  loading: boolean = false // 是否正在加载数据

  @Builder
  getGoodBuilder(item: GoodItem, index: number) {
    FlowItem() {
      Column({ space: 20 }) {
        Image(item.goods_img)
          .width("100%")
          .height(index % 2 ? 180 : 220)
          .borderRadius(8)
        Text(item.goods_name)
          .fontSize(14)
          .lineHeight(22)
      }
    }
  }

  // 加载更多的数据
  async loadMore() {
    // 阀门控制  防抖节流只是降低频率
    // promptAction.showToast({ message: '滚动底部啦' })
    // setTimeout
    // resolve(成功时要执行的函数)
    // reject（失败时要执行的函数）
    // pending等待 fullfilled成功 rejected失败状态
    return new Promise<boolean>((resolve, reject) => {
      setTimeout(() => {
        // 等待一秒钟
        // 得到新的数据 放到新的数组里面
        this.list.push(...this.list.slice(0, 9)) // 直接往里面push10条数据
        resolve(true)
      }, 1000)
    })
  }

  @Builder
  getFooterBuilder() {
    // 正在加载
    if (this.loading) {
      Row({ space: 6 }) {
        Text("数据加载中...")
        LoadingProgress()
          .width(20)
          .height(20)
      }
      .justifyContent(FlexAlign.Center)
      .width("100%")
      .height(60)
    }
  }

  // Promise


  build() {
    WaterFlow({ footer: this.getFooterBuilder }) {
      ForEach(this.list, (item: GoodItem, index: number) => {
        // 使用FlowItem
        this.getGoodBuilder(item, index)
      })
    }
    .columnsTemplate("1fr 1fr")
    .columnsGap(20)
    .rowsGap(20)
    .padding(20)
    .onReachEnd(async () => {
      // promptAction.showToast({ message: '滚动底部啦' })
      if (!this.loading) {
        try {
          this.loading = true // 关门操作
          await this.loadMore() // 执行完毕
          this.loading = false // 开门操作
        } catch (error) {
        }
      }

    })
  }
}

class GoodItem {
  id: number = 0
  goods_name: string = ""
  goods_img: string = ""
  goods_price: number = 0
  goods_count: number = 0
}

```

:::success
async/await

+ async 表示该函数是一个异步函数- 不会阻塞任何的请求
+ await必须和async配合使用
+ await永远等待后面的promise执行resolve, 
+ 如果没有promise就重新返回一个
+ promise 三种状态 pending fullfilled . rejected失败
+ 同步和异步-同步和异步相遇，会将异步线程挂起， 等到主线程代码执行完毕，再去按照放入队列的顺序 取出执行-并拿结构，调用回调函数
+ setInterval/setTimeout/请求/动画回调函数 
+ 同步代码-除了代码都属于同步

:::

<h3 id="b0b3ecbc">3. 构建函数-传参传递</h3>
:::success
传的参数是按值的话，那个builder不具备响应式特征

传的参数是复杂数据， 而且复杂数据类型中的参数有响应式修饰符修饰，那么具备响应式特征

:::

```typescript
@Entry
@Component
struct BuilderTransCase {
  @State
  area: string = "望京"
  @Builder
  getCardItem (leftTitle: string, rightValue: string) {
    Row() {
      Text(leftTitle)
      Text(rightValue)
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(50)
    .borderRadius(8)
    .backgroundColor(Color.White)
    .padding({
      left: 20,
      right: 20
    })
  }
  @Builder
  getCardItemObj (item: ICardItem) {
    Row() {
      Text(item.leftTitle)
      Text(item.rightValue)
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(50)
    .borderRadius(8)
    .backgroundColor(Color.White)
    .padding({
      left: 20,
      right: 20
    })
  }

  build() {
   Column({ space: 20 }) {
     Text(this.area)
     this.getCardItem("异常位置", this.area)  // 按值传递不具备响应式
     this.getCardItemObj({  leftTitle: '异常位置', rightValue: this.area }) // 按照引用传递可以实现数据更新
     this.getCardItem("异常时间", "2023-12-12")
     this.getCardItem("异常类型", "漏油")
     Button("上报位置")
       .onClick(() => {
         this.area = "厦门"
       })
   }
   .justifyContent(FlexAlign.Center)
    .width('100%')
    .height('100%')
    .padding(20)
    .backgroundColor(Color.Gray)
  }
}
interface ICardItem {
  leftTitle: string
  rightValue: string
}
```

:::info
<font style="color:rgba(0, 0, 0, 0.9);">自定义构建函数的参数传递有</font>[按值传递](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-builder-0000001524176981-V3#section163841721135012)<font style="color:rgba(0, 0, 0, 0.9);">和</font>[按引用传递](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-builder-0000001524176981-V3#section1522464044212)<font style="color:rgba(0, 0, 0, 0.9);">两种，均需遵守以下规则：</font>

+ <font style="color:rgb(36, 39, 40);">参数的类型必须与参数声明的类型一致，不允许undefined、null和返回undefined、null的表达式。</font>
+ <font style="color:rgb(36, 39, 40);">在自定义构建函数内部，不允许改变参数值。如果需要改变参数值，且同步回调用点，建议使用</font>[@Link](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-link-0000001524297305-V3)<font style="color:rgb(36, 39, 40);">。</font>
+ <font style="color:rgb(36, 39, 40);">@Builder内UI语法遵循</font>[UI语法规则](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-create-custom-components-0000001473537046-V3#section1150911733811)<font style="color:rgb(36, 39, 40);">。</font>

:::

> 我们发现上一个案例，使用了string这种基础数据类型，即使它属于用State修饰的变量，也不会引起UI的变化
>



```typescript
@Entry
@Component
struct BuilderTransCase {
  @State
  salary: number = 7
  @State
  currentName: string = "章三"

  // 按照值传递
  @Builder
  getCardItem(leftTitle: string, rightValue: string) {
    Row() {
      Text(leftTitle)
      Text(rightValue)
    }
    .height(60)
    .padding({
      left: 10,
      right: 10
    })
    .justifyContent(FlexAlign.SpaceBetween)
    .backgroundColor(Color.White)
    .width("100%")
    .borderRadius(10)

  }

  @Builder
  getMyName() {
    Text(this.currentName)
      .fontSize(40)
  }

  @Builder
  getCardObj(item: CardItem) {
    Row() {
      Text(item.leftTitle)
      Text(item.rightValue.toString() + "万")
    }
    .height(60)
    .padding({
      left: 10,
      right: 10
    })
    .justifyContent(FlexAlign.SpaceBetween)
    .backgroundColor(Color.White)
    .width("100%")
    .borderRadius(10)

  }

  build() {
    Column({ space: 20 }) {
      this.getCardItem("姓名", "老高")
      this.getCardItem("年龄", "22")
      this.getCardObj({
        leftTitle: '年薪',
        rightValue: this.salary
      })
      this.getMyName()

      Text(this.salary.toString())
      Button("加薪")
        .onClick(() => {
          this.salary++
        })
      Button("修改名称")
        .onClick(() => {
          this.currentName = "老高"
        })
    }
    .backgroundColor(Color.Gray)
    .height('100%')
    .width('100%')
    .padding(10)
  }
}

interface CardItem {
  leftTitle: string,
  rightValue: number
}
```

+ 传值

```typescript
this.getCellContent({ leftTitle: '异常位置', rightValue: this.formData.location })
this.getCellContent({ leftTitle: '异常时间', rightValue: this.formData.time })
this.getCellContent({ leftTitle: '异常类型', rightValue: this.formData.type })
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1722931464298-fc96b764-1e26-4816-8e3a-b93814c380a0.png)



:::info
同样的，全局Builder同样支持这种用法

:::

```typescript
@Entry
@Component
struct BuilderCase {
  @State formData: CardClass = {
    time: "2023-12-12",
    location: '回龙观',
    type: '漏油'
  }
  @Builder
  getCellContent($$: CellParams) {
    Row() {
      Row() {
        Text($$.leftTitle)
        Text($$.rightValue)
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({
        left: 15,
        right: 15
      })
      .borderRadius(8)
      .height(40)
      .backgroundColor(Color.White)
    }.padding({
      left: 10,
      right: 10
    })

  }
  build() {
    Row() {
      Column() {
        Column({ space: 10 }) {
          this.getCellContent({ leftTitle: '异常时间', rightValue: this.formData.time })
          this.getCellContent({ leftTitle: '异常位置', rightValue: this.formData.location })
          this.getCellContent({ leftTitle: '异常类型', rightValue: this.formData.type })
        }
        .width('100%')
        Button("修改数据").onClick(() => {
          this.formData.location = "望京"
        })
      }
      .width('100%')
    }
    .height('100%')
    .backgroundColor('#ccc')
  }
}

class CardClass {
  time: string = ""
  location: string = ""
  type: string = ""
}
class CellParams {
  leftTitle: string = ""
  rightValue: string = ""
}
@Builder
function getCellContent($$: CellParams  ) {
  Row() {
    Row() {
      Text($$.leftTitle)
      Text($$.rightValue)
    }
    .width('100%')
    .justifyContent(FlexAlign.SpaceBetween)
    .padding({
      left: 15,
      right: 15
    })
    .borderRadius(8)
    .height(40)
    .backgroundColor(Color.White)
  }.padding({
    left: 10,
    right: 10
  })

}
```



:::info
+ 使用 `@Builder` 复用逻辑的时候，支持传参可以更灵活的渲染UI
+ 参数可以使用`状态数据`，不过建议通过对象的方式传入 `@Builder`

:::



<h3 id="dfn3m">4. 构建函数-简单示例</h3>
:::info
+ 接下来，我们来灵活的使用builder完成这样一个示例，页面初始化后两秒后加载一个用户信息，然后使builder函数渲染出来

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702099334212-2bf24000-4b95-46de-8397-2c4f3b768e97.png)



```typescript
class UserInfo {
  name: string = ""
  age: number = 0
  sex: "男" | "女" = "男"
  address: string = ""
}
class CaseCellParams {
  left: string = ""
  right: string = ""
}
@Entry
@Component
struct BuilderNoParams02 {
 @State userInfo: UserInfo  = {
    name: '',
    age: 0,
    sex: '男',
    address: ''
  }
  aboutToAppear() {
    setTimeout(() => {
      this.userInfo = {
        name: '老高',
        age: 34,
        sex: "男",
        address: '北京顺义'
      }
    }, 2000)
  }
  @Builder
  getContentItem ($$: CaseCellParams) {
    Row() {
      Row() {
        Text($$.left)
        Text($$.right)
      }
      .width('100%')
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({
        left: 15,
        right: 15
      })
      .borderRadius(8)
      .height(40)
      .backgroundColor(Color.White)
    }.padding({
      left: 10,
      right: 10
    })
  }
@Builder
  getContent () {
    this.getContentItem({ left: "姓名", right: this.userInfo.name  })
    this.getContentItem({ left: "年龄", right: this.userInfo.age.toString()  })
    this.getContentItem({ left: "性别", right: this.userInfo.sex  })
    this.getContentItem({ left: "地址", right: this.userInfo.address  })
  }

  build() {
    Column() {
      Column({ space: 10 }){
        this.getContent()
      }
      .margin({
        top: 50
      })
    }
    .height('100%')
    .backgroundColor('#ccc')
  }
}
```

<h3 id="ce9dadb0">5. 构建函数-[@BuilderParam ](/BuilderParam ) 传递UI </h3>
:::success
插槽-Vue-Slot React-RenderProps

+ 把UI结构体的函数(Builder修饰的函数)当成参数传入到组件中，让组件放入固定的位置去渲染
+ 子组件接收传入的函数的修饰符/装饰器叫做BuilderParam

:::

:::info
+ Component可以抽提组件
+ Builder可以实现轻量级的UI复用

 完善了吗？ 其实还不算，比如下面这个例子

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702100068539-204da172-d65f-41bd-8889-ef2f56316ba9.png)![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702100095074-5560fe5a-900a-46c6-b9c6-f2bbb879a56b.png)![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702100111339-1f8583ad-8e54-43cb-8c91-7317876561e5.png)

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702100143344-ec5f7e40-0ace-4d25-beec-12c17de21490.png)



:::info
大家发现没有，我们后面的神领物流项目中会有很多地方用到这种类似卡片Card的地方，但是里面的内容各有不同，怎么办？

 前端同学应该知道Vue里面有个叫做slot插槽的东西，就是可以传入自定义的结构，整体复用父组件的外观

ArkTS提供了一个叫做BuilderParam的修饰符，你可以在组件中定义这样一个函数属性，在使用组件时直接传入

+ BuilderParam只能应用在Component组件中，不能使用Entry修饰的组件中使用

:::



:::success
使用BuilderParam的步骤

+ 需要出现父子组件的关系
+ BuilderParam应出现在子组件中
+ @BuilderParam  getConent: () => void
+ BuilderParam的参数可以不给初始值，如果给了初始值， 就是没有内容的默认内容
+ 父组件传入的时候，它需要用builder修饰的函数又或者是 一个箭头函数中包裹着
+ 调用builder函数的逻辑

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709646412074-794118ee-5c9a-4eb0-9888-7b1694788c6f.png)

:::



```typescript
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct BuilderParamCase {
  name: string = "我是你爸爸"

  @Builder
  getImageContent() {
    Row() {
      Image("http://gips2.baidu.com/it/u=3093819921,829322739&fm=3028&app=3028&f=JPEG&fmt=auto?w=1024&h=1024")
        .width("100%")
        .height(100)
    }
    .onClick(() => {
      promptAction.showToast({ message: this.name })
    })
  }

  @Builder
  getBtnContent() {
    Button("底部按钮")
      .width("100%")
  }

  build() {
    Column({ space: 10 }) {
      HmCard({
        getContent: () => {
          // this指向父组件
          this.getImageContent()
        },
        // getFooterContent: () => {
        //   this.getBtnContent()
        // }
        // getContent: this.getImageContent // 渲染没问题 逻辑非常容易乱
      })

      HmCard() {
        // 尾随闭包
        // 大括号里面的内容会被自动封装成一个builder函数传递给默认的那一个builder函数
        this.getImageContent() // 调用
        //  this.getImageContent // 没有执行
      }

    }
    .padding(20)
    .height('100%')
    .width('100%')
    .backgroundColor(Color.Green)
  }
}

@Component
struct HmCard {
  name: string = "我是子组件"
  @BuilderParam
  getContent: () => void = this.getDefaultBuilder

  // @BuilderParam
  // getFooterContent: () => void = this.getDefaultBuilder

  @Builder
  getDefaultBuilder() {
    Text("默认内容")
  }

  build() {
    Column({ space: 20 }) {
      Row() {
        Text("取消")
        Text("确定")
      }
      .width("100%")
      .padding({
        left: 10,
        right: 10
      })
      .justifyContent(FlexAlign.SpaceBetween)
      .height(60)
      .border({
        color: '#ccc',
        width: {
          bottom: 2
        }
      })


      // 放置内容
      // 先判断函数是否存在
      if (this.getContent) {
        this.getContent()
      }
      // if (this.getFooterContent) {
      //   this.getFooterContent()
      // }
    }
    .width("100%")
    .height(300)
    .backgroundColor(Color.White)
    .borderRadius(10)
  }
}


// 函数中的this指向谁？ => （没有箭头函数的情况下）this永远指向调用者
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1722934424683-293ce5d8-57c9-4aea-ad52-329221583e0b.png)

+ 多个builderParam的使用

```typescript
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct BuilderParamCase {
  name: string = "我是你爸爸"

  @Builder
  getImageContent() {
    Row() {
      Image("http://gips2.baidu.com/it/u=3093819921,829322739&fm=3028&app=3028&f=JPEG&fmt=auto?w=1024&h=1024")
        .width("100%")
        .height(100)
    }
    .onClick(() => {
      promptAction.showToast({ message: this.name })
    })
  }

  @Builder
  getBtnContent() {
    Button("底部按钮")
      .width("100%")
  }

  build() {
    Column({ space: 10 }) {
      HmCard({
        getContent: () => {
          // this指向父组件
          this.getImageContent()
        },
        // getFooterContent: () => {
        //   this.getBtnContent()
        // }
        // getContent: this.getImageContent // 渲染没问题 逻辑非常容易乱
      })

      HmCard() {
        // 尾随闭包
        // 大括号里面的内容会被自动封装成一个builder函数传递给默认的那一个builder函数
        this.getImageContent() // 调用
        //  this.getImageContent // 没有执行
      }

    }
    .padding(20)
    .height('100%')
    .width('100%')
    .backgroundColor(Color.Green)
  }
}

@Component
struct HmCard {
  name: string = "我是子组件"
  @BuilderParam
  getContent: () => void = this.getDefaultBuilder

  // @BuilderParam
  // getFooterContent: () => void = this.getDefaultBuilder

  @Builder
  getDefaultBuilder() {
    Text("默认内容")
  }

  build() {
    Column({ space: 20 }) {
      Row() {
        Text("取消")
        Text("确定")
      }
      .width("100%")
      .padding({
        left: 10,
        right: 10
      })
      .justifyContent(FlexAlign.SpaceBetween)
      .height(60)
      .border({
        color: '#ccc',
        width: {
          bottom: 2
        }
      })


      // 放置内容
      // 先判断函数是否存在
      if (this.getContent) {
        this.getContent()
      }
      // if (this.getFooterContent) {
      //   this.getFooterContent()
      // }
    }
    .width("100%")
    .height(300)
    .backgroundColor(Color.White)
    .borderRadius(10)
  }
}


// 函数中的this指向谁？ => （没有箭头函数的情况下）this永远指向调用者
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1722934442952-bdc7ff92-a714-4e6e-aca9-06acce936f9e.png)



+ builderParam传值

:::success
+ 当我们使用builderParam的时候，又需要拿到渲染的数据该怎么办？

场景：  **<font style="color:#DF2A3F;">当我们有一个列表组件，该组件的列表格式是固定的，但是每个选项的内容由传入的结构决定怎么搞？</font>**

+ 列表组件可以渲染数据-但是每一个选项的UI结构由使用者决定

:::

+ 封装一个列表的组件，可以渲染传入的数组

```typescript
@Preview
@Component
// 列表组件
struct HmList {
  @State
  list: object[] = [] // 不知道传入的是什么类型 统一认为是object
  @BuilderParam
  renderItem: (obj: object) => void

  build() {
    // Grid List WaterFlow
    // 渲染数组
    List ({ space: 10 }) {
      ForEach(this.list, (item: object) => {
        ListItem() {
          // 自定义的结构
          if(this.renderItem) {
            this.renderItem(item)
            // 函数中的this始终指向调用者
          }
        }
      })
    }
    .padding(20)
  }
}
export { HmList }

// WaterFlow FlowItem  Grid GirdItem  List ListItem
```

+ 父组件调用

```typescript
import { HmList } from './components/HmList'
import { GoodItem } from '../04/models'

@Entry
@Component
struct BuilderParamTransParam {
  @State
  list: GoodItem[] = [
    {
      "id": 1,
      "goods_name": "班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣",
      "goods_img": "assets/1.webp",
      "goods_price": 108,
      "goods_count": 1,
    },
    {
      "id": 2,
      "goods_name": "嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮",
      "goods_img": "assets/2.webp",
      "goods_price": 129,
      "goods_count": 1,
    },
    {
      "id": 3,
      "goods_name": "思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套",
      "goods_img": "assets/3.webp",
      "goods_price": 198,
      "goods_count": 1,
    },
    {
      "id": 4,
      "goods_name": "思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套",
      "goods_img": "assets/4.webp",
      "goods_price": 99,
      "goods_count": 1,
    },
    {
      "id": 5,
      "goods_name": "幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮",
      "goods_img": "assets/5.webp",
      "goods_price": 156,
      "goods_count": 1,
    },
    {
      "id": 6,
      "goods_name": "ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女",
      "goods_img": "assets/6.webp",
      "goods_price": 142.8,
      "goods_count": 1,
    },
    {
      "id": 7,
      "goods_name": "幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套",
      "goods_img": "assets/7.webp",
      "goods_price": 219,
      "goods_count": 2,
    },
    {
      "id": 8,
      "goods_name": "依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套",
      "goods_img": "assets/8.webp",
      "goods_price": 178,
      "goods_count": 1,
    },
    {
      "id": 9,
      "goods_name": "芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬",
      "goods_img": "assets/9.webp",
      "goods_price": 128,
      "goods_count": 1,
    },
    {
      "id": 10,
      "goods_name": "Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫",
      "goods_img": "assets/10.webp",
      "goods_price": 153,
      "goods_count": 1,
    }
  ]

  @Builder
  getRealItem (item: GoodItem) {
    Row({ space: 10 }) {
      Image(item.goods_img)
        .borderRadius(8)
        .width(120)
        .height(200)
      Column() {
        Text(item.goods_name)
          .fontWeight(FontWeight.Bold)
        Text("¥ "+item.goods_price.toString())
          .fontColor(Color.Red)
          .fontWeight(FontWeight.Bold)
      }
      .padding({
        top: 5,
        bottom: 5
      })
      .alignItems(HorizontalAlign.Start)
      .justifyContent(FlexAlign.SpaceBetween)
      .height(200)
      .layoutWeight(1)
    }
    .width('100%')
  }

  build() {
    Column() {
      HmList({
        list: this.list,
        renderItem: (item: object) => {
          this.getRealItem(item as GoodItem)
        }
      })
      // HmList() 意味着 new了组件 HmList的实例  方舟会将小括号中的参数 先覆盖对象的初始值 然后再实例化
    }
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709812805232-020d7032-ee61-4e2e-94c7-f9c9e73e730d.png)

+ 尾随闭包

:::success
Column () {  } 中大括号就是尾随闭包的写法

:::

:::info
当我们的组件**<font style="color:#DF2A3F;">只有一个BuilderParam</font>**的时候，此时可以使用**<font style="color:#DF2A3F;">尾随闭包</font>**的语法 也就是像我们原来使用Column或者Row组件时一样，直接在大括号中传入， 如下

:::

+ 封装一个HmPanel的组件

```typescript
@Preview
@Component
struct HmPanel {
  panelHeight: number = 300
  @BuilderParam
  body: () => void
  panelColor: ResourceColor = Color.Gray
  build() {
    Column() {
      Column() {
        if(this.body) {
          this.body()
        }
      }
      .backgroundColor(this.panelColor)
      .width('100%')
      .height(this.panelHeight)
      .borderRadius(20)

    }
    .padding(20)
  }
}
export { HmPanel }
```

+ 父组件使用尾随闭包传入

```typescript
import { HmPanel } from './components/HmPanel'

@Entry
@Component
struct BuilderParamDangle {
  build() {
    Column({ space: 20 }) {
      // 只有一个builderParam的时候可以使用尾随闭包
      // 当没有builderParam没有参数传出的时候 可以用尾随闭包
      HmPanel({ panelHeight: 200, panelColor: Color.Pink }) {
        Flex({ direction: FlexDirection.Row, wrap: FlexWrap.Wrap }) {
          // 尾随闭包内容 传入
          ForEach([1,2,3,4,5,6], (item: number) => {
            Button("测试" + item)
              .margin({
                left: 10,
                top: 10
              })
          })
        }
        Column({ space: 20 }) {
          Progress({ value: 10, total: 20 })

          Progress({ value: 10, total: 20 })

          Progress({ value: 10, total: 20 })

          Progress({ value: 10, total: 20 })

          Progress({ value: 10, total: 20 })
        }


      }
      HmPanel({ panelHeight: 100, panelColor: Color.Orange }) {

      }

    }
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709814438752-35666761-cc86-4d5f-8eeb-e680a3124c15.png)

+ 如果有多个呢，不好意思，你必须在组件的函数中老老实实的传入多个builder自定义函数

```typescript
@Component
struct  HMCard {
  @BuilderParam
  content: () => void
  @BuilderParam
  header: () => void
  build() {
    Column () {
      Text("卡片组件")
      if(this.header) {
        this.header()
      }
      Divider()
      Text("传入内容")
      if(this.content) {
        this.content()
      }
    }
  }
}

@Entry
@Component
struct BuilderParamCase {

  @Builder
  getContent () {
    Row() {
      Text("插槽内容")
        .fontColor(Color.Red)
    }
  }
  @Builder
  getHeader () {
    Row() {
      Text("头部内容")
        .fontColor(Color.Red)
    }
  }
  build() {
    Row() {
      Column() {
         HMCard({
          header: () => {
            this.getHeader()
          },
          content: () => {
            this.getContent()
          }
        })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```



:::info
案例- 封装HmCard 和HmCardItem组件， 使用BuilderParam属性完成神领物流的效果图



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702100143344-ec5f7e40-0ace-4d25-beec-12c17de21490.png)

:::



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702102826141-31345e30-48b0-4f28-8ccd-72bd317b375f.png)

代码

```typescript
@Entry
@Component
struct BuilderParamCard02 {
  @State message: string = 'Hello World'

  build() {
    Column() {
      HmCard() {
        HmCardItem({ leftTitle: '员工姓名', rightValue: '张三' })
        HmCardItem({ leftTitle: '员工编号', rightValue: '30032' })
        HmCardItem({ leftTitle: '员工权限', rightValue: '普通' })
        HmCardItem({ leftTitle: '员工组织', rightValue: '研发部' })
        HmCardItem({ leftTitle: '员工上级', rightValue: '老高' })
      }
    }
    .height('100%')
    .backgroundColor("#ccc")
  }
}

@Component
struct HmCard {
  @BuilderParam
  CardFn: () => void
  build() {
    Column() {
      Column() {
        if(this.CardFn) {
          this.CardFn()
        }
      }.borderRadius(8)
      .backgroundColor(Color.White)

    }.padding({
      left: 15,
      right: 15
    })
    .margin({
      top: 10
    })


  }
}
@Component
struct HmCardItem {
  leftTitle: string = ''
  rightValue: string = ''
  build() {
    Row() {
      Text(this.leftTitle)
      Text(this.rightValue).fontColor("#ccc")
    }.width('100%')
    .stateStyles({
      normal: {
        .backgroundColor(Color.White)
      },
      pressed: {
        .backgroundColor("#F3f4f5")
      }
    })
    .justifyContent(FlexAlign.SpaceBetween)
    .padding({
      left: 10,
      right: 10
    })
    .height(50)
    .border({
      width: {
        bottom: 1
      },
      color: '#f4f5f6'
    })
  }
}
```

<h2 id="447baccd">2.组件状态共享</h2>
:::color2
State是当前组件的状态， 用State修饰的数据变化会驱动UI的更新（只有第一层）

父传子的时候，子组件定义变量的时候，如果没有任何的修饰符，那么该值只会在第一次渲染时生效

:::

:::info
接下来，我们学习组件状态传递

我们知道 State是当前组件的状态，它的数据变化可以驱动UI，但是子组件接收的数据没办法更新，我们需要

更多的修饰符来帮助我们完成数据的响应式传递

:::

<h3 id="8d992de3">1. 状态共享-父子单向</h3>
> `@Prop` 装饰的变量可以和父组件建立单向的同步关系。`@Prop` 装饰的变量是可变的，但是变化不会同步回其父组件。-Prop是用在子组件中的
>

:::info
Prop 支持类型和State修饰符基本一致，并且**<font style="color:#DF2A3F;">Prop可以给初始值，也可以不给</font>**

:::

+ 完成父 - 子的单向同步

```typescript
@Entry
@Component
struct PropCase {
  @State pnum: number = 0
  build() {
    Row() {
      Column() {
        Text(this.pnum.toString())
        Button("+1")
          .onClick(() => {
            this.pnum++
          })

        Divider()
        Child({ num: this.pnum })
      }
      .width('100%')
    }
    .height('100%')
  }
}

@Component
struct Child {
  @Prop num: number
  build() {
    Column() {
      Text("子组件")
      Text(this.num.toString())
    }.height(60)
    .width('100%')
    .backgroundColor(Color.Pink)
  }
}
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702104880851-f31b31d5-c0af-4476-81f4-75ea6fc8ff8a.png)

:::info
如果子组件修改这个Prop呢？

我们来试试

:::

```typescript
 Button("修改子组件Prop")
        .onClick(() => {
          this.num++
        })
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702104999557-3cd3d471-32ca-46e2-b73c-4cb4d5a7eec7.png)

:::info
我们发现使用Prop修饰的状态，只会在当前子组件生效，不会传导到父组件，所以它属于一种单向传递

+ 子组件可修改 `Prop` 数据值，但不同步到父组件，父组件更新后覆盖子组件 `Prop` 数据
+ 子组件可以初始化默认值

:::

:::color1
Prop如果传递是对象类型，它只会在子组件内部生效，不会延伸到父组件-

:::



:::success
网络相册案例

+ 点个按钮，出现选择照片的相册
+ 选择完成之后， 点击完成图片回显示到页面

:::

+ 基础相册封装和使用

```typescript
import { GoodItem } from '../04/models'
@Entry
@Component
struct PropBigCase {
  @State
  showAlbum: boolean = false
  @State
  list: GoodItem[] = [
    {
      "id": 1,
      "goods_name": "班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣",
      "goods_img": "assets/1.webp",
      "goods_price": 108,
      "goods_count": 1,
    },
    {
      "id": 2,
      "goods_name": "嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮",
      "goods_img": "assets/2.webp",
      "goods_price": 129,
      "goods_count": 1,
    },
    {
      "id": 3,
      "goods_name": "思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套",
      "goods_img": "assets/3.webp",
      "goods_price": 198,
      "goods_count": 1,
    },
    {
      "id": 4,
      "goods_name": "思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套",
      "goods_img": "assets/4.webp",
      "goods_price": 99,
      "goods_count": 1,
    },
    {
      "id": 5,
      "goods_name": "幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮",
      "goods_img": "assets/5.webp",
      "goods_price": 156,
      "goods_count": 1,
    },
    {
      "id": 6,
      "goods_name": "ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女",
      "goods_img": "assets/6.webp",
      "goods_price": 142.8,
      "goods_count": 1,
    },
    {
      "id": 7,
      "goods_name": "幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套",
      "goods_img": "assets/7.webp",
      "goods_price": 219,
      "goods_count": 2,
    },
    {
      "id": 8,
      "goods_name": "依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套",
      "goods_img": "assets/8.webp",
      "goods_price": 178,
      "goods_count": 1,
    },
    {
      "id": 9,
      "goods_name": "芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬",
      "goods_img": "assets/9.webp",
      "goods_price": 128,
      "goods_count": 1,
    },
    {
      "id": 10,
      "goods_name": "Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫",
      "goods_img": "assets/10.webp",
      "goods_price": 153,
      "goods_count": 1,
    }
  ]

  build() {
     Column() {
       Button("选择图片")
         .onClick(() => {
           this.showAlbum = true
         })
       if(this.showAlbum) {
         PhotoAlbum({
           list: this.list,
           maxSelectNumber: 2,
           close: () => {
             this.showAlbum = false
           }
         })
       }
     }
    .width('100%')
    .height('100%')
    .padding(2)
  }
}

@Component
struct PhotoAlbum {
  @Prop
  maxSelectNumber: number = 9 // 设置可选择的图片的张数
  @Prop
  list: GoodItem[] = []
  close: () => void = () => {}
  build() {
    Column() {
      Grid() {
        // 数据的
        ForEach(this.list, (item: GoodItem) => {
          GridItem() {
            Image(item.goods_img)
              .aspectRatio(1)
              .onClick(() => {
                // 通过一个标记 能够知道当前的图片到底是选中还是没选中 如果选中 取消选中
                // 如果没选中 则选中 可以设置最多选择9张图片
              })
          }
        })
      }
      .columnsGap(2)
      .rowsGap(2)
      .columnsTemplate("1fr 1fr 1fr")
      .layoutWeight(1)
      Row() {
         Button("取消")
           .onClick(() => {
             this.close()
           })
           .backgroundColor(Color.Gray)
         Text(`可选${this.maxSelectNumber}张`)
        Button("完成")
      }
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({
        left: 10,
        right: 10
      })
      .height(50)
      .width('100%')

    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height('100%')
    .backgroundColor(Color.White)
    .position({
      x: 0,
      y: 0
    })
  }
}
```



![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709818801927-b455875b-e692-4cb9-9c20-818c82a22964.png)



+ 相册选择

```typescript
import { GoodItem } from '../04/models'
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct PropBigCase {
  @State
  showAlbum: boolean = false
  @State
  list: GoodItem[] = [
    {
      "id": 1,
      "goods_name": "班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣",
      "goods_img": "assets/1.webp",
      "goods_price": 108,
      "goods_count": 1,
    },
    {
      "id": 2,
      "goods_name": "嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮",
      "goods_img": "assets/2.webp",
      "goods_price": 129,
      "goods_count": 1,
    },
    {
      "id": 3,
      "goods_name": "思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套",
      "goods_img": "assets/3.webp",
      "goods_price": 198,
      "goods_count": 1,
    },
    {
      "id": 4,
      "goods_name": "思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套",
      "goods_img": "assets/4.webp",
      "goods_price": 99,
      "goods_count": 1,
    },
    {
      "id": 5,
      "goods_name": "幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮",
      "goods_img": "assets/5.webp",
      "goods_price": 156,
      "goods_count": 1,
    },
    {
      "id": 6,
      "goods_name": "ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女",
      "goods_img": "assets/6.webp",
      "goods_price": 142.8,
      "goods_count": 1,
    },
    {
      "id": 7,
      "goods_name": "幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套",
      "goods_img": "assets/7.webp",
      "goods_price": 219,
      "goods_count": 2,
    },
    {
      "id": 8,
      "goods_name": "依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套",
      "goods_img": "assets/8.webp",
      "goods_price": 178,
      "goods_count": 1,
    },
    {
      "id": 9,
      "goods_name": "芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬",
      "goods_img": "assets/9.webp",
      "goods_price": 128,
      "goods_count": 1,
    },
    {
      "id": 10,
      "goods_name": "Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫",
      "goods_img": "assets/10.webp",
      "goods_price": 153,
      "goods_count": 1,
    }
  ]

  build() {
     Column() {
       Button("选择图片")
         .onClick(() => {
           this.showAlbum = true
         })
       if(this.showAlbum) {
         PhotoAlbum({
           list: this.list,
           maxSelectNumber: 9,
           close: () => {
             this.showAlbum = false
           }
         })
       }
     }
    .width('100%')
    .height('100%')
    .padding(2)
  }
}

@Component
struct PhotoAlbum {
  @Prop
  maxSelectNumber: number = 9 // 设置可选择的图片的张数
  @Prop
  list: GoodItem[] = []
  @State
  selectPhotos: SelectPhoto[] = []
  close: () => void = () => {}

  // 用来选中或者取消选中图片
  selectImage (item: GoodItem) {
    // 通过一个标记 能够知道当前的图片到底是选中还是没选中 如果选中 取消选中
    // 如果没选中 则选中 可以设置最多选择9张图片
    const index = this.selectPhotos.findIndex(obj => obj.imgId === item.id)
    if(index > -1) {
      // 表示已经选择了 选中的化需要移除
      // 数组移除
      // 先找索引
      // 再通过吧splice进行移除
      this.selectPhotos.splice(index, 1) // 移除一个内容
      promptAction.showToast({ message: '执行移除' })
    }
    else {
      // 当选择张数小于最大张数时才可以继续
      if(this.selectPhotos.length < this.maxSelectNumber) {
        // 没有选中
        this.selectPhotos.push({ imgUrl: item.goods_img, imgId: item.id })
      }
    }
  }
  // 获取是否显示对号
  getShowSelect (item: GoodItem) {
   return  this.selectPhotos.findIndex(obj => obj.imgId === item.id) > -1
  }
  build() {
    Column() {
      Grid() {
        // 数据的
        ForEach(this.list, (item: GoodItem) => {
          GridItem() {
            Stack({ alignContent: Alignment.BottomEnd }) {
              Image(item.goods_img)
                .aspectRatio(1)

                if(this.getShowSelect(item)) {
                  // 需要展示对号
                  Image($r("app.media.select"))
                    .width(60)
                    .height(60)
                    .fillColor(Color.Orange)
                }
            }
            .onClick(() => {
              // 通过一个标记 能够知道当前的图片到底是选中还是没选中 如果选中 取消选中
              // 如果没选中 则选中 可以设置最多选择9张图片
              this.selectImage(item)
            })
          }
        })
      }
      .columnsGap(2)
      .rowsGap(2)
      .columnsTemplate("1fr 1fr 1fr")
      .layoutWeight(1)
      Row() {
         Button("取消")
           .onClick(() => {
             this.close()
           })
           .backgroundColor(Color.Gray)
         Text(`已选${this.selectPhotos.length}/ 可选${this.maxSelectNumber}张`)
        Button("完成")
      }
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({
        left: 10,
        right: 10
      })
      .height(50)
      .width('100%')

    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height('100%')
    .backgroundColor(Color.White)
    .position({
      x: 0,
      y: 0
    })
  }
}

interface SelectPhoto {
  imgUrl: string | ResourceColor
  imgId: number
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709820323157-b6eacd69-cbd4-4e19-8f50-0395e1e0b6bf.png)

:::success
新的诉求

  希望点击图片-完成图片的预览

需要使用弹出层- 两种的使用方式- dialog - sheet

:::

+ 弹窗UI的第一种方式CustomDialog

:::success
struct这个结构体只能被 Component和CustomDialog修饰

+ 必须被CustomDialog修饰
+ 组件中必须有一个属性 它的类型是 CustomDialogController,名字其实无所谓
+ Component的修饰符可以没有，有的话意味着它可以作为组件使用

:::

```typescript
@CustomDialog
struct PreviewDialog {
  controller: CustomDialogController // 控制器
  url: ResourceStr = ""
  build() {
    Column() {
      Image(this.url)
        .width('100%')
    }.backgroundColor(Color.Black)
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width("100%")
    .onClick(() => {
        this.controller.close()
    })
  }
}
```

+ 如果需要使用弹层，需要在使用的组件或者页面中显示的声明一个对象

```typescript
// 显示声明对象 类型未CustomDialogController
  preview: CustomDialogController = new CustomDialogController({
    builder: PreviewDialog({ url: this.selectImg }), // 这里需要传入 自定义弹层的对象
    customStyle: true  // 按照弹层的样式来渲染
  })
```

:::success
customStyle的意思是否允许自定义的样式设置，因为默认的弹层是有一些定制的样式的。

:::

+ 弹层就两个方法

:::success
open- 创建弹层组件-显示-会有动画的弹出

close- 销毁组件-推出-会有动画的退出

:::

+ 涉及到Dialog的传值

:::success
因为open/close会创建和销毁组件，不存在缓存现象，里面的参数实际上没有任何必要用修饰符

:::

+ 在父组件中调用打开

```typescript
GridItem() {
             Image(item.imgUrl)
               .aspectRatio(1)
               .borderRadius(4)
               .onClick(() => {
                 this.selectImg = item.imgUrl
                 // 弹出层 显示图片
                  this.preview.open()
               })
           }
```

+ 在本身组件中同样是可以打开和关闭

```typescript
.onClick(() => {
        this.controller.close()
    })
```

+ sheet的用法

:::success
+ 弹出框-类似于ios的交互-底部推到屏幕中的一个区域-可能有半屏或者全屏的区域
+ 不需要使用组件
+ 使用的是通用属性 bindSheet，可以通过该属性设置弹出框的 变量控制，内容控制，属性控制

:::

```typescript
.bindSheet($$this.showAlbum, this.getSheetBuilder(), {
      showClose: false
    })
```

:::success
$$ 为什么在这里使用？

因为需要数据驱动视图，视图发生变化，它同样需要更新数据

:::

+ 视图内容

```typescript
// 渲染相册的内容
  // Entry修饰的方法 可以没有根节点 但是 如果有的话 必须该组件是个容器组件
  @Builder
  getSheetBuilder() {
    // 坑点 bindSheet的内容最外层需要用原生组件才可以
    Column() {
      PhotoAlbum({
        list: this.list,
        maxSelectNumber: 5,
        close: () => {
           this.showAlbum = false
        },
        finish: (selectPhotos: SelectPhoto[]) => {
          this.selectList.push(...selectPhotos)
          this.showAlbum = false
        }
      })
    }
  }
```

:::success
诉求： 需要弹出的照片需要进行滑动- Swiper 轮播图

就是一个组件Swiper, 自动的可以实现滑动， 可以实现上下和左右， 可以双向绑定组件的当前的激活索引 index



:::



```typescript
@CustomDialog
struct PreviewDialog {
  controller: CustomDialogController // 控制器
  urls: ResourceStr [] = []
  @State
  selectIndex: number  = 0
  build() {
    Column() {
      Swiper() {
        ForEach(this.urls, (url: string) => {
          Image(url)
            .width('100%')
        })
      }.index($$this.selectIndex)
    }
    .backgroundColor(Color.Black)
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width("100%")
    .onClick(() => {
      this.controller.close()
    })
  }
}
```





+ 相册综合案例的完整代码

```typescript
import { GoodItem } from '../04/models'
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct PropBigCase {
  @State
  showAlbum: boolean = false
  @State
  list: GoodItem[] = [
    {
      "id": 1,
      "goods_name": "班俏BANQIAO超火ins潮卫衣女士2020秋季新款韩版宽松慵懒风薄款外套带帽上衣",
      "goods_img": "assets/1.webp",
      "goods_price": 108,
      "goods_count": 1,
    },
    {
      "id": 2,
      "goods_name": "嘉叶希连帽卫衣女春秋薄款2020新款宽松bf韩版字母印花中长款外套ins潮",
      "goods_img": "assets/2.webp",
      "goods_price": 129,
      "goods_count": 1,
    },
    {
      "id": 3,
      "goods_name": "思蜜怡2020休闲运动套装女春秋季新款时尚大码宽松长袖卫衣两件套",
      "goods_img": "assets/3.webp",
      "goods_price": 198,
      "goods_count": 1,
    },
    {
      "id": 4,
      "goods_name": "思蜜怡卫衣女加绒加厚2020秋冬装新款韩版宽松上衣连帽中长款外套",
      "goods_img": "assets/4.webp",
      "goods_price": 99,
      "goods_count": 1,
    },
    {
      "id": 5,
      "goods_name": "幂凝早秋季卫衣女春秋装韩版宽松中长款假两件上衣薄款ins盐系外套潮",
      "goods_img": "assets/5.webp",
      "goods_price": 156,
      "goods_count": 1,
    },
    {
      "id": 6,
      "goods_name": "ME&CITY女装冬季新款针织抽绳休闲连帽卫衣女",
      "goods_img": "assets/6.webp",
      "goods_price": 142.8,
      "goods_count": 1,
    },
    {
      "id": 7,
      "goods_name": "幂凝假两件女士卫衣秋冬女装2020年新款韩版宽松春秋季薄款ins潮外套",
      "goods_img": "assets/7.webp",
      "goods_price": 219,
      "goods_count": 2,
    },
    {
      "id": 8,
      "goods_name": "依魅人2020休闲运动衣套装女秋季新款秋季韩版宽松卫衣 时尚两件套",
      "goods_img": "assets/8.webp",
      "goods_price": 178,
      "goods_count": 1,
    },
    {
      "id": 9,
      "goods_name": "芷臻(zhizhen)加厚卫衣2020春秋季女长袖韩版宽松短款加绒春秋装连帽开衫外套冬",
      "goods_img": "assets/9.webp",
      "goods_price": 128,
      "goods_count": 1,
    },
    {
      "id": 10,
      "goods_name": "Semir森马卫衣女冬装2019新款可爱甜美大撞色小清新连帽薄绒女士套头衫",
      "goods_img": "assets/10.webp",
      "goods_price": 153,
      "goods_count": 1,
    }
  ]
  @State
  selectList: SelectPhoto[] = []
  selectImg: ResourceStr = ''

  selectIndex: number = 0

  // 显示声明对象 类型未CustomDialogController
  preview: CustomDialogController = new CustomDialogController({
    builder: PreviewDialog({ urls: this.selectList.map(item => item.imgUrl), selectIndex: this.selectIndex }), // 这里需要传入 自定义弹层的对象
    customStyle: true, // 按照弹层的样式来渲染
    cancel: () => {

    }
  })
  // 渲染相册的内容
  // Entry修饰的方法 可以没有根节点 但是 如果有的话 必须该组件是个容器组件
  @Builder
  getSheetBuilder() {
    // 坑点 bindSheet的内容最外层需要用原生组件才可以
    Column() {
      PhotoAlbum({
        list: this.list,
        maxSelectNumber: 5,
        close: () => {
           this.showAlbum = false
        },
        finish: (selectPhotos: SelectPhoto[]) => {
          this.selectList.push(...selectPhotos)
          this.showAlbum = false
        }
      })
    }
  }

  build() {
    Column({ space: 10 }) {
      Button("选择图片")
        .onClick(() => {
          this.showAlbum = true
        })

      // 渲染选择的图片
      Grid() {
        ForEach(this.selectList, (item: SelectPhoto, index: number) => {
          GridItem() {
            Image(item.imgUrl)
              .aspectRatio(1)
              .borderRadius(4)
              .onClick(() => {
                 this.selectIndex = index // 记录点击的索引
                // 弹出层 显示图片
                this.preview.open()
              })
          }
        })
      }
      .columnsTemplate("1fr 1fr")
      .columnsGap(2)
      .rowsGap(2)
    }
    .width('100%')
    .height('100%')
    .padding(2)
    .bindSheet($$this.showAlbum, this.getSheetBuilder(), {
      showClose: false,
      height: '70%'
    })
    // 数据变化 可以驱动视图的更新
    // 视图的更新无法驱动数据的变化
  }
}

@Component
struct PhotoAlbum {
  @Prop
  maxSelectNumber: number = 9 // 设置可选择的图片的张数
  @Prop
  list: GoodItem[] = []
  @State
  selectPhotos: SelectPhoto[] = []
  close: () => void = () => {
  }
  finish: (selectPHOTOES: SelectPhoto[]) => void = () => {
  }

  // 用来选中或者取消选中图片
  selectImage(item: GoodItem) {
    // 通过一个标记 能够知道当前的图片到底是选中还是没选中 如果选中 取消选中
    // 如果没选中 则选中 可以设置最多选择9张图片
    const index = this.selectPhotos.findIndex(obj => obj.imgId === item.id)
    if (index > -1) {
      // 表示已经选择了 选中的化需要移除
      // 数组移除
      // 先找索引
      // 再通过吧splice进行移除
      this.selectPhotos.splice(index, 1) // 移除一个内容
      promptAction.showToast({ message: '执行移除' })
    }
    else {
      // 当选择张数小于最大张数时才可以继续
      if (this.selectPhotos.length < this.maxSelectNumber) {
        // 没有选中
        this.selectPhotos.push({ imgUrl: item.goods_img, imgId: item.id })
      }
    }
  }

  // 获取是否显示对号
  getShowSelect(item: GoodItem) {
    return this.selectPhotos.findIndex(obj => obj.imgId === item.id) > -1
  }

  build() {
    Column() {
      Row() {
        Button("取消")
          .onClick(() => {
            this.close()
          })
          .backgroundColor(Color.Gray)
        Text(`已选${this.selectPhotos.length}/可选${this.maxSelectNumber}张`)
        Button("完成")
          .onClick(() => {
            this.finish(this.selectPhotos)
          })
      }
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({
        left: 10,
        right: 10
      })
      .zIndex(40)
      .height(50)
      .width('100%')
      Grid() {
        // 数据的
        ForEach(this.list, (item: GoodItem) => {
          GridItem() {
            Stack({ alignContent: Alignment.BottomEnd }) {
              Image(item.goods_img)
                .aspectRatio(1)

              if (this.getShowSelect(item)) {
                // 需要展示对号
                Image($r("app.media.select"))
                  .width(60)
                  .height(60)
                  .fillColor(Color.Orange)
              }
            }
            .onClick(() => {
              // 通过一个标记 能够知道当前的图片到底是选中还是没选中 如果选中 取消选中
              // 如果没选中 则选中 可以设置最多选择9张图片
              this.selectImage(item)
            })
          }
        })
      }
      .columnsGap(2)
      .rowsGap(2)
      .columnsTemplate("1fr 1fr 1fr")
      .layoutWeight(1)



    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height('100%')
    .backgroundColor(Color.White)
  }
}

interface SelectPhoto {
  imgUrl: string | ResourceStr
  imgId: number
}

//

@CustomDialog
struct PreviewDialog {
  controller: CustomDialogController // 控制器
  urls: ResourceStr [] = []
  @State
  selectIndex: number  = 0
  build() {
    Column() {
      Swiper() {
        ForEach(this.urls, (url: string) => {
          Image(url)
            .width('100%')
        })
      }.index($$this.selectIndex)
    }
    .backgroundColor(Color.Black)
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width("100%")
    .onClick(() => {
      this.controller.close()
    })
  }
}
```

<h3 id="46088153">2. 状态共享-父子双向</h3>
+ Prop修饰符- 父组件数据更新-让子组件更新- **<font style="color:#DF2A3F;">子组件更新-父组件不为所动</font>**

:::info
Prop是单向的，而Link修饰符则是双向的数据传递，只要使用Link修饰了传递过来的数据，这个时候就是双向同步了

注意点： 在父组件传入Link属性时，需要使用$来修饰该变量，去掉this

Next版本中可以不用$修饰，直接使用this.xx属性绑定即可

Link修饰符不允许给初始值

:::

+ 将刚刚的案例改造成双向的

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702105346123-ab6eb085-f9ce-4a13-ac43-abfb07ceacdb.png)

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702105359292-890dd114-6ed4-4764-8bf6-b0691f0cd879.png)

> 子组件中被@Link装饰的变量与其父组件中对应的数据源建立双向数据绑定。
>

```typescript
@Entry
@Component
struct LinkCase {
  @State
  num: number = 0
  build() {
    Column({ space: 20 }) {
      Row ({ space: 10 }) {
        Text("父组件")
          .fontSize(40)
        Text(this.num.toString())
          .fontSize(40)

      }
      .onClick(() => {
        this.num++
      })

      Divider()
        .width("100%")
        .strokeWidth(20)
      LinkChild({ num: this.num })
      LinkChild({ num: $num })
      // Link的修饰符传值 在Next版本这一代 进行了一代的放宽
      // $num
    }
    .justifyContent(FlexAlign.Center)
    .width('100%')
    .height('100%')
  }
}

@Component
struct LinkChild {
  @Link
  num: number
  build() {
    Column() {
      Text("子组件" + this.num)
        .onClick(() => {
          this.num++
        })
      Swiper() {
        ForEach([1,2,3,4,5,6,7,8,9,10], (item: number) => {
          Row() {
            Text(item.toString())
              .fontColor(Color.White)
              .fontSize(50)
          }
          .justifyContent(FlexAlign.Center)
          .width('100%')
          .height(130)
          .backgroundColor(Color.Blue)
        })
      }
      .index($$this.num)
    }

  }
}
```



:::success
Link修饰符的要求- 你的父组件传值时传的必须是个响应式状态

State/Prop/

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709977039684-9e7f6f31-334b-4d2f-936f-bf6ac8dabb7d.png)



:::info
需要注意的是，Link修饰的变量类型和State和Prop的类型是一样的，支持string、number、boolean、enum Object Class以及这些类型对应的数组

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1709979383186-0ae1d20d-660a-40c6-a0dd-1f9461d35d9d.png)



```typescript
@Entry
@Component
struct LinkCartCase {
  @State
  foodList: FoodItem[] = [{
    food_name: '鱼香肉丝',
    food_price: 18.8,
    food_count: 3,
    food_id: 1
  }, {
    food_name: '羊蝎子',
    food_price: 78.8,
    food_count: 3,
    food_id: 2
  }, {
    food_name: '锦州烧烤',
    food_price: 58.8,
    food_count: 1,
    food_id: 3
  }]

  build() {
    Column() {
      HmCart({
        list: $foodList
      })
    }
    .justifyContent(FlexAlign.Center)
    .width('100%')
    .height("100%")
  }
}

@Component
struct HmCart {
  @Link
  list: FoodItem[]
  updateCard(item: FoodItem, type: 'add' | 'cut') {
    // if(type === 'add') {
    //   // 加菜
    //   item.food_count++ // 数量更新之后
    // }
    // else {
    //   // 减菜
    //   if(item.food_count) {
    //     item.food_count--
    //   }
    //
    // }
    type === "add" ? (item.food_count++) : (item.food_count && item.food_count--)
    const index = this.list.findIndex(obj => obj.food_id === item.food_id)
    this.list.splice(index, 1, item) // 更新方式 傻大粗的更新方式 ObjectLink的更新方式 可以实现局部的更新
  }

  build() {
    List() {
      ForEach(this.list, (item: FoodItem) => {
        ListItem() {
          // 放内容或者是自定义组件
          HmCartItem({
            item, addOrCut: (item: FoodItem, type: 'add' | 'cut') => {
              this.updateCard(item, type)
            }
          })
        }
      })
    }
  }
}

@Component
struct HmCartItem {
  @Prop
  item: FoodItem
  addOrCut: (item: FoodItem, type: "add" | "cut") => void = () => {
  }

  build() {
    Row() {
      Column() {
        Text(this.item.food_name)
          .fontSize(24)
        Text(this.item.food_price.toString())
          .fontColor(Color.Red)
          .fontWeight(FontWeight.Bold)
      }
      .height(60)
      .justifyContent(FlexAlign.SpaceBetween)
      .alignItems(HorizontalAlign.Start)

      Row({ space: 10 }) {
        Text("-")
          .addText()
          .onClick(() => {
            // this.item.food_id
            this.addOrCut(this.item, "cut")
          })
        Text(`${this.item.food_count}`)
          .fontSize(24)
        Text("+")
          .addText()
          .onClick(() => {
            // this.item.food_id
            this.addOrCut(this.item, "add")
          })
      }

    }
    .padding(10)
    .alignItems(VerticalAlign.Top)
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(100)
  }
}

@Extend(Text)
function addText() {
  .width(40)
  .height(40)
  .textAlign(TextAlign.Center)
  .lineHeight(38)
  .border({
    width: 1,
    color: "#999"
  })
  .borderRadius(20)
  .fontColor("#999")
  .fontSize(30)
}


interface FoodItem {
  food_name: string
  food_price: number
  food_count: number
  food_id: number
}
```



:::success
当我们的Link，比如是一个数组的时候， 如果你循环该数组，还有一层组件，此时该组件的中的属性不能再使用Link来修饰了，因为语法不支持Link被循环之后的 传递

:::



:::info
大家一定在想，为什么不把每个菜封装成一个组件，然后用Link传递过去岂不是更方便？？？

我们试试

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702106767187-70cb1648-9c69-4d78-9640-a73c9873db3a.png)

:::info
看到没有，ArtTS不支持这么做，也就是Link修饰的数据必须得是最外层的 State数据，想要实现我们刚刚的设想，我们还得另辟蹊径。-后续ObjectLink 和Observerd会解决这个问题

:::

<h3 id="f5a7a96d">3. 状态共享-后代组件</h3>
:::info
如果我们的组件层级特别多，ArkTS支持跨组件传递状态数据来实现双向同步@Provide和 @Consume   

这特别像Vue中的依赖注入

:::

+ 假设我们有三层组件，Index-Child-Grand， Index的数据不想经过Child而直接给到Grand可以使用该修饰器

```typescript
@Entry
@Component
struct ProvideCase02 {
 @Provide count: number = 0

  build() {
    Row() {
      Column({ space: 15 }) {
        Text(this.count.toString())
          .fontSize(50)
        Button("顶级组件+1")
          .onClick(() => {
            this.count++
          })
        Divider()
        Child()
      }
      .width('100%')
    }
    .height('100%')
  }
}

@Component
struct Child {
  build() {
    Column() {
      Text("子组件")
        .fontSize(40)
      Divider()
      Grand()
    }
  }
}

@Component
struct Grand {
  @Consume count: number
  build() {
    Column() {
      Text("孙组件")
        .fontSize(30)
      Text(this.count.toString())
    }
  }
}
```



:::info
注意： 在不指定Provide名称的情况下，你需要使用相同的名字来定义和接收数据

:::

1）通过相同的变量名绑定

```typescript
@Entry
@Component
struct Index {
  @Provide
  money: number = 0

  build() {
    Column({ space: 20 }) {
      Text('父组件：' + this.money)
        .onClick(() => {
          this.money++
        })
      Parent()
    }
    .width('100%')
    .height('100%')
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Center)
  }
}

@Component
struct Parent {
  @Consume
  money: number

  build() {
    Column({ space: 20 }) {
      Text('父组件：' + this.money)
        .onClick(() => {
          this.money++
        })
      Child()
    }
  }
}

@Component
struct Child {
  @Consume
  money: number

  build() {
    Text('子组件：' + this.money)
      .onClick(() => {
        this.money++
      })
  }
}
```

:::info
+ `Object、class、string、number、boolean、enum` 类型均支持
+ 通过相同的变量别名绑定 `@Provide('key')` 和 `@Consume('key')` key需要保持一致

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702108098006-b9c10184-433f-49d9-8cd6-51f9b1811aee.png)



:::color2
ArkTS所有内容都不支持深层数据更新 UI渲染

:::

+ 综合案例

:::success
声明一个登录页

:::

```typescript
import { promptAction, router } from '@kit.ArkUI'

@Entry
@Component
struct ProvideBigCase {
  @State
  phone: string = "13812345678"
  @State
  code: string = "123456"

  getBtnEnable () {
    return  !!(this.phone && this.code)
  }
  login () {
    if(this.phone === "13812345678" && this.code === '123456') {
      // 需要跳入主页
        router.pushUrl({
          url: 'pages/09/ProvideBigMainCase'  // 一定是个Page
        })
    }else {
      promptAction.showToast({ message: '手机号或验证码错误' })
    }
  }
  build() {
    Column({ space: 20 }) {
        Image($r("app.media.login_logo"))
          .width(80)
          .aspectRatio(1)
        Text("欢迎使用鸿蒙刷题")
          .fontSize(20)
        TextInput({
          text: $$this.phone,
          placeholder: '请输入手机号'
        })
          .height(50)
          .width("100%")
        TextInput({
          text: $$this.code,
          placeholder: '请输入验证码'
        })
          .height(50)
          .width("100%")
      Button("登录")
        .enabled(this.getBtnEnable())
        .height(50)
        .width('100%')
        .onClick(() => {
          this.login()
        })
    }
    .justifyContent(FlexAlign.Center)
    .width('100%')
    .height('100%')
    .padding({
      left: 40,
      right: 40
    })
  }
}
// 登录 -》 主页 =》 拿到身份信息 =》 通过三层传递 =》 将身份信息传到每一层组件
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710245881687-f30e333a-4723-4e04-8ddc-2b048bc2982f.png)

+ 跳转到主页

```typescript
import { UserInfo, UserInfoModel } from './models/user'

@Entry
@Component
struct ProvideBigMainCase {
  // 通过Provide 和Consume来实现 数据的传递
  @Provide
  user: UserInfoModel = new UserInfoModel({} as UserInfo)

  // 进入页面就执行的函数
  aboutToAppear(): void {
    this.getCurrentUser()
  }
  // 获取当前的用户信息
  async getCurrentUser() {
    // 请求
    const result = await new Promise<UserInfo>((resolve) => {
      setTimeout(() => {
        resolve({
          id: 1,
          avatar: '456',
          mobile: '13812345678',
          email: '123@qq.com',
          nickName: '水若寒宇'
        })
      }, 1000)
    })
    this.user = new UserInfoModel(result)
  }

  build() {
    // Tabs
    Tabs() {
      TabContent() {
        WeChat()
      }.tabBar("微信")

      TabContent() {
        Connect()
      }.tabBar("联系人")

      TabContent() {
        Discover()
      }.tabBar("发现")

      TabContent() {
        My()
      }.tabBar("我的")
    }.barPosition(BarPosition.End)
  }
}

@Component
struct WeChat {
  @Consume
  user: UserInfoModel
  build() {
   Column() {
     Text(this.user.nickName)
   }
  }
}

@Component
struct Connect {
  @Consume
  user: UserInfoModel
  build() {
    Column() {
      Text(this.user.mobile)
    }
  }
}

@Component
struct My {
  @Consume
  user: UserInfoModel
  build() {
    Text(this.user.email)
  }
}

@Component
struct Discover {
  @Consume
  user: UserInfoModel
  build() {
    Text(this.user.avatar)
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710245912413-393df195-9f99-4a33-b651-ad5783c798bb.png)



:::success
新的知识点

   router.pushUrl() . 可以实现路由的跳转-强调-地址上第一个/必须去掉，必须保证跳转的页面是Entry修饰的页面，并且在 resources/base/profile/main_pages.json中可以找到这个地址

:::

<h3 id="e902d709">4. 状态共享-状态监听器</h3>
修饰符- entry-component-State-Prop-Link-Provide Consume

:::color2
如果开发者需要关注某个状态变量的值是否改变，可以使用 `@Watch` 为状态变量设置回调函数。

Watch("回调函数名")中的回调必须在组件中声明，该函数接收一个参数，参数为修改的属性名

注意：Watch修饰符要写在 State Prop Link Provide的修饰符下面，否则会有问题

+ 在第一次初始化的时候，@Watch装饰的方法不会被调用

:::

如下

```typescript
import { promptAction } from '@kit.ArkUI';

@Entry
@Component
struct WatchCase {
  @State
  @Watch("updateNum")
  num: number = 0
  @State
  @Watch("updateName")
  message: string = 'Hello World';
  updateName() {
    console.log("发生变化了", this.message)
  }
  updateNum() {
    promptAction.showToast({ message: '子组件变化了' })

  }
  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
        Text("父组件" + this.num)
        Button("修改变量")
          .onClick(() => {
            this.message = "你好 我要变异了"
          })
        WatchChild({ mess: this.message, num: $num })
      }
      .width('100%')
    }
    .height('100%')
  }
}

@Component
struct WatchChild {
  @Link
  num: number
  @Prop
  @Watch("updateMess")
  mess: string
  updateMess() {
    promptAction.showToast({ message: '父组件变化了' })
  }
  build() {
    Column() {
      Text("子组件" + this.num)
        .onClick(() => {
          this.num++
        })

    }

  }
}
```



+ `@State、@Prop、@Link` 等装饰器在 `@Watch` 装饰之前



:::info
有了watch 我们就可以随心所欲的搞监听了，比如

+ 父组件数据变化了， 子组件随机而动
+ 子组件双向更新了父组件数据，父组件随机而动

后续项目中我们会在上传组件的位置去使用它

:::

:::success
刷题案例

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710247458090-93f027ed-c72e-47a2-b933-eae723f767b7.png)

+ 实现基本布局

```typescript
@Entry
@Component
struct WatchBigCase {
  @Styles
  imgStyle () {
    .width(20)
    .height(20)
  }
  @Builder
  getTopContent () {
    Row () {
      Image($r("app.media.ic_public_left_arrow"))
        .imgStyle()
      Text("在线模拟")
      Image($r("app.media.read"))
        .imgStyle()
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(40)
  }

  @Builder
  getBottomContent () {
    Row() {
      Row() {
        Image($r("app.media.ic_public_left_arrow"))
          .imgStyle()
        Text("上一题")
      }
      Row() {
        Text("下一题")
        Image($r("app.media.ic_public_left_arrow"))
          .imgStyle()
          .rotate({
            angle: 180
          })
      }
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(60)
    .backgroundColor(Color.White)
  }
  build() {
    Column({ space: 20 }) {
      // builder
      this.getTopContent()
      // 进度条
      Progress({ value: 50, total: 100 })

      Column() {

      }
      .layoutWeight(1)
      // 底部区域
      this.getBottomContent()

    }
    .width('100%')
    .height('100%')
    .padding({
      left: 10,
      right: 10
    })
    .backgroundColor(Color.White)
  }
}
```



![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710248243752-26186647-288a-46c1-bbfe-15abecc9f592.png) 

+ 准备数据结构

```typescript
export interface QuestionInfo {
  id: number
  title: string
  options: OptionItem []
}

export interface OptionItem {
  letter: string // A B C D
  optionTitle: string // 选项名称
}
export class QuestionInfoModel implements QuestionInfo {
  id: number = 0
  title: string = ''
  options: OptionItem [] = []

  constructor(model: QuestionInfo) {
    this.id = model.id
    this.title = model.title
    this.options = model.options
  }
}
export class OptionItemModel implements OptionItem {
  letter: string = ''
  optionTitle: string = ''

  constructor(model: OptionItem) {
    this.letter = model.letter
    this.optionTitle = model.optionTitle
  }
}

```

+ 模拟初始化获取数据

```typescript
 @State
  list: QuestionInfoModel[] = []

  aboutToAppear(): void {
    this.getQuestionList()
  }
  async getQuestionList () {
    this.list = await new Promise<QuestionInfoModel[]>((resolve) => {
       setTimeout(() => {
         resolve([new QuestionInfoModel({
           id: 1,
           title: '下面说法正确的是',
           options: [new OptionItemModel({
             optionTitle: "鸿蒙和openharmony是一回事",
             letter: 'A'
           }),
             new OptionItemModel({
             optionTitle: "鸿蒙的装饰器不可以做响应式",
             letter: 'B'
           }), new OptionItemModel({
               optionTitle: "arkTS借鉴了TS的语法",
               letter: 'C'
             }),
             new OptionItemModel({
               optionTitle: "鸿蒙4.0已经面世1年了",
               letter: 'D'
             })]
         }),new QuestionInfoModel({
           id: 2,
           title: '哪个修饰符不具备响应式',
           options: [new OptionItemModel({
             optionTitle: "State",
             letter: 'A'
           }),
             new OptionItemModel({
               optionTitle: "Link",
               letter: 'B'
             }), new OptionItemModel({
               optionTitle: "Prop",
               letter: 'C'
             }),
             new OptionItemModel({
               optionTitle: "Preview",
               letter: 'D'
             })]
         }), new QuestionInfoModel({
           id: 3,
           title: 'Link的用法下面哪个语法是正确的',
           options: [new OptionItemModel({
             optionTitle: "$$this.xxx",
             letter: 'A'
           }),
             new OptionItemModel({
               optionTitle: "$.xxx",
               letter: 'B'
             }), new OptionItemModel({
               optionTitle: "$this.xxx",
               letter: 'C'
             }),
             new OptionItemModel({
               optionTitle: "$$xxx",
               letter: 'D'
             })]
         })])
       }, 300)
    })
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710249190054-0c8202d1-8466-4af6-b9d4-719f14f5599a.png)

+ 声明一个记录当前索引的标记

```typescript
 @State
  currentIndex: number = 0 // 默认索引

```

+ 实现上一题和下一题的逻辑

```typescript
 lastQuestion() {
    if (this.getLastEnable()) {
      this.currentIndex--
    }
  }

  // 获取上一个是否可以点击
  getLastEnable() {
    return this.currentIndex > 0
  }

  // 获取下一个是否可以点击
  getNextEnable() {
    return this.currentIndex < this.list.length - 1
  }

  nextQuestion() {
    if (this.getNextEnable()) {
      this.currentIndex++
    }
  }
```

+ 实现获取当前题目以及渲染当前题目

```typescript
 // 获取当前的激活题目
  getCurrentQuestion() {
    if (this.list.length) {
      return this.list[this.currentIndex]
    }
    return null
  }
```

+ 渲染当前题目

```typescript
  @Builder
  getQuestionContent() {
    Column({ space: 8 }) {
      if(this.list.length) {
        Text(this.getCurrentQuestion()!.title)
        // !非空断言 主观认定该变量不为空
        ForEach(this.getCurrentQuestion()!.options, (item: OptionItemModel) => {
          Row({ space: 10 }) {
            Text(item.letter+".")
            Text(item.optionTitle)
          }
          .height(60)
          .width("100%")
          .borderRadius(4)
          .backgroundColor("#f9f9f9")
          .padding({
            left: 20
          })
        })
      }

    }
    .padding({
      left: 20
    })
    .alignItems(HorizontalAlign.Start)
    .width('100%')
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710409164230-e375a21d-adab-4cae-ae87-8acf96f271e7.png)

+ 答题逻辑

:::success
+ 选中项的点击变色
+ 单选场景下-互斥场景- 点A关B
+ 切换题目时-监听索引的变化-将用户的答案回显到屏幕上

:::



:::success
记录用户的点击的答案- 在切题过程中-能够缓存的

应该有一份单独的数据结构来存储每个题的答案- 只针对当前用户- 要记录很多题的答案

:::

+ 声明一个答案的数据结构

```typescript
// 设计一个用户的答案的结构
export interface UserAnswer {
  question_id: number // 做题的题目的id
  user_answer: string // 用户所选的答案
  user_id: string  // 当前的用户的id
}
```

+ 在页面中使用Record 这种键值对的形式声明一个对象

```typescript
  @State
  answerMap: Record<number, UserAnswer> = {}
```

+ 点击选项时，将答案写入集合

```typescript
 Row({ space: 10 }) {
            Text(item.letter+".")
              .fontColor(this.getColor(item, "font"))
            Text(item.optionTitle)
              .fontColor(this.getColor(item, "font"))
          }
          .height(60)
          .width("100%")
          .borderRadius(4)
          .backgroundColor(this.getColor(item))
          .padding({
            left: 20
          })
          .onClick(() => {
             // 选了答案  答案得存起来
            this.selectAnswer(item)
          })
```

+ 实现selectAnswer方法

```typescript
 // 选择答案
  selectAnswer (option: OptionItemModel) {
    let question = this.getCurrentQuestion() // 拿到当前做的题目
    if(question) {
      // [字段] 写法作用在object或者record在Next是支持的
      this.answerMap[question.id] = {
        question_id: question.id,
        user_answer: option.letter,
        user_id: "123456"
      }

    }
  }
```

+ 实现一个获取颜色的方法

```typescript

  // 获取每个选项的颜色
  getColor (option: OptionItemModel, type: "back" | "font" = "back") {
    let question = this.getCurrentQuestion() // 拿到当前做的题目
    if (question) {
     if(this.answerMap[question.id]?.user_answer === option.letter) {
       return  type === "back" ? Color.Blue : Color.White
     }
    }
    return type === "back" ? "#f9f9f9" : Color.Black
  }
```

+ 整体代码

```typescript
import { OptionItemModel, QuestionInfoModel, UserAnswer } from './models/question'
import { promptAction } from '@kit.ArkUI'
import { util } from '@kit.ArkTS'

@Entry
@Component
struct WatchBigCase {
  @State
  list: QuestionInfoModel[] = []
  @State
  currentIndex: number = 0 // 默认索引

  // @State
  // answer: Partial<UserAnswer> = { }
  // 集合 数组[] 对象
  // { 1: {}, 2: {}, 3: {}  }
  @State
  answerMap: Record<number, UserAnswer> = {}

  aboutToAppear(): void {
    this.getQuestionList()
  }

  async getQuestionList() {
    this.list = await new Promise<QuestionInfoModel[]>((resolve) => {
      setTimeout(() => {
        resolve([new QuestionInfoModel({
          id: 1,
          title: '下面说法正确的是',
          options: [new OptionItemModel({
            optionTitle: "鸿蒙和openharmony是一回事",
            letter: 'A'
          }),
            new OptionItemModel({
              optionTitle: "鸿蒙的装饰器不可以做响应式",
              letter: 'B'
            }), new OptionItemModel({
              optionTitle: "arkTS借鉴了TS的语法",
              letter: 'C'
            }),
            new OptionItemModel({
              optionTitle: "鸿蒙4.0已经面世1年了",
              letter: 'D'
            })]
        }), new QuestionInfoModel({
          id: 2,
          title: '哪个修饰符不具备响应式',
          options: [new OptionItemModel({
            optionTitle: "State",
            letter: 'A'
          }),
            new OptionItemModel({
              optionTitle: "Link",
              letter: 'B'
            }), new OptionItemModel({
              optionTitle: "Prop",
              letter: 'C'
            }),
            new OptionItemModel({
              optionTitle: "Preview",
              letter: 'D'
            })]
        }), new QuestionInfoModel({
          id: 3,
          title: 'Link的用法下面哪个语法是正确的',
          options: [new OptionItemModel({
            optionTitle: "$$this.xxx",
            letter: 'A'
          }),
            new OptionItemModel({
              optionTitle: "$.xxx",
              letter: 'B'
            }), new OptionItemModel({
              optionTitle: "$this.xxx",
              letter: 'C'
            }),
            new OptionItemModel({
              optionTitle: "$$xxx",
              letter: 'D'
            })]
        })])
      }, 300)
    })
  }

  @Styles
  imgStyle() {
    .width(20)
    .height(20)
  }

  @Builder
  getTopContent() {
    Row() {
      Image($r("app.media.ic_public_left_arrow"))
        .imgStyle()
      Text("在线模拟")
      Image($r("app.media.read"))
        .imgStyle()
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(40)
  }

  lastQuestion() {
    if (this.getLastEnable()) {
      this.currentIndex--
    }
  }

  // 获取上一个是否可以点击
  getLastEnable() {
    return this.currentIndex > 0
  }

  // 获取下一个是否可以点击
  getNextEnable() {
    return this.currentIndex < this.list.length - 1
  }

  nextQuestion() {
    if (this.getNextEnable()) {
      this.currentIndex++
    }
  }

  // 获取当前的激活题目
  getCurrentQuestion() {
    if (this.list.length) {
      return this.list[this.currentIndex]
    }
    return null
  }

  @Builder
  getBottomContent() {
    Row() {
      Row() {
        Image($r("app.media.ic_public_left_arrow"))
          .imgStyle()
          .fillColor(this.getLastEnable() ? Color.Black : "#ffe2e4e5")
        Text("上一题")
          .fontColor(this.getLastEnable() ? Color.Black : "#ffe2e4e5")
      }
      .onClick(() => {
        this.lastQuestion()
      })

      Row() {
        Text("下一题")
          .fontColor(this.getNextEnable() ? Color.Black : "#ffe2e4e5")
        Image($r("app.media.ic_public_left_arrow"))
          .imgStyle()
          .fillColor(this.getNextEnable() ? Color.Black : "#ffe2e4e5")
          .rotate({
            angle: 180
          })
      }
      .onClick(() => {
        this.nextQuestion()
      })
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(60)
    .backgroundColor(Color.White)
  }

  // 选择答案
  selectAnswer (option: OptionItemModel) {
    let question = this.getCurrentQuestion() // 拿到当前做的题目
    if(question) {
      // [字段] 写法作用在object或者record在Next是支持的
      this.answerMap[question.id] = {
        question_id: question.id,
        user_answer: option.letter,
        user_id: "123456"
      }

    }
  }

  // 获取每个选项的颜色
  getColor (option: OptionItemModel, type: "back" | "font" = "back") {
    let question = this.getCurrentQuestion() // 拿到当前做的题目
    if (question) {
     if(this.answerMap[question.id]?.user_answer === option.letter) {
       return  type === "back" ? Color.Blue : Color.White
     }
    }
    return type === "back" ? "#f9f9f9" : Color.Black
  }
  @Builder
  getQuestionContent() {
    Column({ space: 8 }) {
      if(this.list.length) {
        Text(this.getCurrentQuestion()!.title)
        // !非空断言 主观认定该变量不为空
        ForEach(this.getCurrentQuestion()!.options, (item: OptionItemModel) => {
          Row({ space: 10 }) {
            Text(item.letter+".")
              .fontColor(this.getColor(item, "font"))
            Text(item.optionTitle)
              .fontColor(this.getColor(item, "font"))
          }
          .height(60)
          .width("100%")
          .borderRadius(4)
          .backgroundColor(this.getColor(item))
          .padding({
            left: 20
          })
          .onClick(() => {
             // 选了答案  答案得存起来
            this.selectAnswer(item)
          })
        })
      }

    }
    .padding({
      left: 20
    })
    .alignItems(HorizontalAlign.Start)
    .width('100%')
  }

  build() {
    Column({ space: 20 }) {
      // builder
      this.getTopContent()
      // 进度条
      // 因为0表示第一个
      Progress({ value: this.currentIndex + 1, total: this.list.length })

      Column() {
        this.getQuestionContent()
      }
      .layoutWeight(1)
      // 底部区域
      this.getBottomContent()

    }
    .width('100%')
    .height('100%')
    .padding({
      left: 10,
      right: 10
    })
    .backgroundColor(Color.White)
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710417272585-01b5a477-5f8c-42c4-b2f2-c215c800fd08.png)



<h3 id="fh1xr">5. Next新增修饰符-Require-Track</h3>
:::success
Require修饰符

4.0的编辑器中- 如果子组件定义了Prop，那么父组件必须得传，不传则报错

Next版本中，如果你想让父组件必须传递一个属性给你的Prop，作为强制性的约束条件，可以使用Require修饰符

:::



:::success
Require修饰符只能作用在两个修饰符前面Prop  BuilderParam

:::



```typescript
@Entry
@Component
struct RequireCase {
  @State
  num: number = 0

  build() {
    Row() {
      Column() {
        RequireChild({ num: this.num, content: () => {
          
        } })
        Button("+1")
          .onClick(() => {
            this.num++
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}

@Component
struct RequireChild {
  @Require
  @BuilderParam
  content: () => void

  @Require
  @Prop
  num: number = 0
  build() {
     Column() {
       Text("子组件" + this.num)
     }
  }
}
```



:::success
Track修饰符- 只针对对象中的某个属性的更新起作用

:::



![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710418425105-ac714357-ecb1-4280-9c8d-f14b015a6cd4.png)

:::success
State 修饰的一个变量 class类型，有N个属性， 只要是第一层的属性发生了变化，就会更新视图

:::

```typescript
@Entry
@Component
struct TrackCase {
  @State
  wz: WZModelModel = new WZModelModel({
    name: '老高',
    money: 2.5,
    age: 20
  })

  build() {
    Column({ space: 20 }) {
      // Row() {
      //   Text("姓名")
      //   Text(this.wz.name)
      // }
      // .width("100%")
      // .justifyContent(FlexAlign.SpaceBetween)

      // Row() {
      //   Text("年龄")
      //   Text(this.wz.age.toString())
      // }
      // .width("100%")
      // .justifyContent(FlexAlign.SpaceBetween)

      Row() {
        Text("金钱")
        Text(this.wz.money.toString())
      }
      .width("100%")
      .justifyContent(FlexAlign.SpaceBetween)

      // Button("年龄++")
      //   .onClick(() => {
      //     this.wz.age++
      //   })
      // Button("姓名++")
      //   .onClick(() => {
      //     this.wz.name += "1"
      //   })
      Button("金钱++")
        .onClick(() => {
          this.wz.money++
        })

    }
    .height('100%')
    .width('100%')
    .padding(20)
  }
}

interface WZModel {
  name: string
  age: number
  money: number
}

export class WZModelModel implements WZModel {
  name: string = ''
  age: number = 0
  @Track
  money: number = 0

  constructor(model: WZModel) {
    this.name = model.name
    this.age = model.age
    this.money = model.money
  }
}

```

:::success
Track的作用只更新对象中的某些字段， Track修饰符用来作用在class中的某些字段，只有被标记的字段才会更新，并且没有被Track标记的字段不能被使用-不能在UI中使用。

场景： 

    假如只想根据对象中某个字段来更新或者渲染视图 就可以使用Track

:::

```typescript
@Entry
@Component
struct TrackCase {
  @State message: string = 'Hello World';
  @State
  game: WZGameModel = new WZGameModel({
    name: '王者荣耀',
    money: 100,
    users: 2
  })
  build() {
    Row() {
      Column({ space: 20 }) {
        Row () {
          Text("名称:")
          Text(this.game.name)
        }
        Row () {
          Text("资产:")
          Text(this.game.money + "亿")
        }
        Row () {
          Text("用户:")
          // Text(this.game.users + "亿")
        }
       Button("修改名称")
         .onClick(() => {
           this.game.name = "欢迎来到王者荣耀"
         })
        Button("修改资产")
          .onClick(() => {
            this.game.money += 10
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}

interface WZGame {
  name: string
  money: number
  users: number
}
export class WZGameModel implements WZGame {
  @Track
  name: string = ''
  @Track
  money: number = 0
  users: number = 0

  constructor(model: WZGame) {
    this.name = model.name
    this.money = model.money
    this.users = model.users
  }
}

```

<h3 id="0b280655">6. @Observed与[@ObjectLink ](/ObjectLink ) </h3>
:::info
之前讲解Link的时候，我们遇到了一个问题，就是循环生成的item没办法用item传递给子组件的Link，也就是

封装的组件没办法做双向更新同步，那么ArtTS支持 Observed和@ObjectLink来实现这个需求

场景： 知乎案例

    点赞- 需求是当前数据的点赞量+1或者-1， 之前实际实现是： 把一条数据 给到父组件-替换了父组件的整行的数据， 并且造成了案例中头像的闪烁-因为这个组件数据被销毁然后被创建

理想效果： 其他一切都不动，只动数量的部分-也就是UI视图的局部更新- 需要使用Observed和ObjectLink

:::



:::color2
使用步骤：

+ 类 `class` 数据需要定义通过构造函数，使用 `@Observed` 修饰这个类
+ 初始化数据：需要通过初始化构造函数的方式添加
+ 通过 `@ObjectLink` 关联对象，可以直接修改被关联对象来更新UI

需求：模拟一个点赞的案例

1）定义构造函数和使用`@Observed` 修饰符，以及初始化数据

:::



:::success
Observed可以和ObjectLink实现局部更新，即非移除组件替换组件式的更新

:::



```typescript
@Entry
@Component
struct ObservedCase {
  @State
  commentList: DouYinCommentModel[] = [new DouYinCommentModel({
    author: '小团团',
    content: '你告诉我你今天到底吃的什么',
    like_count: 10
  }), new DouYinCommentModel({
    author: '大宇',
    content: '我真的不知道该说什么了',
    like_count: 3
  })]

  build() {
    List() {
      ForEach(this.commentList, (item: DouYinCommentModel) => {
        ListItem() {
          DouYinCom({ item: item })
        }
      })
    }
    .padding(20)
  }
}

@Component
struct DouYinCom {
  @ObjectLink
  item: DouYinCommentModel
  build() {
    Row() {
       Text(this.item.author)
       Text(this.item.content)
       Text(this.item.like_count.toString())
        .onClick(() => {
           this.item.like_count++
        })
    }
    .justifyContent(FlexAlign.SpaceBetween)
    .width('100%')
    .height(60)
  }
}


interface DouYinComment {
  content: string
  like_count: number
  author: string
}
@Observed
export class DouYinCommentModel implements DouYinComment {
  content: string = ''
  like_count: number = 0
  author: string = ''

  constructor(model: DouYinComment) {
    this.content = model.content
    this.like_count = model.like_count
    this.author = model.author
  }
}

```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710420807406-6eebf61d-1b41-4b13-b957-d64e68932d0f.png)

:::color2
上述代码中

+ 我们使用Class继承实现了interface，并且通过传入的对象将我们Class中的属性进行赋值
+ 使用了Observed这个装饰器来修饰class，那么只要我们改动class的属性，它就会驱动UI的更新（只是第一层）

注意： 只有Observed修饰的class才可以被 ObjectLink使用，并且Entry修饰的组件不允许使用ObjectLink

:::



+ 接下来，我们同样改造下我们的知乎案例
+ 给class增加observed

```typescript
@Observed
export class ReplyItemModel implements ReplyItem {
  avatar: ResourceStr = ''
  author: string = ''
  id: number = 0
  content: string = ''
  time: string = ''
  area: string = ''
  likeNum: number = 0
  likeFlag: boolean | null = null

  constructor(model: ReplyItem) {
    this.avatar = model.avatar
    this.author = model.author
    this.id = model.id
    this.content = model.content
    this.time = model.time
    this.area = model.area
    this.likeNum = model.likeNum
    this.likeFlag = model.likeFlag
  }
}

```

+ 给知乎的评论组件增加一个ObjectLink修饰符

```typescript
 // 接收渲染的选项
  @ObjectLink
  item: ReplyItemModel
```

+ 评论子组件实现点赞的方法

```typescript
// 更新逻辑
  changeLike () {
    if(this.item.likeFlag) {
      // 点过赞
      this.item.likeNum--
    }
    else {
      // 没有点过赞
      this.item.likeNum++
    }
    this.item.likeFlag = !this.item.likeFlag // 取反
  }
```

+ 父组件传值优化

```typescript
 ForEach(this.commentList, (item: ReplyItemModel) => {
         ListItem() {
           HmCommentItem({
             item: item
           })
         }
       }, (item: ReplyItemModel) => item.id.toString() + "_" + item.likeNum.toString())
```





:::info
此时，我们的头像不再闪动，说明数据已经不需要去更新整条数据来完成UI的更新

:::



:::info
注意点：

+ ObjectLink只能修饰被Observed修饰的class类型
+ Observed修饰的class的数据如果是复杂数据类型，需要采用赋值的方式才可以具备响应式特性-因为它监听的是该属性的set和get
+ 如果出现复杂类型嵌套，只需要Observed我们需要的class即可，至于用于类型的class可以用type或者interface
+ **<font style="color:#DF2A3F;">ObjectLink修饰符不能用在Entry修饰的组件中</font>**

:::



:::info
此知识点不太好理解，同学们一定一定多敲几遍！！！！！

:::

<h2 id="7f3168ac">3.应用状态</h2>
:::success
State 组件内状态

Prop 父组件传入

Link 父组件传入

Provide 跨级组件传入

Consume 跨级组件接收

ObjectLink  父组件传入局部更新状态

:::



:::info
ArtTS提供了好几种状态用来帮助我们管理我们的全局数据

+ LocalStorage-UIAbility状态（内存- 注意：和前端的区分开，它非持久化，非全应用）
+ AppStorage- 应用内状态-多UIAbility共享-（内存-非持久化-退出应用同样消失）
+ PersistentStorage-全局持久化状态（写入磁盘-持久化状态-退出应用 数据同样存在）
+ 首选项- 写入磁盘
+ 关系型数据库 - 写入磁盘
+ 端云数据库
+ 接口调用-云端数据（服务器数据）

:::

<h3 id="8750260c">1. UIAbility内状态-LocalStorage</h3>
:::info
`LocalStorage` 是页面级的UI状态存储，通过 `@Entry` 装饰器接收的参数可以在页面内共享同一个 `LocalStorage` 实例。 `LocalStorage` 也可以在 `UIAbility` 内，页面间共享状态。

用法

+ 创建 `LocalStorage` 实例：`const storage = new LocalStorage({ key: value })`
+ 单向 `@LocalStorageProp('user')` 组件内可变
+ 双向 `@LocalStorageLink('user')` 全局均可变

:::

案例- 两个页面共享一个user对象

+ 创建一个共享的状态 

```typescript
// Recordl类似 键值对的一饿中类型

export class FastPeople {
  name: string = ""
  age: number = 0
}

// 要共享的数据的初始值
let obj: Record<string, FastPeople> = {
  "user": { name: "章三", age: 20 }
}
const tokenObj = new LocalStorage(obj) // 得到一个实际对象

export { tokenObj }
```

+ 页面1

```typescript
import { FastPeople, tokenObj } from './local/TokenModel'
import { router } from '@kit.ArkUI'

// @Entry({ storage: tokenObj }) 这种写法一般用在路由跳转需要name的时候
//
@Entry(tokenObj)
@Component
struct LocalStorageCase {
  @LocalStorageProp("user") // 单向数据同步
  user: FastPeople = new FastPeople()
  @LocalStorageLink("user") // 双向同步
  user1: FastPeople = new FastPeople()

  build() {
    Column({ space: 20 }) {
      Text(this.user.name)
      Text(this.user.age.toString())
      Button("修改数据-Prop")
        .onClick(() => {
          this.user.age++
        })
      Button("修改数据-Link")
        .onClick(() => {
          this.user1.age++
        })
      Button("跳转页面")
        .onClick(() => {
          router.pushUrl({
            url: 'pages/06/LocalStorageCaseB'
          })
          // router.pushNamedRoute({
          //   name: 'abc'
          // })
        })
    }
    .height('100%')
    .width('100%')
  }
}
```

+ 页面2

```typescript
import { FastPeople, tokenObj } from './local/TokenModel';

@Entry(tokenObj)
@Component
struct LocalStorageCaseB {
  @LocalStorageProp("user") // 单向数据同步
  user: FastPeople = new FastPeople()

  build() {
    Column({ space: 20 }) {
      Text(this.user.name)
      Text(this.user.age.toString())
      Button("修改数据")
        .onClick(() => {
          this.user.age++
        })
      Button("跳转页面")
    }
    .height('100%')
    .width('100%')
  }
}
```



2）页面间共享

:::info
如果你想在`UIAbility`中共享某个localStorage，可以在入口处直接初始化传入

+ 可以在loadContent过程中直接传入创建的LocalStorage
+ `const storage = LocalStorage.GetShared()` 得到实例
+ 通过 `@Entry(storage)` 传入页面

:::

+ 在UIAbility进行初始化storage

```typescript
windowStage.loadContent('pages/06/LocalStorageCase', tokenObj) // 传入localStorage

```

+ 在页面中传入

```typescript
const shareLocal = LocalStorage.GetShared()
@Entry(shareLocal)
```

:::info
注意测试全局分享LocalStorage时需要使用模拟器，preview不支持

:::

:::success
服务卡片-只能通过LocalStorage进行接收参数

:::



:::info
+ 应用逻辑中使用参考 [链接](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-localstorage-0000001524537149-V3#section614118685518)

:::

<h2 id="QYD9A">关于模拟器</h2>
:::color1
模拟器基本上能够演示及测试真机75%左右的功能

99.9%的UI和真机一致

window的模拟器问题多很多-没有键盘-不能输入中文-不能使用地图组件-不能使用华为账号服务

mac-arm的模拟器问题最少

+ 真机需要签名 需要指纹 需要证书 
+ 模拟器一概不需要

:::

+ 新建模拟器

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723018037236-9c1265b2-a143-41d1-90dd-05bc409a2ff0.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723018052129-69ef96c6-7df4-41a5-94d1-8238abc72747.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723018160329-98d9b0cd-dc9e-491a-86e8-eb4b94ed3039.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723018240271-6a35aea7-e2e0-4e7b-b64a-afee8a5817d8.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723018387280-42233880-2fb9-4abb-9526-318b97f00a5e.png)

<h3 id="2d11529a">2. 应用状态-AppStorage（需要模拟器）</h3>
:::color2
LocalStorage是针对UIAbility的状态共享- 一个UIAbility有个页面

一个应用可能有若干个UIAbility

:::

:::success
<h2 id="qe1Um"><font style="color:rgba(0, 0, 0, 0.9);">概述</font></h2>
<font style="color:rgba(0, 0, 0, 0.9);">AppStorage是在应用启动的时候会被创建的单例。它的目的是为了提供应用状态数据的中心存储，这些状态数据在应用级别都是可访问的。AppStorage将在应用运行过程保留其属性。属性通过唯一的键字符串值访问。</font>

<font style="color:rgba(0, 0, 0, 0.9);">AppStorage可以和UI组件同步，且可以在应用业务逻辑中被访问。</font>

<font style="color:rgba(0, 0, 0, 0.9);">AppStorage支持应用的</font>[主线程](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/thread-model-stage-0000001820999617)<font style="color:rgba(0, 0, 0, 0.9);">内多个UIAbility实例间的状态共享。</font>

<font style="color:rgba(0, 0, 0, 0.9);">AppStorage中的属性可以被双向同步，数据可以是存在于本地或远程设备上，并具有不同的功能，比如数据持久化（详见</font>[PersistentStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-persiststorage-0000001774119950)<font style="color:rgba(0, 0, 0, 0.9);">）。这些数据是通过业务逻辑中实现，与UI解耦，如果希望这些数据在UI中使用，需要用到</font>[@StorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage-0000001774279622#ZH-CN_TOPIC_0000001774279622__storageprop)<font style="color:rgba(0, 0, 0, 0.9);">和</font>[@StorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-appstorage-0000001774279622#ZH-CN_TOPIC_0000001774279622__storagelink)<font style="color:rgba(0, 0, 0, 0.9);">。</font>

:::

:::info
`AppStorage` 是应用全局的UI状态存储，是和应用的进程绑定的，由UI框架在应用程序启动时创建，为应用程序UI状态属性提供中央存储。-注意它也是内存数据，不会写入磁盘

**第一种用法-使用UI修饰符**

+ **如果是初始化使用 **`**AppStorage.setOrCreate(key,value)**`
+ **单向 **`**@StorageProp('user')**`** 组件内可变**
+ **双向 **`**@StorageLink('user')**`** 全局均可变**

**第二种用法  使用API方法**

+ `**AppStorage.get<ValueType>(key)**`** 获取数据**
+ `**AppStorage.set<ValueType>(key,value)**`** 覆盖数据**
+ `**const link: SubscribedAbstractProperty<ValueType> = AppStorage.Link(key)**`** 覆盖数据 **
    - `**link.set(value)**`** 修改**
    - `**link.get()**`** 获取**

:::

:::success
AppStorage.setOrCreate<T>("", T) // 创建或者设置某个字段的属性

AppStorage.get<T>("") // 获取的全局状态类型

如果遇到获取数据的类型为空，可以用if判断，也可以用非空断言来解决

StorageLink . - 直接修改-自动同步到全局状态

StorageProp- 可以改，只会在当前组件生效，只是改的全局状态的副本，不会对全局状态产生影响

:::



A页面登录存入AppStorage

```typescript
import { promptAction, router } from '@kit.ArkUI'

@Entry
@Component
struct AppStorageCase {
  @State
  username: string = "shuiruohanyu"
  @State
  password: string = "123456"
  login() {
    if(this.username === 'shuiruohanyu' && this.password === "123456") {
      // 要将当前用户的身份存入AppStorage
      AppStorage.setOrCreate<UserInfoModel>("userInfo", new UserInfoModel({
        username: '水若寒宇',
        age: 34,
        avatar: 'https://c-ssl.dtstatic.com/uploads/blog/202103/25/20210325082228_4fb35.thumb.1000_0.jpg'
      }))
      router.pushUrl({ url: 'pages/11/AppMain' })
    }else {
      promptAction.showToast({ message: '登录失败' })
    }
  }
  build() {
    Row() {
      Column({ space: 20 }) {
        TextInput({ placeholder: '请输入用户名', text: $$this.username })

        TextInput({ placeholder: '请输入密码', text: $$this.password })
          .type(InputType.Password)
        Button("登录")
          .width('100%')
          .onClick(() => {
             this.login()
          })
      }
      .padding(20)
      .width('100%')
    }
    .height('100%')
  }
}

export interface  UserInfo {
  username: string
  age: number
  avatar: string
}
export class UserInfoModel implements UserInfo {
  username: string = ''
  age: number = 0
  avatar: string = ''

  constructor(model: UserInfo) {
    this.username = model.username
    this.age = model.age
    this.avatar = model.avatar
  }
}

```

B页面使用

```typescript
import { UserInfo, UserInfoModel } from './AppStorageCase'
import { router } from '@kit.ArkUI'

@Entry
@Component
struct AppMain {
  // @StorageLink("userInfo")
  user: UserInfoModel = new UserInfoModel({} as UserInfo)

  aboutToAppear(): void {
    let obj = AppStorage.get<UserInfoModel>("userInfo")
    this.user = obj!
   }
  lgout () {
    AppStorage.set("userInfo", null) // 清空数据
    router.replaceUrl({ url: 'pages/11/AppStorageCase' })
  }
  build() {
    Column() {
      Row({ space: 20 }) {
        Column({ space: 10 }) {
          Image(this.user.avatar)
            .width(60)
            .aspectRatio(1)
            .borderRadius(30)

          Text(this.user.username)
        }
        Text(`年龄：${this.user.age}岁`)
      }
      .alignItems(VerticalAlign.Center)
      .padding(20)
      .width('100%')
      Button("退出")
        .onClick(() => {
          this.lgout()
        })
    }
    .width('100%')
    .height('100%')
  }
}
```



<h3 id="64ec169b">3. 状态持久化-PersistentStorage（需要模拟器）</h3>
:::info
前面讲的所有状态均为内存状态，也就是应用退出便消失，所以如果我们想持久化的保留一些数据，应该使用

`PersistentStorage`。

注意：

UI和业务逻辑不直接访问 `PersistentStorage` 中的属性，所有属性访问都是对 `AppStorage` 的访问，`AppStorage` 中的更改会自动同步到 `PersistentStorage`。



也就是，我们和之前访问AppStorage是一样的，只不过需要提前使用PersistentStorage来声明

:::

> `PersistentStorage` 将选定的 `AppStorage` 属性保留在设备磁盘上。
>

:::warning
+ 支持：number, string, boolean, enum 对象等类型
+ 持久化变量最好是小于2kb的数据，如果开发者需要存储大量的数据，建议使用数据库api。

用法：

    PersistentStorage.persistProp('属性名', 值)



注意： 如果用了持久化, 那么AppStorage读取出来的对象实际上是个json字符串

          如果没用持久化 。那么读取出来的对象就是对象

:::



:::color2
⚠️： `**<font style="color:#DF2A3F;">PersistentStorage</font>**`**<font style="color:#DF2A3F;">必须只能在页面中声明之后才可以使用，不支持在UIAbility中使用</font>**

:::

> 将刚刚的token直接持久化存储
>

```typescript
PersistentStorage.PersistProp("user_token", '') // 初始化磁盘

```

:::info
只要初始化了数据，我们以后使用AppStorage就可以读取和设置，它会自动同步到我们的磁盘上

目前不支持复杂对象的持久化，如果你需要存储，你需要把它序列化成功字符串

+ 测试：需要在真机或模拟器调试

:::



:::color2
大家可以在上一个例子之前添加 PersistentStorage.PersistProp('属性名', 值)

然后直接使用AppStorage进行set就可以了，设置完成之后，使用模拟器先把任务销毁，然后再查看数据是否显示

:::



:::success
<h2 id="iSNsl"><font style="color:rgba(0, 0, 0, 0.9);">限制条件</font></h2>
<font style="color:rgba(0, 0, 0, 0.9);">PersistentStorage允许的类型和值有：</font>

+ <font style="color:rgb(36, 39, 40);">number, string, boolean, enum 等简单类型。</font>
+ <font style="color:rgb(36, 39, 40);">可以被JSON.stringify()和JSON.parse()重构的对象。例如Date, Map, Set等内置类型则不支持，以及对象的属性方法不支持持久化。</font>

<font style="color:rgba(0, 0, 0, 0.9);">PersistentStorage不允许的类型和值有：</font>

+ <font style="color:rgb(36, 39, 40);">不支持嵌套对象（对象数组，对象的属性是对象等）。因为目前框架无法检测AppStorage中嵌套对象（包括数组）值的变化，所以无法写回到PersistentStorage中。</font>
+ <font style="color:rgb(36, 39, 40);">不支持undefined 和 null 。</font>

<font style="color:rgba(0, 0, 0, 0.9);">持久化数据是一个相对缓慢的操作，应用程序应避免以下情况：</font>

+ <font style="color:rgb(36, 39, 40);">持久化大型数据集。</font>
+ <font style="color:rgb(36, 39, 40);">持久化经常变化的变量。</font>

<font style="color:rgba(0, 0, 0, 0.9);">PersistentStorage的持久化变量最好是小于2kb的数据，不要大量的数据持久化，因为PersistentStorage写入磁盘的操作是同步的，大量的数据本地化读写会同步在UI线程中执行，影响UI渲染性能。如果开发者需要存储大量的数据，建议使用数据库api。</font>

<font style="color:rgba(0, 0, 0, 0.9);">PersistentStorage和UIContext相关联，需要在</font>[UIContext](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-uicontext-0000001774280798#ZH-CN_TOPIC_0000001774280798__uicontext)<font style="color:rgba(0, 0, 0, 0.9);">明确的时候才可以调用，可以通过在</font>[runScopedTask](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/js-apis-arkui-uicontext-0000001774280798#ZH-CN_TOPIC_0000001774280798__runscopedtask)<font style="color:rgba(0, 0, 0, 0.9);">里明确上下文。如果没有在UIContext明确的地方调用，将导致无法持久化数据。</font>

:::





:::success
此时此刻，需要做一件事， 有token跳转到主页，没有token跳转到登录

:::

:::success
首选项

+ 每一个key的value的长度最大为8kb
+ 创建首选项-仓库的概念- 应用可以有N个仓库，一个仓库中可以有N个key

:::

<h3 id="QYlk0">3.倒计时的用法</h3>
+ 用法

:::color1
setTimeout 只会执行一次

setInterval。会不断执行

:::

+ 语法

```arkts
let timer = setTimeout(() => {}, 1000) // 会在一秒之后执行逻辑
let timer = setInterval(() => {}, 1000) // 每一秒执行一次逻辑
```

+ 销毁定时器

```arkts
clearTimeout(timer)  // 销毁定时器
```

+ 广告页进入5秒销毁，支持点击跳过

```arkts
import { preferences } from '@kit.ArkData';

@Entry
@Component
struct FirstSelect {
  @State
  num: number = 0

  aboutToAppear(): void {
    // 读取首选项的值
    this.getData()
  }

  getData() {
    this.num = new TokenManager().getToken()
  }

  build() {
    Column({ space: 20 }) {
      Text(this.num.toString())
        .fontSize(60)
      Button("写入首选项")
        .onClick(() => {
          new TokenManager().setToken("999999")
        })
    }
    .height('100%')
    .width('100%')
  }
}


// class 读写首选项
export class TokenManager {
  context?: Context

  // 获取仓库
  getStore() {
    // Sync是同步 非Sync是异步
    // 传入上下文
    // 页面(getContext())和UIAbility(this.context)
    return preferences.getPreferencesSync(this.context || getContext(), {
      name: 'token'  // 仓库名 文件名
    })
  }

  // getList => Promise<123>
  // getListSync => 123

  // 写入token
  async setToken(token: string) {
    const store = this.getStore() // 获取仓库
    store.putSync("abc", token)
    // 必须得flush一下
    await store.flush() // 写入磁盘

  }

  // 获取token
  getToken() {
    const store = this.getStore()
    return store.getSync("abc", 10) as number
  }
}
```

<h3 id="oXHHF">4.首选项</h3>
:::color1
![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723024845846-2dce77ed-db85-4b71-8cdb-56b280b357d9.png)

:::

:::color1
+ 仓库的概念-一个仓库就是一个文件
+ 一个文件可以有N个键值
+ 键值的概念-一个键值有一定大小限制-8192个字节

过程

+ 获取仓库
+ 写入内容， put方法，写入之后必须flush(刷新磁盘)

:::

```typescript
import preferences from '@ohos.data.preferences'

export class TokenManager {
  static async getStore(context?: Context) {
    // 上下文 如果是在页面中调用 getContext
    // 1 在页面中调用 2. ability中调用（不能使用getContext()  因为此时页面还没初始化呢）
    return await preferences.getPreferences(context || getContext(), "token_store")
  }

  static async setToken(token: string, context?: Context) {
    const store = await TokenManager.getStore(context)
    store.putSync("my_token", token) // 同步写入内容
    // 写入磁盘
    await store.flush()
  }
  static  async  getToken (context?: Context) {
    const store = await TokenManager.getStore(context)
    return store.getSync("my_token", "") as string
  }
}


```

+ 在ability中判断

```typescript
 if(await TokenManager.getToken(this.context)) {
      windowStage.loadContent('pages/11/Home',local, (err, data) => {
        if (err.code) {
          hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
          return;
        }
        hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
      });
    }else {
      windowStage.loadContent('pages/11/Login',local, (err, data) => {
        if (err.code) {
          hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
          return;
        }
        hilog.info(0x0000, 'testTag', 'Succeeded in loading the content. Data: %{public}s', JSON.stringify(data) ?? '');
      });
    }
```

<h3 id="ZGAyU">5.相对布局</h3>
:::info
<font style="color:rgba(0, 0, 0, 0.9);">相对布局组件，用于复杂场景中元素对齐的布局。</font>

<font style="color:rgba(0, 0, 0, 0.9);">需要一个参考布局的容器RelativeContainer和需要排列的若干子组件</font>

<font style="color:rgba(0, 0, 0, 0.9);">注意：容器的id固定为__container__，参与相对布局的容器内组件若被设备锚点，需要设置id，否则不显示</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1718615647989-abd4f984-764f-45c3-a023-9c103deeed7f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_10%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

:::info
准备一个容器RelativeContainer，内部组件通过alignRules设置对其方式

+ 垂直方向对齐
    - top：设置元素上方对齐位置
    - bottom：设置元素下方对齐位置
    - center：设置元素垂直中线对齐位置
+ 水平方向对齐
    - left：设置元素左侧对齐位置
    - right：设置元素右侧对齐位置
    - middle：设置元素水平中线对齐位置

:::

```typescript
@Entry
@Component
struct RelativeCase {
  build() {
    RelativeContainer() {
      RelativeContainer() {
        Row(){}
        .width('33%')
        .aspectRatio(1)
        .alignRules({
          top: { anchor: '__container__', align: VerticalAlign.Top },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
        .backgroundColor(Color.Red)
        Row(){}
        .width('33%')
        .aspectRatio(1)
        .alignRules({
          bottom: { anchor: '__container__', align: VerticalAlign.Bottom },
          middle: { anchor: '__container__', align: HorizontalAlign.Center }
        })
        .backgroundColor(Color.Yellow)
        Row(){}
        .width('33%')
        .aspectRatio(1)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          left: { anchor: '__container__', align: HorizontalAlign.Start }
        })
        .backgroundColor(Color.Blue)
        .zIndex(2)
        Row(){}
        .width('33%')
        .aspectRatio(1)
        .alignRules({
          center: { anchor: '__container__', align: VerticalAlign.Center },
          right: { anchor: '__container__', align: HorizontalAlign.End }
        })
        .backgroundColor(Color.Green)
      }
      .width('60%')
      .aspectRatio(1)
      .backgroundColor(Color.Pink)
      .alignRules({
        center: { anchor: '__container__', align: VerticalAlign.Center },
        middle: { anchor: '__container__', align: HorizontalAlign.Center }
      })
    }
    .height('100%')
    .width('100%')
    .id('firstContainer')
    .backgroundColor(Color.Gray)
  }
}
```



<h2 id="2f6dbb9c">4.网络管理（需要模拟器-新版500以上编辑器预览期也可以发请求了）</h2>
:::color1
Preview（预览操作-不具备数据传输能力）

ObjectLink

:::

:::color1
ArkTS

ArkUI

:::

<h3 id="5d8103da">1. 应用权限</h3>
:::color2
ATM (AccessTokenManager) 是HarmonyOS上基于AccessToken构建的统一的应用权限管理能力

应用权限保护的对象可以分为数据和功能：

+ 数据包含了个人数据（如照片、通讯录、日历、位置等）、设备数据（如设备标识、相机、麦克风等）、应用数据。
+ 功能则包括了设备功能（如打电话、发短信、联网等）、应用功能（如弹出悬浮框、创建快捷方式等）等。

根据授权方式的不同，权限类型可分为system_grant（系统授权）和user_grant（用户授权）。

:::

+ 配置文件权限声明(系统权限只需要配置这个文件就可以了)
+ 向用户申请授权（1.配置权限文件2. 经过用户同意 ）

:::color1
做应用的时候要注意： 

 现在的国家要求： 目前的App不允许一上来就向用户要权限，而是用到时才申请

目前鸿蒙申请的特点： 申请的弹窗只会弹出一次！！！不论你同意还是不同意！！！

:::

例如：访问网络需要联网权限



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1701346958161-2d8aed0c-6898-4888-9b1f-0dfaaef83371.png)



```json
{
  "module" : {
    // ...
    "requestPermissions":[
      {
        "name" : "ohos.permission.INTERNET"
      }
    ]
  }
}
```



<h3 id="07767728">2. HTTP请求（需要模拟器-新版可以不用了）</h3>
:::success
<h2 id="t2z2F"><font style="color:rgba(0, 0, 0, 0.9);">request接口开发步骤</font></h2>
1. <font style="color:rgb(36, 39, 40);">从@ohos.net.http.d.ts中导入http命名空间。</font>
2. <font style="color:rgb(36, 39, 40);">调用createHttp()方法，创建一个HttpRequest对象。</font>
3. <font style="color:rgb(36, 39, 40);">调用该对象的on()方法，订阅http响应头事件，此接口会比request请求先返回。可以根据业务需要订阅此消息。</font>
4. <font style="color:rgb(36, 39, 40);">调用该对象的request()方法，传入http请求的url地址和可选参数，发起网络请求。</font>
5. <font style="color:rgb(36, 39, 40);">按照实际业务需要，解析返回结果。</font>
6. <font style="color:rgb(36, 39, 40);">调用该对象的off()方法，取消订阅http响应头事件。</font>
7. <font style="color:rgb(36, 39, 40);">当该请求使用完毕时，调用destroy()方法主动销毁。</font>

:::

```typescript
// 引入包名
import http from '@ohos.net.http';
import { BusinessError } from '@ohos.base';

// 每一个httpRequest对应一个HTTP请求任务，不可复用
let httpRequest = http.createHttp();
// 用于订阅HTTP响应头，此接口会比request请求先返回。可以根据业务需要订阅此消息
// 从API 8开始，使用on('headersReceive', Callback)替代on('headerReceive', AsyncCallback)。 8+
httpRequest.on('headersReceive', (header) => {
  console.info('header: ' + JSON.stringify(header));
});
httpRequest.request(
  // 填写HTTP请求的URL地址，可以带参数也可以不带参数。URL地址需要开发者自定义。请求的参数可以在extraData中指定
  "EXAMPLE_URL",
  {
    method: http.RequestMethod.POST, // 可选，默认为http.RequestMethod.GET
    // 开发者根据自身业务需要添加header字段
    header: [{
      'Content-Type': 'application/json'
    }],
    // 当使用POST请求时此字段用于传递内容
    extraData: "data to send",
    expectDataType: http.HttpDataType.STRING, // 可选，指定返回数据的类型
    usingCache: true, // 可选，默认为true
    priority: 1, // 可选，默认为1
    connectTimeout: 60000, // 可选，默认为60000ms
    readTimeout: 60000, // 可选，默认为60000ms
    usingProtocol: http.HttpProtocol.HTTP1_1, // 可选，协议类型默认值由系统自动指定
    usingProxy: false, // 可选，默认不使用网络代理，自API 10开始支持该属性
    caPath:'/path/to/cacert.pem', // 可选，默认使用系统预制证书，自API 10开始支持该属性
    clientCert: { // 可选，默认不使用客户端证书，自API 11开始支持该属性
      certPath: '/path/to/client.pem', // 默认不使用客户端证书，自API 11开始支持该属性
      keyPath: '/path/to/client.key', // 若证书包含Key信息，传入空字符串，自API 11开始支持该属性
      certType: http.CertType.PEM, // 可选，默认使用PEM，自API 11开始支持该属性
      keyPassword: "passwordToKey" // 可选，输入key文件的密码，自API 11开始支持该属性
    },
    multiFormDataList: [ // 可选，仅当Header中，'content-Type'为'multipart/form-data'时生效，自API 11开始支持该属性
      {
        name: "Part1", // 数据名，自API 11开始支持该属性
        contentType: 'text/plain', // 数据类型，自API 11开始支持该属性
        data: 'Example data', // 可选，数据内容，自API 11开始支持该属性
        remoteFileName: 'example.txt' // 可选，自API 11开始支持该属性
      }, {
        name: "Part2", // 数据名，自API 11开始支持该属性
        contentType: 'text/plain', // 数据类型，自API 11开始支持该属性
        // data/app/el2/100/base/com.example.myapplication/haps/entry/files/fileName.txt
        filePath: `${getContext(this).filesDir}/fileName.txt`, // 可选，传入文件路径，自API 11开始支持该属性
        remoteFileName: 'fileName.txt' // 可选，自API 11开始支持该属性
      }
    ]
  }, (err: BusinessError, data: http.HttpResponse) => {
    if (!err) {
      // data.result为HTTP响应内容，可根据业务需要进行解析
      console.info('Result:' + JSON.stringify(data.result));
      console.info('code:' + JSON.stringify(data.responseCode));
      // data.header为HTTP响应头，可根据业务需要进行解析
      console.info('header:' + JSON.stringify(data.header));
      console.info('cookies:' + JSON.stringify(data.cookies)); // 8+
      // 当该请求使用完毕时，调用destroy方法主动销毁
      httpRequest.destroy();
    } else {
      console.error('error:' + JSON.stringify(err));
      // 取消订阅HTTP响应头事件
      httpRequest.off('headersReceive');
      // 当该请求使用完毕时，调用destroy方法主动销毁
      httpRequest.destroy();
    }
  }
);
```

:::color2
美团外卖接口地址： [https://zhousg.atomgit.net/harmonyos-next/takeaway.json](https://zhousg.atomgit.net/harmonyos-next/takeaway.json)

:::

2）使用 `@ohos.net.http` 模块发请求

```typescript
import { http } from '@kit.NetworkKit';
import { promptAction, router } from '@kit.ArkUI';
import { AuthManager } from './AuthManager';

@Entry
@Component
struct HttpCase {
  @State
  mobile: string = ""
  @State
  code: string = ""
  @State
  count: number = 5 // 默认倒计时5秒
  timer: number = -1 // 记录倒计时标记

  async getFoodData() {
    try {
      const req = http.createHttp()
      const result = await req.request("https://zhousg.atomgit.net/harmonyos-next/takeaway.json")
      AlertDialog.show({
        message: result.result as string
      })
    } catch (error) {
      AlertDialog.show({
        message: error.message as string
      })
    }

    // req.request("https://zhousg.atomgit.net/harmonyos-next/takeaway.json", (err, response) => {
    //   if (!err) {
    //     AlertDialog.show({ message: response.result as string })
    //   } else {
    //     AlertDialog.show({ message: err.message })
    //   }
    // })
  }

  getBtnEnable() {
    if (this.mobile && this.code) {
      return true
    }
    return false
  }

  // 发送验证码的方法
  async sendCode() {
    if (this.count === 5 && this.mobile) {
      // 才可以发验证码
      await this.sendHttp() // 等到发送成功
      // 开始倒计时
      this.beginRun()
    }
  }

  beginRun() {
    this.timer = setInterval(() => {
      if (this.count === 0) {
        clearInterval(this.timer)
        this.count = 5 // 重新恢复之间的倒计时逻辑
        return // 一定要return
      }
      this.count--
    }, 1000)
  }

  aboutToDisappear(): void {
    clearInterval(this.timer) // 离开页面销毁所有的不需要的能力
  }

  async sendHttp() {
    const req = http.createHttp()
    await req.request(`https://toutiao.itheima.net/v1_0/sms/codes/${this.mobile}`)
    promptAction.showToast({ message: '发送验证码成功' })
    req.destroy()
  }

  // 登录方法
  async login() {
    const req = http.createHttp()
    const result = await req.request("https://toutiao.itheima.net/v1_0/authorizations", {
      method: http.RequestMethod.POST,
      header: {
        "Content-Type": "application/json" // 约束传入的body参数为对象类型
      },
      extraData: {
        mobile: this.mobile,
        code: this.code
      }
    })
    req.destroy()
    const res = JSON.parse(result.result as string) as ResponseData<TokenObj>
    new AuthManager().setToken(res.data!.token) // 设置首选项  为了写入磁盘 为了进入判断
    AppStorage.setOrCreate<string>("token", res.data!.token) // 用起来很简单
    // res.data?.refresh_token
    // AlertDialog.show({ message: result.result as string })
    router.pushUrl({
      url: 'pages/06/AppStorageCaseMain'
    })
  }

  build() {
    Column({ space: 20 }) {
      // Button("获取数据")
      //   .onClick(() => {
      //     this.getFoodData()
      //   })
      TextInput({ placeholder: "请输入手机号", text: $$this.mobile })
      Row({ space: 10 }) {
        TextInput({
          placeholder: '请输入验证码', text: $$this.code
        })
          .layoutWeight(1)
        Text(this.count === 5 ? "发送验证码" : `还有${this.count}秒`)
          .onClick(() => {
            this.sendCode() // 发送验证码的方法
          })
      }

      Button("登录")
        .enabled(this.getBtnEnable())
        .width("100%")
        .onClick(() => {
          // 登录接口
          this.login()

        })

    }
    .padding(20)
    .alignItems(HorizontalAlign.Center)
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width('100%')
  }
}

class ResponseData<T> {
  data: T | null = null
  message: string = ""
}

class TokenObj {
  token: string = ""
  refresh_token: string = ""
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723104105432-f11947b9-3db2-42a7-b614-2d287401820e.png)

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702210757454-3eb4199a-e6d3-4d50-bf2f-e131c0027129.png)



:::success
使用第三方包 axios

:::

:::success
[openharmony中心仓地址](https://ohpm.openharmony.cn/#/cn/home)

:::

+ 安装axios

```bash
$  ohpm install @ohos/axios
```

+ 发起请求

```typescript
import axios, { AxiosResponse } from '@ohos/axios'
import { promptAction } from '@kit.ArkUI';

@Entry
@Component
struct HttpCase {
  @State message: string = 'Hello World';

  async getData() {
    const result = await axios.get<object, AxiosResponse<object,null>>("https://zhousg.atomgit.net/harmonyos-next/takeaway.json")
    promptAction.showToast({ message: JSON.stringify(result) })
  }

  build() {
    Row() {
      Column() {
        Text(this.message)
          .fontSize(50)
          .fontWeight(FontWeight.Bold)
        Button("测试请求")
          .onClick(() => {
            this.getData()
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
interface Data {
  name: string
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710562181504-0d4435a6-bc31-4264-998a-1f4f6aa86343.png)



<h2 id="db5848fc">5.今日案例-美团外卖</h2>
:::success
准备基础色值

在一个标准项目中，应该会有几套标准的配色，此时可以使用resources/base/element/color.json来帮我们统一管理，使用时使用$r("app.color.xxx")来取值即可

:::

+ 将color赋值到resources/base/element/color.json中

```json
{
  "color": [
    {
      "name": "start_window_background",
      "value": "#FFFFFF"
    },
    {
      "name": "white",
      "value": "#FFFFFF"
    },
    {
      "name": "black",
      "value": "#000000"
    },
    {
      "name": "bottom_back",
      "value": "#222426"
    },
    {
      "name": "main_color",
      "value": "#f8c74e"
    },
    {
      "name": "select_border_color",
      "value": "#fa0"
    },
    {
      "name": "un_select_color",
      "value": "#666"
    },
    {
      "name": "search_back_color",
      "value": "#eee"
    },
    {
      "name": "search_font_color",
      "value": "#999"
    },
    {
      "name": "food_item_second_color",
      "value": "#333"
    },
    {
      "name": "food_item_label_color",
      "value": "#fff5e2"
    },
    {
      "name": "top_border_color",
      "value": "#e4e4e4"
    },
    {
      "name": "left_back_color",
      "value": "#f5f5f5"
    },{
      "name": "font_main_color",
      "value": "#ff8000"
    }
  ]
}
```



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1701339078002-5cd6d88b-98d2-4920-88ba-ebdd49a1f3d6.png)![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1701339065832-c5ae32cd-b662-4df5-ae98-885484023982.png)

<h3 id="7a3097a1">1. 目录结构-入口页面</h3>
:::success
新建如下目录结构

   pages

        -MeiTuan

           -api

           -components

           -viewmodels

           -utils

           -MTIndex.ets(Page)

       

:::

+ 在MTIndex.ets中设置基础布局

```typescript
@Entry
  @Component
  struct MTIndex {
    build() {
      Column() {

      }
      .width('100%')
        .height("100%")
        .backgroundColor($r("app.color.white"))
    }
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710746129345-a925afa5-581b-4411-86aa-decb0440bbaf.png)

+ 新建MTTop-MTMain-MTBottom三个组件-在components目录下

```typescript
@Component
struct MTMain {
  build() {
    Text("MTMain")
  }
}
export default MTMain
```

```typescript
@Component
struct MTTop {
  build() {
    Text("MTTop")
  }
}
export default MTTop
```

```typescript
@Component
struct MTBottom {
  build() {
    Text("MTBottom")
  }
}
export default MTBottom
```

+ 在MTIndex.ets中放入

```typescript
import MTBottom from './components/MTBottom'
import MTMain from './components/MTMain'
import MTTop from './components/MTTop'

@Entry
@Component
struct MTIndex {
  build() {
    Column() {
      Stack({ alignContent: Alignment.Bottom }) {
        Column() {
          MTTop()
          MTMain()
        }
        .height("100%")
        MTBottom()
      }.layoutWeight(1)
    }
    .width('100%')
    .height("100%")
    .backgroundColor($r("app.color.white"))
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710748786677-7b08bc60-041d-4090-8218-cf9721d28ffe.png)



<h3 id="2b362659">2. 页面结构-底部组件</h3>
![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702214197578-0d1050de-45c2-4ee3-b81c-82853ca0c0da.png)

:::success
将图片资源 [图片.zip](https://weiqi123.yuque.com/attachments/yuque/0/2024/zip/32778948/1727514811382-efb747d0-6b0a-4dcf-815a-911d628f5c39.zip)放入到资源目录下 resources/media

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710750602509-4d63aea4-d84d-48b7-9162-7845621be612.png)

```typescript
@Preview
@Component
struct MTBottom {
  build() {
    Row () {
      Row() {
        // 小哥的显示
        Badge({
          value: '0',
          position: BadgePosition.Right,
          style: {
            badgeSize: 18
          }
        }){
           Image($r("app.media.ic_public_cart"))
             .width(47)
             .height(69)
             .position({
               y: -20
             })
        }
        .margin({
          left: 25,
          right: 10
        })
        // 显示费用
        Column() {
          Text(){
            // span imageSpan
            Span("¥")
              .fontSize(12)
            Span("0.00")
              .fontSize(24)
          }
            .fontColor($r("app.color.white"))
          Text("预估另需配送费¥5元")
            .fontColor($r("app.color.search_font_color"))
            .fontSize(14)
        }
        .alignItems(HorizontalAlign.Start)
        .layoutWeight(1)

        Text("去结算")
          .height(50)
          .width(100)
          .backgroundColor($r("app.color.main_color"))
          .textAlign(TextAlign.Center)
          .borderRadius({
            topRight: 25,
            bottomRight: 25
          })
      }
      .height(50)
      .backgroundColor($r("app.color.bottom_back"))
      .width('100%')
      .borderRadius(25)
    }
    .width('100%')
    .padding({
      left: 20,
      right: 20,
      bottom: 20
    })
  }
}
export default MTBottom
```



<h3 id="1258bbd7">3. 顶部结构-MTTop（复制粘贴）</h3>
![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710750647113-33f1fb8a-c835-4af9-b83d-82b3076d2f1d.png)

```typescript
@Component
struct MTTop {
  @Builder
  NavItem(active: boolean, title: string, subTitle?: string) {
    Column() {
      Text() {
        Span(title)
        if (subTitle) {
          Span(' ' + subTitle)
            .fontSize(10)
            .fontColor(active ? $r("app.color.black") : $r("app.color.un_select_color"))
        }
      }.layoutWeight(1)
      .fontColor(active ? $r("app.color.black") : $r("app.color.un_select_color"))
      .fontWeight(active ? FontWeight.Bold : FontWeight.Normal)

      Text()
        .height(1)
        .width(20)
        .margin({ left: 6 })
        .backgroundColor(active ? $r("app.color.select_border_color") : 'transparent')
    }
    .width(73)
    .alignItems(HorizontalAlign.Start)
    .padding({ top: 3 })
  }
  build() {
    Row() {
      this.NavItem(true, '点菜')
      this.NavItem(false, '评价', '1796')
      this.NavItem(false, '商家')
      Row() {
        Image($r('app.media.ic_public_search'))
          .width(14)
          .aspectRatio(1)
          .fillColor($r("app.color.search_font_color"))
        Text('请输入菜品名称')
          .fontSize(12)
          .fontColor($r("app.color.search_back_color"))
      }
      .backgroundColor($r("app.color.search_back_color"))
      .height(25)
      .borderRadius(13)
      .padding({ left: 5, right: 5 })
      .layoutWeight(1)

    }
    .padding({ left: 15, right: 15 })
    .height(40)
    .border({ width: { bottom: 0.5 }, color: $r("app.color.top_border_color") })
  }
}

export default MTTop
```

<h3 id="3220dabf">4. 页面结构-商品菜单和商品列表</h3>


![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702218609671-beaff31e-9639-4e52-9161-110734d7967d.png)



+ 抽提MTFoodItem组件(粘贴)

```typescript
@Preview
@Component
struct MTFoodItem {
  build() {
    Row() {
      Image('https://zqran.gitee.io/images/waimai/8078956697.jpg')
        .width(90)
        .aspectRatio(1)
      Column({ space: 5 }) {
        Text('小份酸汤莜面鱼鱼+肉夹馍套餐')
          .textOverflow({
            overflow: TextOverflow.Ellipsis,
          })
          .maxLines(2)
          .fontWeight(600)
        Text('酸汤莜面鱼鱼，主料：酸汤、莜面 肉夹馍，主料：白皮饼、猪肉')
          .textOverflow({
            overflow: TextOverflow.Ellipsis,
          })
          .maxLines(1)
          .fontSize(12)
          .fontColor($r("app.color.food_item_second_color"))
        Text('点评网友推荐')
          .fontSize(10)
          .backgroundColor($r("app.color.food_item_label_color"))
          .fontColor($r("app.color.font_main_color"))
          .padding({ top: 2, bottom: 2, right: 5, left: 5 })
          .borderRadius(2)
        Text() {
          Span('月销售40')
          Span(' ')
          Span('好评度100%')
        }
        .fontSize(12)
        .fontColor($r("app.color.black"))

        Row() {
          Text() {
            Span('¥ ')
              .fontColor($r("app.color.font_main_color"))
              .fontSize(10)
            Span('34.23')
              .fontColor($r("app.color.font_main_color"))
              .fontWeight(FontWeight.Bold)
          }
        }
        .justifyContent(FlexAlign.SpaceBetween)
        .width('100%')
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 10, right: 10 })
    }
    .padding(10)
    .alignItems(VerticalAlign.Top)
  }
}
export default MTFoodItem
```

+ 在MTMain中使用

```typescript
import MTFoodItem from './MTFoodItem'

@Component
struct MTMain {
  list: string[] = ['一人套餐', '特色烧烤', '杂粮主食']
  @State
  activeIndex: number = 0
  build() {
    Row() {
      Column() {
        ForEach(this.list, (item: string, index: number) => {
          Text(item)
            .height(50)
            .width('100%')
            .textAlign(TextAlign.Center)
            .fontSize(14)
            .backgroundColor(this.activeIndex === index ? $r("app.color.white") : $r("app.color.left_back_color"))
            .onClick(() => {
              this.activeIndex = index
            })
        })
      }
      .width(90)

      //   右侧内容
      List() {
        ForEach([1,2,3,4,5,6,7,8,9], () => {
          ListItem() {
            MTFoodItem()
          }
        })
      }.layoutWeight(1)
      .backgroundColor('#fff')
      .padding({
        bottom: 80
      })
    }
    .layoutWeight(1)
    .alignItems(VerticalAlign.Top)
    .width('100%')
  }
}
export default MTMain
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710751345207-e5a2f6ce-c788-486f-8780-ea1e9160a15c.png)

<h3 id="495e33d4">5. 页面结构-购物车</h3>
![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702219130955-2ec9afdd-b10c-40fc-affe-f0353aa0e949.png)

+ 新建MTCart组件

```typescript
import MTCartItem from './MTCartItem'

@Component
struct MTCart {
  build() {
    Column() {
      Column() {
        Row() {
          Text('购物车')
            .fontSize(12)
            .fontWeight(600)
          Text('清空购物车')
            .fontSize(12)
            .fontColor($r("app.color.search_font_color"))
        }
        .width('100%')
        .height(40)
        .justifyContent(FlexAlign.SpaceBetween)
        .border({ width: { bottom: 0.5 }, color: $r("app.color.left_back_color") })
        .margin({ bottom: 10 })
        .padding({ left: 15, right: 15 })

        List({ space: 30 }) {
          ForEach([1,2,3,4], () => {
            ListItem() {
              MTCartItem()
            }
          })
        }
        .divider({
          strokeWidth: 0.5,
          color: $r("app.color.left_back_color")
        })
        .padding({ left: 15, right: 15, bottom: 100 })
      }
      .backgroundColor($r("app.color.white"))
      .borderRadius({
        topLeft: 16,
        topRight: 16
      })
    }
    .height('100%')
    .width('100%')
    .justifyContent(FlexAlign.End)
    .backgroundColor('rgba(0,0,0,0.5)')
  }
}
export default MTCart
```

+ 新建MTCartItem组件

```typescript
@Component
struct MTCartItem {
  build() {
    Row() {
      Image('https://zqran.gitee.io/images/waimai/7384994864.jpg')
        .width(60)
        .aspectRatio(1)
        .borderRadius(8)
      Column({ space: 5 }) {
        Text('小份酸汤莜面鱼鱼+肉夹馍套餐')
          .fontSize(14)
          .textOverflow({
            overflow: TextOverflow.Ellipsis
          })
          .maxLines(2)
        Row() {
          Text() {
            Span('¥ ')
              .fontColor($r("app.color.font_main_color"))
              .fontSize(10)
            Span('34.23')
              .fontColor($r("app.color.font_main_color"))
              .fontWeight(FontWeight.Bold)
          }
        }
        .justifyContent(FlexAlign.SpaceBetween)
        .width('100%')
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 10, right: 10 })
    }
    .alignItems(VerticalAlign.Top)
  }
}
export default MTCartItem
```

+ 在MTIndex.ets中声明管控显示购物车变量

```typescript
@Provide showCart: boolean = false
```

+ 在MTIndex.ets中控制显示

```typescript
import MTBottom from './components/MTBottom'
import MTCart from './components/MTCart'
import MTMain from './components/MTMain'
import MTTop from './components/MTTop'

@Entry
@Component
struct MTIndex {
  @Provide showCart: boolean = false
  build() {
    Column() {
      Stack({ alignContent: Alignment.Bottom }) {
        Column() {
          MTTop()
          MTMain()
        }
        .height("100%")
        if(this.showCart) {
          MTCart()
        }
        MTBottom()

      }.layoutWeight(1)

    }
    .width('100%')
    .height("100%")
    .backgroundColor($r("app.color.white"))
  }
}
```

:::success
这里MTCart要放在MTBottom前面 利用层级的先后关系实现底部内容挡在购物车前面的效果

:::

+ 点击购物车图标显示隐藏购物车-MTBottom.ets

```typescript
@Component
struct MTBottom {
  @Consume
  showCart: boolean
  build() {
    Row() {
      Row() {
        Badge({
          value: '0',
          position: BadgePosition.Right,
          style: { badgeSize: 18 }
        }) {
          Image($r("app.media.ic_public_cart"))
            .width(47)
            .height(69)
            .position({ y: -19 })
        }
        .width(50)
        .height(50)
        .margin({ left: 25, right: 10 })
        .onClick(() => {
           this.showCart = !this.showCart
        })

        Column() {
          Text() {
            Span('¥')
              .fontColor('#fff')
              .fontSize(12)
            Span('0.00')
              .fontColor('#fff')
              .fontSize(24)
          }

          Text('预估另需配送费 ¥5')
            .fontSize(12)
            .fontColor('#999')
        }
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Start)

        Text('去结算')
          .backgroundColor($r("app.color.main_color"))
          .alignSelf(ItemAlign.Stretch)
          .padding(15)
          .borderRadius({
            topRight: 25,
            bottomRight: 25
          })
      }
      .height(50)
      .width('100%')
      .backgroundColor($r("app.color.bottom_back"))
      .borderRadius(25)
    }
    .width('100%')
    .padding({ left: 20, right: 20, bottom: 20 })
  }
}
export default MTBottom
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710752217589-36dc6728-8d61-49fe-a2fb-5161dc406bca.png)

<h3 id="dd84864d">6. 业务逻辑-渲染商品菜单和列表</h3>
+ viewmodels/index.ets 定义 model 数据模型

```typescript
export class FoodItem {
  id: number = 0
  name: string = ""
  like_ratio_desc: string = ""
  food_tag_list: string[] = []
  price: number = 0
  picture: string = ""
  description: string = ""
  tag: string = ""
  month_saled: number = 0
  count: number = 0
}


export class Category {
  tag: string = ""
  name: string =""
  foods: FoodItem[] = []
}
```

+ api/index.ets 使用 `http` 发送请求，获取数据

```typescript
// http
import { http } from '@kit.NetworkKit'
import axios, { AxiosResponse } from '@ohos/axios'
import { Category } from '../viewmodels'

export const getAllDataByHttp = async () => {
  const req = http.createHttp()
  const res = await req.request("https://zhousg.atomgit.net/harmonyos-next/takeaway.json")
  return JSON.parse(res.result as string) as Category[]
}

export const getAllDataByHttpThen = async (callback: (res: Category[]) => void) => {
  const req = http.createHttp()
  req.request("https://zhousg.atomgit.net/harmonyos-next/takeaway.json").then(res => {
    const result = JSON.parse(res.result as string) as Category[]
    callback(result)
  })
  // return JSON.parse(res.result as string) as Category[]
}

export const getAllDataByHttpThen2 = async () => {
  const req = http.createHttp()
  return new Promise<Category[]>((resolve, reject) => {
    req.request("https://zhousg.atomgit.net/harmonyos-next/takeaway.json").then(res => {
      const result = JSON.parse(res.result as string) as Category[]
      resolve(result)
    })
  })

  // return JSON.parse(res.result as string) as Category[]
}

export const getAllDataByAxios = async () => {
  const res =
    await axios.get<string, AxiosResponse<Category[], string>>("https://zhousg.atomgit.net/harmonyos-next/takeaway.json")
  return res.data
}
```

+ 在MTMain.ets中获取数据

```typescript
@State
list: Category[] = []
  aboutToAppear(): void {
     this.getAllData()
  }
  async getAllData () {
   this.list = await getAllData()
  }
```

+ MTMain循环内容渲染

```typescript
import { getAllDataByAxios, getAllDataByHttp, getAllDataByHttpThen, getAllDataByHttpThen2 } from '../api'
import { Category, FoodItem } from '../viewmodels'
import MTFoodItem from './MTFoodItem'

@Component
export default struct MTMain {
  @State
  list: Category[] = []
  @State
  activeIndex: number = 0
  scroller: Scroller = new Scroller()

  // 获取数据
  aboutToAppear(): void {
    this.getAllData()
  }

  async getAllData() {
    this.list = await getAllDataByHttp()
    // this.list = result
    // const result = await getAllDataByAxios()
    // AlertDialog.show({ message: JSON.stringify(result) })
    // await getAllDataByHttpThen((result) => {
    //   AlertDialog.show({ message: JSON.stringify(result) })
    // })

  }

  @Builder
  getHeaderBuildr(item: Category) {
    Row() {
      Text(item.name)
        .fontWeight(FontWeight.Bold)
        .fontSize(16)
    }
    .width("100%")
    .padding({
      left: 10
    })

  }

  build() {
    Row() {
      Column() {
        ForEach(this.list, (item: Category, index: number) => {
          Text(item.name)
            .height(50)
            .width("100%")
            .textAlign(TextAlign.Center)
            .fontSize(14)
            .backgroundColor(this.activeIndex === index ? $r("app.color.white") :
            $r("app.color.left_back_color"))
            .onClick(() => {
              this.activeIndex = index
              this.scroller.scrollToIndex(index)
            })
        })
      }
      .height("100%")
      .width(90)
      .backgroundColor($r("app.color.left_back_color"))

      // 右侧内容
      List({ scroller: this.scroller }) {
        ForEach(this.list, (item: Category, index: number) => {
          ListItemGroup({ header: this.getHeaderBuildr(item) }) {
            ForEach(item.foods, (obj: FoodItem) => {
              ListItem() {
                MTFoodItem({ item: obj })
              }
            })

          }
          .padding({
            bottom: index === (this.list.length - 1) ? 300 : 0
          })
        })
        // ForEach([1, 2, 3, 5, 6, 7, 8], () => {
        //   ListItem() {
        //     MTFoodItem()
        //   }
        // })
      }
      .padding({
        bottom: 80
      })
      .layoutWeight(1)
      .onScrollIndex((start) => {
        this.activeIndex = start // 滚动右侧 左侧激活

      })

    }
    .width("100%")
    .layoutWeight(1)
    .alignItems(VerticalAlign.Top)

  }
}
```

+ MTFoodItem组件使用属性接收数据

```typescript
import { FoodItem } from '../models'

@Preview
@Component
struct MTFoodItem {
  item: FoodItem = new FoodItem()

  build() {
    Row() {
      Image(this.item.picture)
        .width(90)
        .aspectRatio(1)
      Column({ space: 5 }) {
        Text(this.item.name)
          .textOverflow({
            overflow: TextOverflow.Ellipsis,
          })
          .maxLines(2)
          .fontWeight(600)
        Text(this.item.description)
          .textOverflow({
            overflow: TextOverflow.Ellipsis,
          })
          .maxLines(1)
          .fontSize(12)
          .fontColor($r("app.color.food_item_second_color"))
        ForEach(this.item.food_tag_list, (tag: string) => {
          Text(tag)
            .fontSize(10)
            .backgroundColor($r("app.color.food_item_label_color"))
            .fontColor($r("app.color.font_main_color"))
            .padding({ top: 2, bottom: 2, right: 5, left: 5 })
            .borderRadius(2)
        })

        Text() {
          Span('月销售' + this.item.month_saled)
          Span(' ')
          Span(this.item.like_ratio_desc)
        }
        .fontSize(12)
        .fontColor($r("app.color.black"))

        Row() {
          Text() {
            Span('¥ ')
              .fontColor($r("app.color.font_main_color"))
              .fontSize(10)
            Span(this.item.price?.toString())
              .fontColor($r("app.color.font_main_color"))
              .fontWeight(FontWeight.Bold)
          }
        }
        .justifyContent(FlexAlign.SpaceBetween)
        .width('100%')
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 10, right: 10 })
    }
    .padding(10)
    .alignItems(VerticalAlign.Top)
  }
}

export default MTFoodItem
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723113393732-ac30e0bb-638c-4a41-a4f0-2d7f959253cb.png)

<h3 id="kPaNm">7. 业务逻辑-封装新增加菜和减菜组件</h3>
![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702222558129-46ac0e7f-248b-488b-b0cf-100f2fdf11f2.png)

```typescript
@Preview
@Component
struct MTAddCut {
  build() {
    Row({ space: 8 }) {
      Row() {
        Image($r('app.media.ic_screenshot_line'))
          .width(10)
          .aspectRatio(1)

      }.width(16)
      .aspectRatio(1)
      .justifyContent(FlexAlign.Center)
      .backgroundColor($r("app.color.white"))
      .borderRadius(4)
      .border({ width: 0.5 , color: $r("app.color.main_color")})
      Text('0').fontSize(14)
      Row() {
        Image($r('app.media.ic_public_add_filled'))
          .width(10)
          .aspectRatio(1)

      }.width(16)
      .aspectRatio(1)
      .justifyContent(FlexAlign.Center)
      .backgroundColor($r("app.color.main_color"))
      .borderRadius(4)
    }
  }
}
export default MTAddCut
```

+ 放置在MTFoodItem中

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710754642335-ee37a17e-5ba4-4ba5-84ce-87a6cd6c34d8.png)

<h3 id="Kl6Zy">8. 业务逻辑-加入购物车</h3>
:::color1
首选项和UI没关系！！！并不能驱动UI

:::

:::info
设计购物车模型

我们需要持久化的数据，使用  PersistentStorage.persistProp(CART_KEY, []) 

:::

```typescript
// 购物车
import { FoodItem, OPERATE_TYPE } from '../viewmodels'

const CART_KEY = "user_cart"
// 声明持久化数据
// AppStorage-> Api/StoreageLink("key")

PersistentStorage.persistProp(CART_KEY, []) // 声明初始化数据

// 用来管理购物车 获取购物车 加减菜购物车 清空购物车
export class CartStore {
  // 获取购物车数据
  getCarts() {
    return (AppStorage.get(CART_KEY) || []) as FoodItem[] // 断言类型
  }

  // 加减购物车
  addCutCart(type: OPERATE_TYPE, food: FoodItem) {
    const list = this.getCarts() // 获取所有购物车数据
    const f = list.find(item => item.id === food.id) // 有可能找到 也有可能找不到
    // 逻辑中可用switch 但是不允许在条件渲染中使用
    if (type === OPERATE_TYPE.ADD) {
      // 加菜逻辑
      if (f) {
        // 之前加入过这个菜
        f.count++ // 因为加过 所以数量加1
      } else {
        food.count = 1 // 因为是第一次加这个菜
        list.unshift(food) // 加入到购物车
      }
    } else if (type === OPERATE_TYPE.CUT) {
      // 减菜逻辑
      if (f && f.count > 0) {
        // 这种情况要处理 1的情况 说明可以减菜
        f.count-- // 先减一次
        // 有可能的值 0  /1 2 3 4 5
        if (f.count === 0) {
          // 此时就该移除这个数据
          let index = list.findIndex(item => item.id === food.id) // 找到对应的索引
          list.splice(index, 1) // 移除数据
        }
      }
    }
    AppStorage.setOrCreate<FoodItem[]>(CART_KEY, [...list]) // 直接设置值
  }

  // 清空购物车
  clearCarts() {
    AppStorage.setOrCreate<FoodItem[]>(CART_KEY, []) // 直接设置值
  }
}

export const store = new CartStore() // 所有人公用一个实例 单例模式


// class Test {
//   static a() {
//
//   }
// }
// const a = new Test()
// const  b = new Test()

// new Test().a()
// Test.a()
```

:::success
上述代码更新时，要对数据进行一下浅拷贝，否则设置对象发现对象地址并没有发生改变，写入内容会采用上一次的

:::



:::color2
+ 现在我们有了加菜-减菜的方法-也可以调用加入菜品，现在需要将数据进行逐一分配到底层的每个需求购物车的组件，这里我们可以采用Provide和Consume进行跨层组件传递

:::

 采用Provide和Consume来实现

:::info
在MTIndex中使用Provide

:::

```typescript
 @Provide
  userCart: FoodItem[] = store.getCarts() // 获取所有购物车数据
```

:::info
在MTCart中使用Consume

:::

```typescript
import { FoodItem } from '../models'
import MTCartItem from './MTCartItem'

@Component
struct MTCart {
  @Consume
  userCart: FoodItem[]
  build() {
    Column() {
      Column() {
        Row() {
          Text('购物车')
            .fontSize(12)
            .fontWeight(600)
          Text('清空购物车')
            .fontSize(12)
            .fontColor($r("app.color.search_font_color"))
        }
        .width('100%')
        .height(40)
        .justifyContent(FlexAlign.SpaceBetween)
        .border({ width: { bottom: 0.5 }, color: $r("app.color.left_back_color") })
        .margin({ bottom: 10 })
        .padding({ left: 15, right: 15 })

        List({ space: 30 }) {
          ForEach(this.userCart, (item: FoodItem) => {
            ListItem() {
              MTCartItem({ item  })
            }
          })
        }
        .divider({
          strokeWidth: 0.5,
          color: $r("app.color.left_back_color")
        })
        .padding({ left: 15, right: 15, bottom: 100 })
      }
      .backgroundColor($r("app.color.white"))
      .borderRadius({
        topLeft: 16,
        topRight: 16
      })
    }
    .height('100%')
    .width('100%')
    .justifyContent(FlexAlign.End)
    .backgroundColor('rgba(0,0,0,0.5)')
  }
}
export default MTCart
```

+ MTCartItem中使用item

```typescript
import { FoodItem } from '../models'

@Component
struct MTCartItem {
  item: FoodItem = new FoodItem()
  build() {
    Row() {
      Image(this.item.picture)
        .width(60)
        .aspectRatio(1)
        .borderRadius(8)
      Column({ space: 5 }) {
        Text(this.item.name)
          .fontSize(14)
          .textOverflow({
            overflow: TextOverflow.Ellipsis
          })
          .maxLines(2)
        Row() {
          Text() {
            Span('¥ ')
              .fontColor($r("app.color.font_main_color"))
              .fontSize(10)
            Span(this.item.price.toString())
              .fontColor($r("app.color.font_main_color"))
              .fontWeight(FontWeight.Bold)
          }
        }
        .justifyContent(FlexAlign.SpaceBetween)
        .width('100%')
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 10, right: 10 })
    }
    .alignItems(VerticalAlign.Top)
  }
}
export default MTCartItem
```

<h3 id="fGYyR">9.加菜和减菜按钮加入购物车</h3>
:::info
  1. 使用Consume接收所有购物车数据

2. 加菜减菜之后提醒父组件更新Provide数据
3. 父组件更新Provide数据
4. 根据数量显示减菜按钮和数量元素

:::

```typescript
import { FoodItem } from '../models'
import { CartStore } from '../utils'

@Preview
@Component
struct MTAddCut {
  @Consume
  userCart: FoodItem[]
  item: FoodItem = new FoodItem()
  getCount () {
    return this.userCart.find(item => item.id === this.item.id)?.count || 0

  }
  build() {
    Row({ space: 8 }) {
      Row() {
        Image($r('app.media.ic_screenshot_line'))
          .width(10)
          .aspectRatio(1)

      }.width(16)
      .aspectRatio(1)
      .justifyContent(FlexAlign.Center)
      .backgroundColor($r("app.color.white"))
      .borderRadius(4)
      .border({ width: 0.5 , color: $r("app.color.main_color")})
      .visibility(this.getCount() ? Visibility.Visible: Visibility.Hidden)
      .onClick(() => {
        CartStore.addCutCart("cut", this.item)
      })
      Text(this.getCount().toString()).fontSize(14)
        .visibility(this.getCount() ? Visibility.Visible: Visibility.Hidden)

      Row() {
        Image($r('app.media.ic_public_add_filled'))
          .width(10)
          .aspectRatio(1)

      }.width(16)
      .aspectRatio(1)
      .justifyContent(FlexAlign.Center)
      .backgroundColor($r("app.color.main_color"))
      .borderRadius(4)
      .onClick(() => {
        CartStore.addCutCart("add", this.item)
      })
    }
  }
}
export default MTAddCut
```

+ 给AddCutCart传入Item

```typescript
 MTAddCut({ item: this.item })
```

:::success
此时发现数据无响应，因为我们使用的api获取的，此时需要通知Provide更新数据

:::

```typescript
 getContext().eventHub.emit("changeChart")
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710758221581-b6cd09cf-d3a4-42c5-9a27-4aea6ca9181c.png)

+ 在MTIndex中监听

```typescript
aboutToAppear(): void {
    this.userCart = CartStore.getCarts()
    getContext().eventHub.on("changeChart", () => {
      this.userCart = CartStore.getCarts()
    })
  }
```

:::success
在MTCartItem中同样需要放置AddCutCart

:::

```typescript
  MTAddCut({ item: this.item })
```

:::success
解决在购物车中添加图片卡的问题

:::

```typescript
ForEach(this.userCart, (item: FoodItem) => {
            ListItem() {
              MTCartItem({ item  })
            }
          }, (item: FoodItem) => item.id.toString())
```

<h3 id="dd9b08eb">10.清空购物车</h3>
```typescript
 Text('清空购物车')
            .fontSize(12)
            .fontColor('#999')
            .onClick(() => {
              CartStore.clearCart()
            })
```

+ 清空方法

```typescript
 static clearCarts () {
    AppStorage.set<FoodItem[]>("user_cart", [])
    getContext().eventHub.emit("changeChart")
  }
```

<h3 id="cX7xn">11.底部内容汇总</h3>
![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702229997497-76135396-541f-4e70-b3d9-23d8f010ab57.png)



```typescript
import { FoodItem } from '../models'

@Component
struct MTBottom {
  @Consume
  showCart: boolean
  @Consume
  userCart: FoodItem[]
  getAllCount () {
    return this.userCart.reduce((preValue, item) => preValue + item.count, 0).toString()
  }
  getAllPrice () {
    return this.userCart.reduce((preValue, item) => preValue + item.count * item.price, 0).toFixed(2)
  }
  build() {
    Row() {
      Row() {
        Badge({
          value: this.getAllCount(),
          position: BadgePosition.Right,
          style: { badgeSize: 18 }
        }) {
          Image($r("app.media.ic_public_cart"))
            .width(47)
            .height(69)
            .position({ y: -19 })
        }
        .width(50)
        .height(50)
        .margin({ left: 25, right: 10 })
        .onClick(() => {
           this.showCart = !this.showCart
        })

        Column() {
          Text() {
            Span('¥')
              .fontColor('#fff')
              .fontSize(12)
            Span(this.getAllPrice())
              .fontColor('#fff')
              .fontSize(24)
          }

          Text('预估另需配送费 ¥5')
            .fontSize(12)
            .fontColor('#999')
        }
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Start)

        Text('去结算')
          .backgroundColor($r("app.color.main_color"))
          .alignSelf(ItemAlign.Stretch)
          .padding(15)
          .borderRadius({
            topRight: 25,
            bottomRight: 25
          })
      }
      .height(50)
      .width('100%')
      .backgroundColor($r("app.color.bottom_back"))
      .borderRadius(25)
    }
    .width('100%')
    .padding({ left: 20, right: 20, bottom: 20 })
  }
}
export default MTBottom
```



<h1 id="DemSd">美团案例完整代码</h1>
+ MTIndex.ets

```typescript
import MTBottom from './components/MTBottom'
import MTCart from './components/MTCart'
import MTMain from './components/MTMain'
import MTTop from './components/MTTop'
import { FoodItem } from './models'
import { CartStore } from './utils'

@Entry
@Component
struct MTIndex {
  @Provide showCart: boolean = false
  @Provide
  userCart: FoodItem[] = []
  aboutToAppear(): void {
    this.userCart = CartStore.getCarts()
    getContext().eventHub.on("changeChart", () => {
      this.userCart = CartStore.getCarts()
    })
  }
  build() {
    Column() {
      Stack({ alignContent: Alignment.Bottom }) {
        Column() {
          MTTop()
          MTMain()
        }
        .height("100%")
        if(this.showCart) {
          MTCart()
        }
        MTBottom()

      }.layoutWeight(1)

    }
    .width('100%')
    .height("100%")
    .backgroundColor($r("app.color.white"))
  }
}
```

+ components/MTTop.ets

```typescript
@Component
struct MTTop {
  @Builder
  NavItem(active: boolean, title: string, subTitle?: string) {
    Column() {
      Text() {
        Span(title)
        if (subTitle) {
          Span(' ' + subTitle)
            .fontSize(10)
            .fontColor(active ? $r("app.color.black") : $r("app.color.un_select_color"))
        }
      }.layoutWeight(1)
      .fontColor(active ? $r("app.color.black") : $r("app.color.un_select_color"))
      .fontWeight(active ? FontWeight.Bold : FontWeight.Normal)

      Text()
        .height(1)
        .width(20)
        .margin({ left: 6 })
        .backgroundColor(active ? $r("app.color.select_border_color") : 'transparent')
    }
    .width(73)
    .alignItems(HorizontalAlign.Start)
    .padding({ top: 3 })
  }
  build() {
    Row() {
      this.NavItem(true, '点菜')
      this.NavItem(false, '评价', '1796')
      this.NavItem(false, '商家')
      Row() {
        Image($r('app.media.ic_public_search'))
          .width(14)
          .aspectRatio(1)
          .fillColor($r("app.color.search_font_color"))
        Text('请输入菜品名称')
          .fontSize(12)
          .fontColor($r("app.color.search_font_color"))
      }
      .backgroundColor($r("app.color.search_back_color"))
      .height(25)
      .borderRadius(13)
      .padding({ left: 5, right: 5 })
      .layoutWeight(1)

    }
    .padding({ left: 15, right: 15 })
    .height(40)
    .border({ width: { bottom: 0.5 }, color: $r("app.color.top_border_color") })
  }
}

export default MTTop
```

+ components/MTMain.ets

```typescript
import { getAllData } from '../api'
import { Category, FoodItem } from '../models'
import MTFoodItem from './MTFoodItem'

@Component
struct MTMain {
  @State
  activeIndex: number = 0
  @State
  list: Category[] = []
  aboutToAppear(): void {
     this.getAllData()
  }
  async getAllData () {
   this.list = await getAllData()
  }
  build() {
    Row() {
      Column() {
        ForEach(this.list, (item: Category, index: number) => {
          Text(item.name)
            .height(50)
            .width('100%')
            .textAlign(TextAlign.Center)
            .fontSize(14)
            .backgroundColor(this.activeIndex === index ? $r("app.color.white") : $r("app.color.left_back_color"))
            .onClick(() => {
              this.activeIndex = index
            })
        })
      }
      .width(90)

      //   右侧内容
      List() {
        ForEach(this.list[this.activeIndex]?.foods || [], (item: FoodItem) => {
          ListItem() {
            MTFoodItem({ item })
          }
        })
      }.layoutWeight(1)
      .backgroundColor($r("app.color.white"))
      .padding({
        bottom: 80
      })
    }
    .layoutWeight(1)
    .alignItems(VerticalAlign.Top)
    .width('100%')
  }
}
export default MTMain
```

+ components/MTBottom.ets

```typescript
import { FoodItem } from '../models'

@Component
struct MTBottom {
  @Consume
  showCart: boolean
  @Consume
  userCart: FoodItem[]
  getAllCount () {
    return this.userCart.reduce((preValue, item) => preValue + item.count, 0).toString()
  }
  getAllPrice () {
    return this.userCart.reduce((preValue, item) => preValue + item.count * item.price, 0).toFixed(2)
  }
  build() {
    Row() {
      Row() {
        Badge({
          value: this.getAllCount(),
          position: BadgePosition.Right,
          style: { badgeSize: 18 }
        }) {
          Image($r("app.media.ic_public_cart"))
            .width(47)
            .height(69)
            .position({ y: -19 })
        }
        .width(50)
        .height(50)
        .margin({ left: 25, right: 10 })
        .onClick(() => {
           this.showCart = !this.showCart
        })

        Column() {
          Text() {
            Span('¥')
              .fontColor('#fff')
              .fontSize(12)
            Span(this.getAllPrice())
              .fontColor('#fff')
              .fontSize(24)
          }

          Text('预估另需配送费 ¥5')
            .fontSize(12)
            .fontColor('#999')
        }
        .layoutWeight(1)
        .alignItems(HorizontalAlign.Start)

        Text('去结算')
          .backgroundColor($r("app.color.main_color"))
          .alignSelf(ItemAlign.Stretch)
          .padding(15)
          .borderRadius({
            topRight: 25,
            bottomRight: 25
          })
      }
      .height(50)
      .width('100%')
      .backgroundColor($r("app.color.bottom_back"))
      .borderRadius(25)
    }
    .width('100%')
    .padding({ left: 20, right: 20, bottom: 20 })
  }
}
export default MTBottom
```

+ components/MTCart.ets

```typescript
import { FoodItem } from '../models'
import { CartStore } from '../utils'
import MTCartItem from './MTCartItem'

@Component
struct MTCart {
  @Consume
  userCart: FoodItem[]
  build() {
    Column() {
      Column() {
        Row() {
          Text('购物车')
            .fontSize(12)
            .fontWeight(600)
          Text('清空购物车')
            .fontSize(12)
            .fontColor($r("app.color.search_font_color"))
            .onClick(() => {
              CartStore.clearCarts()
            })
        }
        .width('100%')
        .height(40)
        .justifyContent(FlexAlign.SpaceBetween)
        .border({ width: { bottom: 0.5 }, color: $r("app.color.left_back_color") })
        .margin({ bottom: 10 })
        .padding({ left: 15, right: 15 })

        List({ space: 30 }) {
          ForEach(this.userCart, (item: FoodItem) => {
            ListItem() {
              MTCartItem({ item  })
            }
          }, (item: FoodItem) => item.id.toString())
        }
        .divider({
          strokeWidth: 0.5,
          color: $r("app.color.left_back_color")
        })
        .padding({ left: 15, right: 15, bottom: 100 })
      }
      .backgroundColor($r("app.color.white"))
      .borderRadius({
        topLeft: 16,
        topRight: 16
      })
    }
    .height('100%')
    .width('100%')
    .justifyContent(FlexAlign.End)
    .backgroundColor('rgba(0,0,0,0.5)')
  }
}
export default MTCart
```

+ components/MTFoodItem.ets

```typescript
import { FoodItem } from '../models'
import MTAddCut from './MTAddCut'

@Preview
@Component
struct MTFoodItem {
  item: FoodItem = new FoodItem()

  build() {
    Row() {
      Image(this.item.picture)
        .width(90)
        .aspectRatio(1)
      Column({ space: 5 }) {
        Text(this.item.name)
          .textOverflow({
            overflow: TextOverflow.Ellipsis,
          })
          .maxLines(2)
          .fontWeight(600)
        Text(this.item.description)
          .textOverflow({
            overflow: TextOverflow.Ellipsis,
          })
          .maxLines(1)
          .fontSize(12)
          .fontColor($r("app.color.food_item_second_color"))
        ForEach(this.item.food_tag_list, (tag: string) => {
          Text(tag)
            .fontSize(10)
            .backgroundColor($r("app.color.food_item_label_color"))
            .fontColor($r("app.color.font_main_color"))
            .padding({ top: 2, bottom: 2, right: 5, left: 5 })
            .borderRadius(2)
        })

        Text() {
          Span('月销售' + this.item.month_saled)
          Span(' ')
          Span(this.item.like_ratio_desc)
        }
        .fontSize(12)
        .fontColor($r("app.color.black"))

        Row() {
          Text() {
            Span('¥ ')
              .fontColor($r("app.color.font_main_color"))
              .fontSize(10)
            Span(this.item.price?.toString())
              .fontColor($r("app.color.font_main_color"))
              .fontWeight(FontWeight.Bold)
          }
          MTAddCut({ item: this.item })
        }
        .justifyContent(FlexAlign.SpaceBetween)
        .width('100%')
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 10, right: 10 })
    }
    .padding(10)
    .alignItems(VerticalAlign.Top)
  }
}

export default MTFoodItem
```

+ components/MTCartItem.ets

```typescript
import { FoodItem } from '../models'
import MTAddCut from './MTAddCut'

@Component
struct MTCartItem {
  item: FoodItem = new FoodItem()
  build() {
    Row() {
      Image(this.item.picture)
        .width(60)
        .aspectRatio(1)
        .borderRadius(8)
      Column({ space: 5 }) {
        Text(this.item.name)
          .fontSize(14)
          .textOverflow({
            overflow: TextOverflow.Ellipsis
          })
          .maxLines(2)
        Row() {
          Text() {
            Span('¥ ')
              .fontColor($r("app.color.font_main_color"))
              .fontSize(10)
            Span(this.item.price.toString())
              .fontColor($r("app.color.font_main_color"))
              .fontWeight(FontWeight.Bold)
          }
          MTAddCut({ item: this.item })
        }
        .justifyContent(FlexAlign.SpaceBetween)
        .width('100%')
      }
      .layoutWeight(1)
      .alignItems(HorizontalAlign.Start)
      .padding({ left: 10, right: 10 })
    }
    .alignItems(VerticalAlign.Top)
  }
}
export default MTCartItem
```

+ components/MTAddCut.ets

```typescript
import { FoodItem } from '../models'
import { CartStore } from '../utils'

@Preview
@Component
struct MTAddCut {
  @Consume
  userCart: FoodItem[]
  item: FoodItem = new FoodItem()
  getCount () {
    return this.userCart.find(item => item.id === this.item.id)?.count || 0
  }
  build() {
    Row({ space: 8 }) {
      Row() {
        Image($r('app.media.ic_screenshot_line'))
          .width(10)
          .aspectRatio(1)

      }.width(16)
      .aspectRatio(1)
      .justifyContent(FlexAlign.Center)
      .backgroundColor($r("app.color.white"))
      .borderRadius(4)
      .border({ width: 0.5 , color: $r("app.color.main_color")})
      .visibility(this.getCount() ? Visibility.Visible: Visibility.Hidden)
      .onClick(() => {
        CartStore.addCutCart("cut", this.item)
      })
      Text(this.getCount().toString()).fontSize(14)
        .visibility(this.getCount() ? Visibility.Visible: Visibility.Hidden)

      Row() {
        Image($r('app.media.ic_public_add_filled'))
          .width(10)
          .aspectRatio(1)

      }.width(16)
      .aspectRatio(1)
      .justifyContent(FlexAlign.Center)
      .backgroundColor($r("app.color.main_color"))
      .borderRadius(4)
      .onClick(() => {
        CartStore.addCutCart("add", this.item)
      })
    }
  }
}
export default MTAddCut
```

+ api/index.ets

```typescript
import { http } from '@kit.NetworkKit'
import { Category } from '../models'

export const  getAllData = async () => {
  const req = http.createHttp()
  const res = await  req.request(" https://zhousg.atomgit.net/harmonyos-next/takeaway.json")
  return JSON.parse(res.result as string) as Category[]
}
```

+ models/index.ets

```typescript
export class FoodItem {
  id: number = 0
  name: string = ""
  like_ratio_desc: string = ""
  food_tag_list: string[] = []
  price: number = 0
  picture: string = ""
  description: string = ""
  tag: string = ""
  month_saled: number = 0
  count: number = 0
}


export class Category {
  tag: string = ""
  name: string =""
  foods: FoodItem[] = []
}
```

+ utils/index.ets

```arkts
import { FoodItem } from '../models'

// 初始化持久化购物车
PersistentStorage.persistProp("user_cart", [])

export class CartStore {
  static getCarts  (): FoodItem[] {
    return  AppStorage.get('user_cart') || [] as FoodItem[]
  }
  static addCutCart (type: 'add' | 'cut', item: FoodItem) {
    const list = CartStore.getCarts()
    const f = list.find(f => f.id === item.id)
    if(type === 'add') {
      // +1
      if(f) {
        f.count++
      }else {
        item.count = 1
        list.unshift(item) // 加入
      }

    } else if(type === 'cut') {
      if(f && f.count > 0) {
        f.count--
        if(f.count === 0) {
          // 移除
          const index = list.findIndex(f => f.id === item.id)
          list.splice(index, 1) // 移除该元素
        }
      }
    }
    AppStorage.set<FoodItem[]>("user_cart", [...list])
    getContext().eventHub.emit("changeChart")
  }
  static clearCarts () {
    AppStorage.set<FoodItem[]>("user_cart", [])
    getContext().eventHub.emit("changeChart")
  }
}

```

 

