<h1 id="vcJDl">沉浸式导航+键盘避让</h1>
:::success
官方文档（有权限者可观看）： [https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects-0000001820435461](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-develop-apply-immersive-effects-0000001820435461)

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710904954993-32964c29-2cb8-4a88-8499-b5e645c03be0.png)     

:::success
<font style="color:rgba(0, 0, 0, 0.9);">安全区域是指页面的显示区域，默认不与系统设置的非安全区域比如状态栏、导航栏区域重叠，默认情况下开发者开发的界面都被布局在安全区域内。提供属性方法允许开发者设置组件绘制内容突破安全区域的限制，通过expandSafeArea属性支持组件不改变布局情况下扩展其绘制区域至安全区外，通过设置setKeyboardAvoidMode来配置虚拟键盘弹出时页面的避让模式。</font>

:::

:::success
正常情况下，手机屏幕上方和下方会保留一个定的安全区域，假如我们想要实现一个沉浸式的效果，如下图

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710905246307-bd1499f4-96ed-46fd-9294-09dceed99d28.png)

可实际的效果就是

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710905449740-3ff44552-22a9-4a2f-b565-e4cbc033e3d8.png)



:::success
怎么实现呢？

两种方案

1. 使用windowStage的设置全屏的方式
2. 使用组件的安全区域扩展的方式

:::

<h2 id="OTscb">使用windowStage来设置</h2>
:::success
window非前端window，鸿蒙中属于窗口管理对象，

:::

:::success
在ability中通过getMainWindow可以获取主窗体，然后通过得到的window对象设置全屏即可实现

:::

```typescript
windowStage.getMainWindow().then(window => {
      window.setWindowLayoutFullScreen(true)
})
```

:::color1
所有页面都会受到影响-不够灵活

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710906273751-71142636-3984-490e-b492-202130480ce4.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710906291430-64c0e1aa-f2e3-4df0-ae6d-4a007ad4b407.png)

:::success
通过这种方式最简单，但是相当于给所有的页面都设置了沉浸式，如果某些页面不需要设置沉浸式，还需要在页面中通过获取window来关闭

:::

+ 页面中关闭沉浸式

```typescript
 aboutToAppear(): void {
    window.getLastWindow(getContext())
      .then(win => {
        win.setWindowLayoutFullScreen(false)
      })
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710906410750-fe1a6884-c3db-4c09-aa47-32726e5c45f1.png)



:::success
还有个问题，如果想要获取安全区域的高度，然后在安全区域做些距离的拉开。

:::

:::success
获取安全区域的高度

getWindowAvoidArea(传入上或者下)

:::

```typescript
AlertDialog.show({
          message: px2vp(win.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM)
            .topRect.height).toString()
        })
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710906843620-314f382a-aefe-41b8-b868-5ea2ee1d4e92.png)

:::success
因为获取的安全区域的大小是px，所以需要用到vp的话 需要使用pxtovp的方法来实现

:::

+ 通过设置背景色统一沉浸式

:::success
当我们只是需要背景统一，实现状态栏-导航栏-主内容区的颜色统一，可以通过设置整体窗口的背景色来实现

视觉沉浸式

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710910049523-4eb7e497-b699-4c7e-ad56-74794bc39590.png)

```typescript
windowStage.loadContent('pages/03/Navgation', (err) => {
      // themeManager.enableFullScreen()

      if (err.code) {
        hilog.error(0x0000, 'testTag', 'Failed to load the content. Cause: %{public}s', JSON.stringify(err) ?? '');
        return;
      }
      windowStage.getMainWindowSync().setWindowBackgroundColor("#ffa269f1")

      hilog.info(0x0000, 'testTag', 'Succeeded in loading the content.');
    });
```

:::success
需要注意： 

需要在loadContent完成之后，再设置背景色

:::

<h2 id="FlY1s">安全区域expandSafeArea</h2>
:::success
文档地址(有权限才可看)： [https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area-0000001820880849#ZH-CN_TOPIC_0000001820880849__expandsafearea](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-universal-attributes-expand-safe-area-0000001820880849#ZH-CN_TOPIC_0000001820880849__expandsafearea)

:::

:::success
相对于上述通过window设置所有页面进行全局的设置，expandSafeArea是个按需的方式，哪个页面需要使用

沉浸式，直接自己设置即可。

+ 作用<font style="color:rgba(0, 0, 0, 0.9);">控制组件扩展其安全区域。</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723195982282-0fec670b-a8d3-4639-9fe0-0cb6f3ec81a3.png)

```arkts
@Entry
@Component
struct ExpandSafeAreaCase {
  @State message: string = 'Hello World';

  build() {
    Column() {
      Text("测试")
        .fontSize(60)
        .fontColor(Color.White)
    }
    .height('100%')
    .width('100%')
    .backgroundColor(Color.Brown)
    .expandSafeArea() // 可以不传参数
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723196049539-154fb66a-8655-440d-a544-55325cc6f4e2.png)

<h2 id="mwgrS">键盘避让模式</h2>
:::success
当我们存在输入框的页面，如果点击输入框，此时就会弹出键盘，此时键盘的弹出会出问题，如下图

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710910519019-e75c5829-81b8-486e-beec-81529aa155e1.png)

```typescript
@Entry
@Component
struct WeChatPage {
  @State message: string = 'Hello World';

  build() {
    RelativeContainer() {
      Row() {
        Text("顶部内容")
          .fontColor(Color.White)
      }
      .justifyContent(FlexAlign.Center)
      .height(50)
      .width("100%")
      .backgroundColor(Color.Grey)
      .id("row1")

      List() {

      }
      // .height("calc(100% - 100vp)")
      .alignRules({
        top: {
          anchor: 'row1',
          align: VerticalAlign.Bottom
        },
        bottom: {
          anchor: 'row2',
          align: VerticalAlign.Top
        }
      })
      .backgroundColor(Color.Pink)
      .width("100%")

      Row() {
        TextInput({
          placeholder: '和我聊聊天吧～'
        })
      }
      .justifyContent(FlexAlign.Center)
      .height(50)
      .width("100%")
      .backgroundColor(Color.Grey)
      .id("row2")
      .alignRules({
        bottom: {
          anchor: '__container__',
          align: VerticalAlign.Bottom
        }
      })
    }
    .height('100%')
    .width('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710910664431-a84f98e0-090f-4dde-b3f8-12aa370310f6.png)



:::success
我们可以设置键盘的避让模式，让窗口被键盘压缩，默认情况下，窗口和键盘的情况是这样的

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710912591244-f869aca4-8988-4a63-8b7a-a8ef1e6a5100.png)

设置为压缩就变成

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710912634769-9d4b927d-1f87-4775-b6f4-2bc0e598cc5e.png)

:::

+ 设置方式

```typescript
import { KeyboardAvoidMode } from '@kit.ArkUI';

@Entry
@Component
struct WeChatPage {
  @State message: string = 'Hello World';

  aboutToAppear(): void {

  }

  build() {
    RelativeContainer() {
      Row() {
        Text("顶部内容")
          .fontColor(Color.White)
      }
      .justifyContent(FlexAlign.Center)
      .height(50)
      .width("100%")
      .backgroundColor(Color.Grey)
      .id("row1")

      List({ space: 10 }) {
        ListItem() {
          Button("正常模式")
            .onClick(() => {
              this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.OFFSET)
            })
        }

        ListItem() {
          Button("压缩模式")
            .onClick(() => {
              this.getUIContext().setKeyboardAvoidMode(KeyboardAvoidMode.RESIZE)
            })
        }

      }
      // .height("calc(100% - 100vp)")
      .alignRules({
        top: {
          anchor: 'row1',
          align: VerticalAlign.Bottom
        },
        bottom: {
          anchor: 'row2',
          align: VerticalAlign.Top
        }
      })
      .backgroundColor(Color.Pink)
      .width("100%")

      Row() {
        TextInput({
          placeholder: '和我聊聊天吧～'
        })
      }
      .justifyContent(FlexAlign.Center)
      .height(50)
      .width("100%")
      .backgroundColor(Color.Grey)
      .id("row2")
      .alignRules({
        bottom: {
          anchor: '__container__',
          align: VerticalAlign.Bottom
        }
      })
    }
    .height('100%')
    .width('100%')
    .onAreaChange(() => {

    })
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1725699112932-68688029-56a5-4f22-aab5-550aac870225.png)

<h1 id="dbc4f724">路由控制</h1>
:::success
路由控制有多种方式来实现

官方说明-

+ **router方式-更适用****<font style="color:rgba(0, 0, 0, 0.9);">用于</font>**[**模块**](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/application-package-structure-stage-0000001774279566)**<font style="color:rgba(0, 0, 0, 0.9);">间与模块内页面切换，通过每个页面的url实现模块间解耦</font>**
+ **Naviagtion-****<font style="color:rgba(0, 0, 0, 0.9);">模块内页面跳转时，为了实现更好的转场动效场景不建议使用router该模块，推荐使用</font>**[**Navigation**](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-navigation-navigation-0000001774120150)**<font style="color:rgba(0, 0, 0, 0.9);">。</font>**

:::

:::success
项目中实际还是适用router更较为简单和合理

Navigation的方式更适合简单页面的方式

:::

<h2 id="LPxVy">Navigtion的使用</h2>
:::success
<font style="color:rgba(0, 0, 0, 0.9);">Navigation组件是路由导航的根视图容器，一般作为Page页面的根容器使用，其内部默认包含了标题栏、内容区和工具栏，其中内容区默认首页显示导航内容（Navigation的子组件）或非首页显示（</font>[NavDestination](https://developer.huawei.com/consumer/cn/doc/harmonyos-references/ts-basic-components-navdestination-0000001774280918)<font style="color:rgba(0, 0, 0, 0.9);">的子组件），首页和非首页通过路由进行切换。</font>

:::

:::success
使用Navigation跳转的组件不需要再使用Entry来修饰，普通组件即可

:::

+ 用法

:::success
使用Navigation在不同设备中会得到不同的视觉体验

:::

**api11- Navigation-NavPathStack(支持逻辑跳转)**

:::color1
+ 最外层Navigation
+ 有一个控制跳转的对象NavPathStack(需要new)
+ 绑定到Navgation上面
+ 需要传导到下方的每一层组件，使用这个对象进行跳转和替换
+ 子组件(页面)放置到NavDestintion中
+ Navigation组件需要配置.navDestion属性（builder）

:::

```typescript
import { promptAction, PromptAction } from '@kit.ArkUI'

@Entry
@Component
struct NavigationCase2 {
  @Provide
  stackPath: NavPathStack = new NavPathStack() // 声明一个pathStack对象

  @Styles
  gridStyle () {
    .height(100)
    .borderRadius(10)
    .backgroundColor(Color.Red)
    .margin(10)

  }
  @Builder
  getPageContent (name: string) {

      if(name === "friend") {
        // 渲染朋友圈组件
        Friend()
      }
      else if(name === "my") {
        // 渲染朋友圈组件
        My()
      }
      else if(name === "connect") {
        // 渲染朋友圈组件
        Connect()
      }
      else if(name === "chat") {
        // 渲染朋友圈组件
        Chat()
      }

  }
  build() {
    // 绑定关系
    Navigation(this.stackPath) {
    //  四个导航 导航不同的页面
      // 朋友圈 我的 联系人 聊天
      GridRow ({ columns: 2 }) {
        GridCol() {
          Text("朋友圈")
            .fontColor(Color.White)
        }
        .gridStyle()
        .onClick(() => {
          // this.stackPath.pushPath({
          //   name: 'friend'
          // })
         this.stackPath.pushPathByName("friend", null)
        })
        GridCol() {
          Text("我的")
            .fontColor(Color.White)
        }  .gridStyle()
        .onClick(() => {
          this.stackPath.pushPathByName("my", null)
        })
        GridCol() {
          Text("联系人")
            .fontColor(Color.White)
        }  .gridStyle()
        .onClick(() => {
          this.stackPath.pushPathByName("connect", null)
        })
        GridCol() {
          Text("聊天")
            .fontColor(Color.White)
        }  .gridStyle()
        .onClick(() => {
          this.stackPath.pushPathByName("chat", null)
        })
      }
    }
    .title("微信主页")
    .titleMode(NavigationTitleMode.Mini)
    .navDestination(this.getPageContent)
  }
}

@Component
struct Friend {
  @Consume
  stackPath: NavPathStack
  build() {
    NavDestination() {
      Text("朋友圈组件")
      Button("到我的").onClick((event: ClickEvent) => {
         // this.stackPath.pushPathByName("my", null)
        this.stackPath.replacePathByName("my", null)
      })
    }
    .title("朋友圈")
  }
}
@Component
struct My {
  build() {
    NavDestination() {
      Text("我的")
    }
    .title("我的")
  }
}
@Component
struct Connect {
  build() {
    NavDestination() {
      Text("联系人")
    }
    .title("联系人")
  }
}
@Component
struct Chat {
  build() {
    NavDestination() {
      Text("聊天")
    }
    .title("聊天")
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711177427845-88eb59a3-d7be-4d32-a6ad-05d9cc73102c.png)



:::success
Navigation的这种跳转方式耦合度较高，不适合大型的项目解耦开发。

后续可以作为入口页的应用

:::



+ 做一个案例

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723275660048-2a35f2e2-0344-4e7b-b961-908facf4ef17.png)

:::color1
使用Navigation组件

:::

```arkts
import { RouterBuilder } from './builders'

@Entry
@Component
struct NavigationPathCase {
  @Provide
  stackPath: NavPathStack = new NavPathStack() // 实例化一个对象绑定到Navigation
  @State
  list: WeChatItem[] = [{
    title: '朋友圈',
    icon: $r("sys.media.ohos_ic_public_arrow_right"),
    isDivider: true,
    toName: 'friend'
  },
    {
      title: '视频号',
      icon: $r("sys.media.ohos_ic_public_arrow_right"),
      toName: 'video'
    }, {
      title: '直播',
      icon: $r("sys.media.ohos_ic_public_arrow_right"),
      isDivider: true,
      toName: 'live'
    }
    , {
      title: '扫一扫',
      icon: $r("sys.media.ohos_ic_public_arrow_right"),
      toName: 'scan'
    }, {
      title: '听一听',
      icon: $r("sys.media.ohos_ic_public_arrow_right"),
      isDivider: true,
      toName: 'listen'
    }
    , {
      title: '看一看',
      icon: $r("sys.media.ohos_ic_public_arrow_right"),
      toName: 'look'
    }, {
      title: '搜一搜',
      icon: $r("sys.media.ohos_ic_public_arrow_right"),
      isDivider: true,
      toName: 'search'
    }]

  @Builder
  getNavBarMenu() {
    Column() {
      ForEach(this.list, (item: WeChatItem) => {
        Row() {
          Text(item.title)
          Image(item.icon)
            .width(30)
            .aspectRatio(1)
            .fillColor("#c6c6c6")
        }
        .padding({
          left: 20,
          right: 20
        })
        .margin({
          bottom: item.isDivider ? 10 : 0
        })
        .border({
          color: "#eaeaea",
          width: {
            bottom: 1
          }
        })
        .onClick(() => {
          // 完成跳转
          this.stackPath.pushPathByName(item.toName, null)
          // item.toName
        })
        // .stateStyles({
        //   normal: {
        //     .backgroundColor(Color.White)
        //   },
        //   pressed: {
        //     .backgroundColor(Color.Blue)
        //   }
        // })
        .height(50)
        .backgroundColor(Color.White)
        .width("100%")
        .justifyContent(FlexAlign.SpaceBetween)
      })
    }
    .width("100%")
  }

  build() {
    Navigation(this.stackPath) {
      this.getNavBarMenu() // 获取导航结构

    }
    .title("")
    .titleMode(NavigationTitleMode.Mini)
    .height('100%')
    .width('100%')
    .backgroundColor("#eaeaea")
    .navDestination(RouterBuilder)
  }
}

class WeChatItem {
  title: string = ""
  icon: ResourceStr = ""
  isDivider?: boolean
  toName?: string
}
```

+ 实现公共的router

```arkts
import Friend from '../components/Friend'
import Listen from '../components/Listen'
import Live from '../components/SearchPage'
import LivePage from '../components/LivePage'
import Look from '../components/Look'
import Scan from '../components/Scan'
import VideoPage from '../components/VideoPage'
import SearchPage from '../components/SearchPage'

@Builder
export function RouterBuilder(name: string) {
  if (name === "friend") {
    Friend()
  } else if (name === "live") {
    LivePage()
  } else if (name === "video") {
    VideoPage()
  } else if (name === "look") {
    Look()
  } else if (name === "search") {
    SearchPage()
  } else if (name === "listen") {
    Listen()
  } else if (name === "scan") {
    Scan()
  }

}
```

+ 其中一个Friend组件的示例

```arkts
import { CommonParams } from '../viewmodels'

@Component
struct Friend {
  @Consume
  stackPath: NavPathStack

  build() {
    NavDestination() {
      Text("朋友圈")
      Button("去搜一搜")
        .onClick(() => {
          let params: CommonParams = {
            id: 1,
            name: '张三'
          }
          this.stackPath.pushPath({
            name: 'search',
            param: params
          })
          // this.stackPath.replacePath({
          //   name: 'search'
          // })
        })
    }
    .onWillAppear(() => {
      console.log("friend_onWillAppear")
    })
    .onAppear(() => {
      console.log("friend_onAppear")
    })
    .onWillShow(() => {
      console.log("friend_onWillShow")
    })
    .onShown(() => {
      console.log("friend_onShown")
    })
    .onWillHide(() => {
      console.log("friend_onWillHide")
    })
    .onHidden(() => {
      console.log("friend_onHidden")
    })
    .onWillDisappear(() => {
      console.log("friend_onWillDisappear")
    })
    .onDisAppear(() => {
      console.log("friend_onDisAppear")
    })
    .title("朋友圈")
  }
}

export default Friend
```

+ search接收参数的示例

```arkts
import { CommonParams } from '../viewmodels'

@Component
struct SearchPage {
  @Consume
  stackPath: NavPathStack

  aboutToAppear(): void {
    const params = this.stackPath.getParamByName("search") as CommonParams[]
    AlertDialog.show({
      message: JSON.stringify(params[0].name)
    })
  }

  build() {
    NavDestination() {
      Text("搜索")
      Button("返回")
        .onClick(() => {
          this.stackPath.pop() // 返回
        })
    }
    .title("搜索")
  }
}

export default SearchPage
```



<h2 id="LA2Tk">router的使用</h2>
:::success
router的使用都是基于Entry修饰的组件

都是基于resources/base/profile/main-page.json中的路由配置来跳转的

:::

:::success
router提供下列的几个方法

+ <font style="color:rgba(0, 0, 0, 0.9);">pushUrl -压栈</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">replaceUrl-替换页面栈</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">back-返回</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">clear-清空之前页面栈</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">getParams-获取参数</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">getState-获取当前路由状态</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">getLength-获取当前所有的路由长度</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">单例模式</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">showAlertBeforeBackPage- （返回阻断）</font>

:::

+ pushUrl

:::success
pushUrl会在当前页面层级再加一层页面，不管是不是同一个页面，

A -> B   相当于当前页面栈中存在两个页面 A和B

鸿蒙系统最多页面栈为32

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710917670158-a6b449cd-c12b-4754-af20-b320ee630ace.png)

:::

```typescript
 Button("push跳转")
        .onClick(() => {
          router.pushUrl({
            url: 'pages/03/RouterCase'
          })
        })
```

:::success
注意跳转的页面必须是Entry修饰的页面

:::

+ replaceUrl

:::success
+ replaceUrl会替换当前页面，不管是不是同一个页面，替换之后相当于页面重新执行

:::

```typescript
 Button("replace跳转")
        .onClick(() => {
          router.replaceUrl({
            url: 'pages/03/RouterCase'
          })
        })
```

+ clear

:::success
<font style="color:rgba(0, 0, 0, 0.9);">清空页面栈中的所有历史页面，仅保留当前页面作为栈顶页面。</font>

:::

```typescript
router.clear()
```

+ back

:::success
回到上一个页面- 回到上一个页面，上一个页面并不会重新初始化

:::

```typescript
 router.back()
```

+ getParams

:::success
在跳转过程中，可以给指定页面传递参数，在pushUrl和replaceUrl的第二个参数

back也可以传参数

:::

```typescript
 Button("push跳转")
        .onClick(() => {
          router.pushUrl({
            url: 'pages/03/RouterCase02',
            params: {
              id: 1
            }
          })
        })
```

+ 在接收页面通过getParams接收参数

```typescript
  AlertDialog.show({ message:  (router.getParams() as Params).id?.toString() })

```

:::success
值得注意的是所有的参数 不论传入和传出都是object，我们需要将其断言成我们想要的类型

:::

+ getState

:::success
<font style="color:rgba(0, 0, 0, 0.9);">获取当前页面的状态信息。</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710918203924-38b25f0a-8ac4-4d4d-a6d9-eb6550f3f59b.png)

```typescript
 AlertDialog.show({
      message: JSON.stringify(router.getState())
    })
```

+ getLength

:::success
获取当前页面栈的数量

:::

```typescript
 AlertDialog.show({
      message: JSON.stringify(router.getLength())
    })
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710919882179-e8f34a93-e41a-445b-9609-fdb5ed20bbdc.png)

+ 单例模式

:::success
路由默认属于标准模式

push就是一直追加，不管你有没有加载这个页面

单例模式

比如你加载过A 在栈底放着 再去追加时 会把页面从栈底拿出 放到栈顶

:::

+ 单例模式不会造成线程的浪费

:::success
假设 A-B-C 现在C现在要回到A，此时用push会变成 A-B-C-A, 用replace会变成A-B-A, 可以给pushUrl加上单例模式, 变成 B-C-A, 或者直接用replace变成 B-A, 或者跳转后clear变成 A

:::

```typescript
 router.pushUrl({
              url: 'pages/03/RouterCase'
            }, router.RouterMode.Single)
```

+ showAlertBeforeBackPage

```typescript
 router.showAlertBeforeBackPage({
        message: '确定要退出吗'
      })
```

:::success
该方法只需要在返回之前执行一下即可

+ 不能获取点击了确定还是取消，由它本身进行处理

:::

<h2 id="Gksnv">模块间跳转</h2>
:::success
一个项目可能会有很多模块，假如A模块要跳转B模块的一个页面，该怎么跳转

:::

:::success
包的分类 

+ hap- 可以有ability，可以有页面，可以有组件，可以有资源
+ hsp- 共享包- 可以实现按需打包
+ har- 静态资源包- 可以实现资源共享

.app 上架包

如果是性能优先 建议使用har包

如果是体积优先 建议使用hsp包

:::



+ 新建一个共享包

:::success
说明

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710920523032-89d11b7d-423b-4c95-86bc-21c1690f6f22.png)

:::

:::success
（har包可以新建page页面-但是不能用！！！）

hap包同entry一样，此时我们要建一个share共享包即最终会生成hsp

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710920993114-cbc9bb5a-1104-4f11-a3e2-0d9a26c3df43.png)

<h3 id="SuAqv">使用地址跳转</h3>
![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710921141825-378925bb-a74c-45c0-938d-0e1537c9e3e6.png)

```typescript
 router.pushUrl({
            url: '@bundle:com.itheima.studu_case/library/ets/pages/Index'
          })
```

:::success
@bundle:包名/模块名/ets/pages/xxx

跳转方式

注意：

   **此时需要使用模拟器，并且需要部署你要跳转的hsp包才可以**

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710921519730-b3964201-c92e-436e-96ac-ad9e2137d99e.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1710921538735-b1fda973-6fdf-4953-8351-b2e331b4a113.png)

:::

<h3 id="bwz3z">使用路径name跳转(较麻烦)</h3>
+ <font style="color:rgba(0, 0, 0, 0.9);">在想要跳转到的共享包页面里，给</font>[@Entry修饰的自定义组件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/arkts-create-custom-components-0000001820999549#ZH-CN_TOPIC_0000001820999549__entryoptions10)<font style="color:rgba(0, 0, 0, 0.9);">命名：</font>

```typescript
@Entry({ routeName: 'hsp_share_index' })
```

+ <font style="color:rgba(0, 0, 0, 0.9);">配置成功后需要在跳转的页面中引入命名路由的页面：</font>

```typescript
import("@ohos/demo/src/main/ets/pages/Index");

```

+ 同时需要在当前包引入对于share包的依赖oh-package.json5

```typescript
"dependencies": {
    "@ohos/demo": "file:../library"
  }
```

+ 跳转共享包

```typescript
 Button("跳共享包-name模式")
        .onClick(() => {
          router.pushNamedRoute({
            name: 'hsp_share_index'
          })
        })
```



:::success
这种操作只适合从hap包 -> hsp一次性的跳转，假设有很多个页面都需要这么跳转，还是采用router

否则太过麻烦

:::





<h1 id="176808a1">生命周期</h1>
:::color1
NavDestination生命周期

+ onWillAppear
+ onAppear
+ onWillShow
+ onShown
+ onWillHide
+ onHidden
+ onWillDisappear
+ onDisAppear
+ onBackPress

:::

<h3 id="7456922d">1. 组件-生命周期</h3>
[生命周期-官网链接](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/arkts-page-custom-components-lifecycle-0000001524296665-V3)

+ <font style="color:rgb(36, 39, 40);">自定义组件：@Component装饰的UI单元，可以组合多个系统组件实现UI的复用。</font>
+ <font style="color:rgb(36, 39, 40);">页面：即应用的UI页面。可以由一个或者多个自定义组件组成，@Entry装饰的自定义组件为页面的入口组件，即页面的根节点，一个页面有且仅能有一个@Entry。只有被@Entry装饰的组件才可以调用页面的生命周期。</font>

<font style="color:rgb(36, 39, 40);">带@Entry修饰符的组件</font>

:::info
<font style="color:rgba(0, 0, 0, 0.9);">页面生命周期，即被@Entry装饰的组件生命周期，提供以下生命周期接口：</font>

+ [onPageShow](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-custom-component-lifecycle-0000001482395076-V3#ZH-CN_TOPIC_0000001523488850__onpageshow)<font style="color:rgb(36, 39, 40);">：页面每次显示时触发。</font>
+ [onPageHide](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-custom-component-lifecycle-0000001482395076-V3#ZH-CN_TOPIC_0000001523488850__onpagehide)<font style="color:rgb(36, 39, 40);">：页面每次隐藏时触发一次。</font>
+ [onBackPress](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-custom-component-lifecycle-0000001482395076-V3#ZH-CN_TOPIC_0000001523488850__onbackpress)<font style="color:rgb(36, 39, 40);">：当用户点击返回按钮时触发。</font>

:::

自定义组件生命周期

:::info
<font style="color:rgba(0, 0, 0, 0.9);">组件生命周期，即一般用@Component装饰的自定义组件的生命周期，提供以下生命周期接口：</font>

+ [aboutToAppear](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-custom-component-lifecycle-0000001482395076-V3#ZH-CN_TOPIC_0000001523488850__abouttoappear)<font style="color:rgb(36, 39, 40);">：组件即将出现时回调该接口，具体时机为在创建自定义组件的新实例后，在执行其build()函数之前执行。</font>
+ [aboutToDisappear](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/arkts-custom-component-lifecycle-0000001482395076-V3#ZH-CN_TOPIC_0000001523488850__abouttodisappear)<font style="color:rgb(36, 39, 40);">：在自定义组件即将析构销毁时执行。</font>

:::



因为@Entry 也是@Component组件，所以页面组件同时拥有自定义组件的生命周期

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1701409227572-91af8efa-dc38-4759-8418-6b75345678dc.png)

:::color1
修饰符Reusable, 复用组件的情况多一个

aboutToReuse => 当我们的组件被Reusable修饰符修饰的时候，组件被复用的时候，会触发该逻辑

一般在这里面取到原有参数，根据自身的业务对数据进行重置

:::



:::color1
abouteToAppear => build => onPageShow 

onPageHide => aboutToDisappear

:::

+ **所有的系统组件都有onAppear和onDisAppear事件**
+ **所有的自定义组件都有aboutToAppear 和aboutToDisappear**



在hmlist中测试一下

```typescript
aboutToAppear() {
    console.log("页面初始化")
  }
  onPageShow() {
    console.log("页面显示")
  }
  onPageHide() {
    console.log("页面隐藏")
  }
  aboutToDisAppear() {
    // 清理定时器
    console.log("页面销毁")
  }
  onBackPress() {
    console.log("后退键")
  }
```

:::success
更多的逻辑会在aboutToAppear中做数据加载

onPageShow也可以做数据加载 分场景

生活场景下- 送菜送外卖的网约车 具有时效性的业务 需要在onPageShow

偏固定性场景获取一次数据就行

aboutToDisAppear

  清理定时任务 。清理监听-线程监听-进程监听

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1701410018737-392ee2ee-8abc-42a4-b643-f783f701f5cc.png)



:::info
+ 带@Entry的页面组件 拥有页面进入，页面销毁，页面显示，页面隐藏， 页面返回的生命周期
+ @Component自定义组件 拥有 组件进入、组件销毁生命周期

:::

+ 在返回页面中，可以进行处理控制是否返回

:::success
在onBackPress中

return true 表示阻止返回 => 用户想要自己控制返回

return false 表示允许返回 => 使用系统的返回

:::

+ 在返回时控制返回

```typescript
 onBackPress() {
    promptAction.showDialog({
      message: '确定要退出吗',
      buttons: [{
        text: '取消',
        color: "black"
      },{
        text: '确定',
        color: "black"
      }],
    })
    .then((result) => {
      if(result.index === 1) {
        router.back()
      }

    })
    return true
  }
```

:::success
因为没有办法在生命周期中实现async和await，所以先手动让页面不返回，然后再确定是否要返回，如果确定要返回，就用router.back来实现

:::



<h3 id="20856d5c">2. UIAbility-生命周期</h3>
[UIAbility-生命周期](https://developer.harmonyos.com/cn/docs/documentation/doc-guides-V3/uiability-lifecycle-0000001427902208-V3)

<font style="color:rgba(0, 0, 0, 0.9);">UIAbility的生命周期包括Create、Foreground、Background、Destroy四个状态，如下图所示。</font>



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1701410657084-aa91e896-ac32-4ced-828d-0110cb8b94bd.png)

+ onCreate（实例创建）

> <font style="color:rgba(0, 0, 0, 0.9);">Ability创建时回调，执行初始化业务逻辑操作。</font>
>

+ onDestory

> <font style="color:rgba(0, 0, 0, 0.9);">Ability生命周期回调，在销毁时回调，执行资源清理等操作。</font>
>

+ onWindowStageCreate

> <font style="color:rgba(0, 0, 0, 0.9);">当WindowStage创建后调用。</font>
>

+ onWindowStageDestory

> <font style="color:rgba(0, 0, 0, 0.9);">当WindowStage销毁后调用。</font>
>

+ onForeground

> <font style="color:rgba(0, 0, 0, 0.9);">Ability生命周期回调，当应用从后台转到前台时触发。</font>
>

+ onBackground

> <font style="color:rgba(0, 0, 0, 0.9);">Ability生命周期回调，当应用从前台转到后台时触发</font>
>

+ onNewWant（会在打开一个新的任务窗口，但是该任务窗口已经存在的情况下）/
+ 单例模式下会执行onNewWant，多例模式

:::info
UIAbility相当于我们应用中的一个任务，我们可以把自己的app想象成一个UIAbility，但是当项目越来越大，

需要扩展和分担业务的时候，可以采取多个

:::

<h3 id="d65af914">3. Ability跳转</h3>
:::success
多个的abiltiy必须建立在hap中

hsp和har均不让建ability

:::

:::color1
Stage模型-~~FA模型~~

+ 模块-hap-hsp -har
+ UIAbility- 项目中默认有一个- 任务窗口-绘制页面
+ Page
+ Component

比如微信- 聊天-支付

:::

:::color1
+ UIAbility组件是系统调度的基本单元，为应用提供绘制界面的窗口；
+ 一个UIAbility组件中可以通过多个页面来实现一个功能模块；
+ 每一个UIAbility组件实例，都对应于一个最近任务列表中的任务。

当我们项目中拆解多个任务的时候，可以通过新建多个Ability的方式来进行任务的拆解

+ 比如，我们支付的之后想新开一个任务去专门处理这件事，就可以采用拉起一个新的Ability来实现

:::

+ 新建一个支付Ablility - PayAbility

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702270060986-3d978177-d64a-4d5f-94e2-abfb5c51480c.png)

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702270103989-fc65a4dd-b6d9-4186-a8f3-31158b2f51bd.png)



+ 新建PayAbility对应的跳转的支付页面 PayIndex.ets

```typescript
@Entry
@Component
struct PayIndex {

  build() {
    Row() {
      Column({ space: 15 }) {
        Text("支付Ability")
          .fontSize(40)
          .fontColor(Color.Red)
        Button("支付")
          .width('100%')
      }

    }
    .height('100%')
    .padding(20)
  }
}
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702270553331-9592ecce-946c-454f-82c4-da910c036910.png)

+ 新建一个主页Page- MainPage用来跳转到支付Ability

```typescript
@Entry
@Component
struct MainPage {

  build() {
    Row() {
      Column({ space: 15 }){
        Text("主Ability")
          .fontSize(50)
        Button("去支付")
          .width('100%')
      }

    }
    .height('100%')
    .padding(20)
  }
}
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702270498774-37c354ad-a8ea-4e09-bf42-a544f744f58b.png)



:::info
+ ability的拉起必须通过模拟器-所以把我们主Ability的启动页设置为我们刚刚新建的主页

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702270634016-8783d6ff-68e1-4604-8f73-7d9f2b748093.png)

:::

:::info
接下来，我们点击去支付按钮的时候 要拉起支付PayAbility

我们采用当前Ability的上下文来实现，使用文档[链接](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-application-want-0000001544464089-V3)

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702272485534-8f5a3914-eb29-48ad-99a6-6bd24cfe4cec.png)

:::

+ 使用Context上下文拉起Ability

:::info
这里我们需要准备一个参数[Want](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/js-apis-application-want-0000001544464089-V3)

:::

```typescript
let want: Want = {
      'deviceId': '', // deviceId为空表示本设备
      'bundleName': '包名',
      'abilityName': 'abilityName',
  };
```

+ 拉起Ability

```typescript
 let want: Want = {
              'deviceId': '', // deviceId为空表示本设备
              'bundleName': 'com.itheima.studu_case',
              'abilityName': 'PayAbility',
            };
            (getContext() as common.UIAbilityContext)
              .startAbility(want)
```



:::success
假设我们想调用第三方的包可不可以？

回答： 当然可以，我们只需要知道第三方的包名即可

:::



:::color2
接下来，我们需要传递参数了

+ 我们需要拉起Ability的时候，传过去一个订单id，让支付能够拿到这个id进行支付相关的事宜
+ 传参使用parameters，它是一个object类型，你可以传递你想传的任意数据

:::

+ Ablility传参数

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703172729370-0af38b42-0c56-4e2e-865f-3b261ab52a42.png)

+ 在HeimaPay中的HeimaPayAbility使用AppStorage进行接收并设置

```typescript
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    AppStorage.setOrCreate<number>("order_id", want.parameters!["order_id"] as number)
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
  }
  onNewWant(want: Want) {
    const params =  want.parameters as AbilityParams
    AppStorage.Set<number>("order_id", params.order_id)

  }
```

:::info
onNewWant表示当前的PayAbility并未销毁的情况下 会调用

:::

+ 在PayIndex中使用StoreageProp接受

```typescript
  @StorageProp('order_id')
  orderId: number = 0
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703173050421-68238d32-de62-4e2c-b13a-7095691017a8.png)



+ 执行完副Ability并返回结果

```typescript
  Button("支付")
          .width('100%')
          .onClick(() => {
            const context =  getContext(this) as common.UIAbilityContext
            context.terminateSelfWithResult({
              resultCode: 1,
              want: {
                abilityName: 'EntryAbility',
                bundleName: 'com.itheima.harmonybase',
                parameters: {
                  paySuccess: true
                }
              }
            })
          })
```

:::info
值得注意的是：如果我们想要获取副Ability对应的结果，在startAbility的时候需要使用**startAbilityForResult**来实现

:::



```typescript
 const result =  await (getContext(this) as common.UIAbilityContext).startAbilityForResult({
                'bundleName': 'com.itheima.harmonybase',
                'abilityName': 'PayAbility',
                parameters: {
                  order_id: Date.now()
                }
              })
              AlertDialog.show({
                message: JSON.stringify(result)
              })
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702273468751-aed67064-9a6d-4964-b9b0-26e122f848c7.png)

:::info
我们可以根据支付结果进行数据和业务的处理

如

:::



:::color2
定义返回参数的类型

:::

```typescript
type ResultParams = Record<string, boolean>

```

+ 接收Ability的返回结果

```typescript
type ResultParams = Record<string, boolean>
const result =  await (getContext(this) as common.UIAbilityContext).startAbilityForResult({
                'bundleName': 'com.itheima.harmonybase',
                'abilityName': 'PayAbility',
                parameters: {
                  order_id: Date.now()
                }
              })
              const params =  result.want?.parameters as ResultParams

              if(params.paySuccess) {
                promptAction.showToast({ message: '支付成功' })
              }else {
                promptAction.showToast({ message: '支付失败' })
              }
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702273568670-0364e48b-8471-4069-8f1e-4868c046480b.png)



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703245956353-f9b95821-1a6a-4aab-9075-09be77907fcf.png)

<h1 id="398e6d4e">使用动画</h1>
<h3 id="o1d24">1. 属性动画</h3>
:::success
<font style="color:rgba(0, 0, 0, 0.9);">属性接口（以下简称属性）包含尺寸属性、布局属性、位置属性等多种类型，用于控制组件的行为。针对当前界面上的组件，其部分属性（如位置属性）的变化会引起UI的变化。添加动画可以让属性值从起点逐渐变化到终点，从而产生连续的动画效果。根据变化时是否能够添加动画，可以将属性分为可动画属性和不可动画属性。</font>

:::

<font style="color:rgb(36, 39, 40);">可动画属性：</font>

+ <font style="color:rgb(36, 39, 40);">系统可动画属性：</font>

| **<font style="color:rgb(36, 39, 40);">分类</font>** | **<font style="color:rgb(36, 39, 40);">说明</font>** |
| :--- | :--- |
| <font style="color:rgb(36, 39, 40);">布局属性</font> | <font style="color:rgb(36, 39, 40);">位置、大小、内边距、外边距、对齐方式、权重等。</font> |
| <font style="color:rgb(36, 39, 40);">仿射变换</font> | <font style="color:rgb(36, 39, 40);">平移、旋转、缩放、锚点等。</font> |
| <font style="color:rgb(36, 39, 40);">背景</font> | <font style="color:rgb(36, 39, 40);">背景颜色、背景模糊等。</font> |
| <font style="color:rgb(36, 39, 40);">内容</font> | <font style="color:rgb(36, 39, 40);">文字大小、文字颜色，图片对齐方式、模糊等。</font> |
| <font style="color:rgb(36, 39, 40);">前景</font> | <font style="color:rgb(36, 39, 40);">前景颜色等。</font> |
| <font style="color:rgb(36, 39, 40);">Overlay</font> | <font style="color:rgb(36, 39, 40);">Overlay属性等。</font> |
| <font style="color:rgb(36, 39, 40);">外观</font> | <font style="color:rgb(36, 39, 40);">透明度、圆角、边框、阴影等。</font> |
| <font style="color:rgb(36, 39, 40);">...</font> | <font style="color:rgb(36, 39, 40);">...</font> |




:::success
属性动画的实现方式有两种

+ animation属性
+ <font style="color:rgba(0, 0, 0, 0.9);">animateTo闭包函数</font>

:::

+ 使用<font style="color:rgba(0, 0, 0, 0.9);">animateTo闭包函数</font>

:::success
animateTo(value: AnimateParam, event: () => void): void

原理

<font style="color:rgba(0, 0, 0, 0.9);">通用函数，对闭包前界面和闭包中的状态变量引起的界面之间的差异做动画。支持多次调用，支持嵌套。</font>

<font style="color:rgba(0, 0, 0, 0.9);">解释： 不论是组件的显示隐藏还是属性的变化，使用animateTo都可以实现动画</font>

:::

```typescript
@Entry
@Component
struct AnimationCase {
  @State
  rWidth: number = 100
  @State
  xPostion: number = 0
  @State
  angle: number = 0

  build() {
    Column({ space: 20 }) {
      Row()
        .width(this.rWidth)
        .aspectRatio(1)
        .backgroundColor(Color.Blue)
      // .animation({
      //   duration: 500,
      //   iterations: -1,
      //   playMode: PlayMode.AlternateReverse
      // })
      Button("变大")
        .onClick(() => {
          animateTo({ duration: 500, iterations: -1, playMode: PlayMode.AlternateReverse }, () => {
            this.rWidth = 200
          })

        })
      Button("变小")
        .onClick(() => {
          this.rWidth = 100
        })

      Row()
        .width(50)
        .aspectRatio(1)
        .backgroundColor(Color.Red)
        .position({
          x: this.xPostion,
          y: 300
        })
        .animation({
          duration: 1000,
          iterations: -1,
          playMode: PlayMode.AlternateReverse
        })
      Button("开始移动")
        .onClick(() => {
          this.xPostion = 310
        })
      Button("开始钟摆")
        .onClick(() => {
          animateTo({ duration: 1000, iterations: -1 }, () => {
            this.angle = 360
          })

        })

      // 钟摆
      RelativeContainer() {
        Row()
          .width(4)
          .height(140)
          .backgroundColor(Color.Blue)
          .alignRules({
            middle: {
              anchor: '__container__',
              align: HorizontalAlign.Center
            }
          })
          .id("row1")

        Row()
          .width(40)
          .aspectRatio(1)
          .borderRadius(20)
          .backgroundColor(Color.Blue)
          .alignRules({
            middle: {
              anchor: '__container__',
              align: HorizontalAlign.Center
            },
            top: {
              anchor: 'row1',
              align: VerticalAlign.Bottom
            }
          })

      }.width(40)
      // .backgroundColor(Color.Gray)
      .rotate({
        angle: this.angle,
        centerX: 20,
        centerY: 0
      })

      // Button("开始恢复")
      //   .onClick(() => {
      //     this.xPostion = 0
      //   })
    }
    .height('100%')
    .width('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1725872243970-1f123ee3-5bdb-40c7-be24-83d5feb90e16.png)

+ 通过animation属性

:::success
<font style="color:rgba(0, 0, 0, 0.9);">识别组件的可动画属性变化，自动添加动画。</font>

<font style="color:rgba(0, 0, 0, 0.9);">组件的接口调用是从下往上执行，animation只会作用于在其之上的属性调用。</font>

<font style="color:rgba(0, 0, 0, 0.9);">组件可以根据调用顺序对多个属性设置不同的animation。</font>

:::



```typescript
import Animator, { AnimatorResult } from '@ohos.animator'

@Entry
@Component
struct AnimatorCase {
  anObj: AnimatorResult | null = null
  @State
  angle: number = 0
  @State
  zAngle: number = 20

  aboutToAppear(): void {
    this.initAnimator()
  }

  initAnimator() {
    this.anObj = Animator.create({
      duration: 1000 * 15,
      easing: 'linear',
      delay: 0,
      fill: "none",
      iterations: -1,
      direction: "normal",
      begin: 0,
      end: 360
    })
    // 监听每帧的回调函数
    this.anObj.onFrame = (val) => {
      this.angle = val
    }
  }

  build() {
    RelativeContainer() {
      Row()
        .width(100)
        .height(4)
        .backgroundColor(Color.Blue)
        .borderRadius(2)
        .alignRules({
          left: {
            anchor: '__container__',
            align: HorizontalAlign.Center
          },
          bottom: {
            anchor: "c1",
            align: VerticalAlign.Top
          }
        })
        .rotate({
          angle: this.zAngle,
          centerX: 0,
          centerY: 0
        })
        .margin({
          bottom: 30
        })

      Row() {
        Image("https://img.1ting.com/images/special/411/20ca07249293be89fd8634480ec995d2.jpg")
          .width(100)
          .aspectRatio(1)
          .borderRadius(50)
      }
      .borderRadius(80)
      .width(160)
      .aspectRatio(1)
      .backgroundColor(Color.Black)
      .justifyContent(FlexAlign.Center)
      .alignRules({
        center: {
          anchor: '__container__',
          align: VerticalAlign.Center
        },
        middle: {
          anchor: '__container__',
          align: HorizontalAlign.Center
        }
      })
      .rotate({
        angle: this.angle,
        centerX: 80,
        centerY: 80
      })
      .id("c1")


      Button("开始播放")
        .alignRules({
          bottom: {
            anchor: '__container__',
            align: VerticalAlign.Bottom
          },
          middle: {
            anchor: '__container__',
            align: HorizontalAlign.Center
          }
        })
        .onClick(() => {
          this.anObj?.play()
          animateTo({ duration: 1000 }, () => {
            this.zAngle = 45
          })

        })
      Button("结束播放")
        .alignRules({
          bottom: {
            anchor: '__container__',
            align: VerticalAlign.Bottom
          },
          right: {
            anchor: '__container__',
            align: HorizontalAlign.End
          }
        })
        .onClick(() => {
          this.anObj?.pause()
          animateTo({ duration: 1000 }, () => {
            this.zAngle = 20
          })

        })
    }
    .height('100%')
    .width('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1725873790996-7461b679-506d-4b3d-870a-55993c7afbc6.png)

做一个心跳的案例吧

:::info
使用之前的点赞图标

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1702277195178-d455d106-5593-48f7-99a6-d45e6c0d7da3.png)



:::color1
注意： **<font style="color:#DF2A3F;">停止动画的方式不能再设置-具体看后面的解决方案</font>**

:::



```typescript
@Entry
@Component
struct HeartCase {
  @State
  scaleValue: number = 1
  @State
  animationObj: AnimateParam = {
    duration: 500,
    playMode: PlayMode.Alternate,
    iterations: -1
  }

  build() {
    Row() {
      Column({ space: 20 }) {
        Column() {
          Image($r('app.media.like'))
            .width(60)
            .height(60)
            .fillColor(Color.Red)
            .scale({ x: this.scaleValue, y: this.scaleValue })
            .animation(this.animationObj)
        }.height(120)

        Button(this.scaleValue === 3 ? "结束心跳" : "开始心跳")
          .onClick(() => {
             if(this.scaleValue === 3) {
               // 清理
               this.scaleValue = 1
               this.animationObj = {
                 duration: 0,
               }
             }else {
               this.scaleValue = 3
               this.animationObj = {
                 duration: 500,
                 playMode: PlayMode.Alternate,
                 iterations: -1
               }
             }
          })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

:::info
需要针对animation进行整体对象赋值，如果停止动画需要设置duration为0

:::



<h3 id="qBZxv">2.骨架屏的动画案例</h3>
```arkts
@Entry
@Component
struct SkleonCase {
  @State message: string = 'Hello World';

  build() {
    RelativeContainer() {
      HmSkeleton()
    }
    .height('100%')
    .width('100%')
  }
}

@Component
struct HmSkeleton {
  build() {
    Column({ space: 20 }) {
      HmSkeletonItem()
      HmSkeletonItem()
      HmSkeletonItem()
      HmSkeletonItem()
      HmSkeletonItem()
      HmSkeletonItem()

    }
    .padding(20)
    .width("100%")
    .height("100%")
    .backgroundColor(Color.Brown)
  }
}

@Component
struct HmSkeletonItem {
  @State
  transLateX: number = 0

  build() {
    Row() {
      Row()
        .width(100)
        .height("100%")
        .position({
          x: this.transLateX
        })
        .linearGradient({
          direction: GradientDirection.Right,
          colors: [["rgba(255,255,255, 0)", 0], ["rgba(255,255,255, 1)", 0.5], ["rgba(255,255,255, 0)", 1]]
        })
        .onAppear(() => {
          animateTo({ duration: 1500, iterations: -1 }, () => {
            this.transLateX = 240
          })

        })
    }
    .width("100%")
    .height(30)
    .backgroundColor("#ccc")
    .borderRadius(4)
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1725874611944-33249024-27ed-4b03-8e2c-2f15af5aeb38.png)

<h3 id="rHp5X">3.图片帧动画</h3>
:::success
通过使用ImageAnimator组件<font style="color:rgba(0, 0, 0, 0.9);">实现逐帧播放图片的能力，可以配置需要播放的图片列表，每张图片可以配置时长</font>

[帧动画素材.zip](https://weiqi123.yuque.com/attachments/yuque/0/2024/zip/32778948/1727514755074-8c5c68aa-570f-4113-962f-6ee5419daa29.zip)

:::

```typescript
@Entry
@Component
struct ImageAnimateCase {
  @State
  list: ImageFrameInfo[] = []
  @State
  state: AnimationStatus = AnimationStatus.Initial // 播放状态

  aboutToAppear(): void {
    this.list = [1, 2, 3, 4, 5, 6].map(item => {
      return { src: `/pages/10/images/coin${item}.png` } as ImageFrameInfo
    })
  }

  build() {
    Column({ space: 20 }) {
      ImageAnimator()
        .images(this.list)
        .width(300)
        .state(this.state)
        .iterations(-1)
        .aspectRatio(1)
        .duration(200)

      Button("播放/暂停")
        .onClick(() => {
          if (this.state !== AnimationStatus.Running) {
            this.state = AnimationStatus.Running
          } else {
            this.state = AnimationStatus.Paused
          }
        })
    }
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .height('100%')
    .width('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1723447014596-711c87c0-e8f7-4c83-bb18-ee64382ca0d4.png)

:::success
通过state属性可以控制图片的动画的执行方式

:::

<h3 id="d811cb75">2. 转场动画</h3>
:::success
+ 出现/消失转场
+ 模态转场 bindSheet 半模态
+ 共享元素转场 
+ 页面转场
+ 组件内转场 transition属性

:::

+ 出现/消失专场

:::success
直接使用animateTo闭包函数即可

:::

```typescript
@Entry
@Component
struct ShowOrHideCase {
  @State message: string = 'Hello World';
  @State
  showMessage: boolean = false
  build() {
    Row() {
      Column() {
        Column() {
          if(this.showMessage) {
            Text(this.message)
              .fontSize(50)
              .fontWeight(FontWeight.Bold)
          }
        }
        .height(50)

        Button("显示/隐藏")
          .onClick(() => {
             animateTo({ duration: 1000 },  () => {
              this.showMessage = !this.showMessage
             })
          })

      }
      .width('100%')
    }
    .height('100%')
  }
}
```

+ 模态转场

:::success
<font style="color:rgba(0, 0, 0, 0.9);">模态转场是新的界面覆盖在旧的界面上，旧的界面不消失的一种转场方式。</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711006110178-a5b86658-6f36-479b-9ea3-cec8fc980f63.png)

:::success
这里没用过的就是全屏模态，测试一下

:::

```typescript
@Entry
@Component
struct ShowOrHideCase {
  @State message: string = 'Hello World';
  @State
  showMessage: boolean = false
  @State
  showDialog: boolean = false
  @State
  timeCount: number = 5
  timer: number  = -1
  aboutToAppear(): void {
    this.showDialog = true
    this.beginCount()
  }
  @Builder
  getContent () {
    Column() {
      Row() {
       Text(`还剩${this.timeCount}秒`)
         .fontColor(Color.White)
         .onClick(() => {
           clearInterval(this.timer)
           this.timeCount = 5
           this.showDialog = false
         })
      }
      .width('100%')
      .justifyContent(FlexAlign.End)
      .padding(10)

    }
    .backgroundColor(Color.Blue)
    .width('100%')
    .height('100%')
  }

  beginCount () {
   this.timer = setInterval(() => {
      if(this.timeCount === 0) {
        clearInterval(this.timer)
        this.timeCount = 5 // 归位
        this.showDialog = false // 关闭弹层
        return
      }
      this.timeCount--
    }, 1000)
  }
  aboutToDisappear(): void {
    clearInterval(this.timer)
  }

  build() {
    Row() {
      Column() {
        Column() {
          if(this.showMessage) {
            Text(this.message)
              .fontSize(50)
              .fontWeight(FontWeight.Bold)
          }
        }
        .height(50)

        Button("显示/隐藏")
          .onClick(() => {
             animateTo({ duration: 1000 },  () => {
              this.showMessage = !this.showMessage
             })
          })
        Button("模态显示")
          .onClick(() => {
              this.showDialog = true
              this.beginCount()
          })

      }
      .width('100%')
    }
    .height('100%')
    .bindContentCover($$this.showDialog,
      this.getContent, {
        modalTransition: ModalTransition.NONE
      })
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711455063000-f69bf887-d0e4-4241-8865-4fa7112b0d94.png)

+ 组件内元素专场transition

:::success
<font style="color:rgba(0, 0, 0, 0.9);">组件内转场主要通过transition属性配置转场参数，在组件插入和删除时显示过渡动效，主要用于容器组件中的子组件插入和删除时，提升用户体验。</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711006744532-d6bc8097-009f-428e-80e5-ab91aa4c6952.png)

:::success
**4.0中的我们使用的transitionOption的属性被废弃了，新增了TransitionEffect的属性设置方式**

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711006813041-00ea26f7-5e5b-48fe-a01d-6eb7a06c23c0.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711006824342-60bc21d1-80ee-49f5-ba4a-28939148de35.png)![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711006837264-1ea6ac2f-6b10-4bcd-a0be-ceb16905dee5.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711006852801-e25ed326-2c8f-4dfb-a445-1dc287268d34.png)

:::success
语法

.transition(TransitionEffect.SLIDE.animation({

  duration: 1000

}).combine(TransitionEffect.rotate({

  angle: -180

})).combine(TransitionEffect.translate({

  x: '-100%'

})))

有三种模式可选

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711083955803-9bca9312-8a32-460f-8b6a-9e3770e4cd6d.png)

:::

 

```plain
.transition(TransitionEffect.SLIDE.animation({
  duration: 1000
}).combine(TransitionEffect.rotate({
  angle: -180
})).combine(TransitionEffect.translate({
  x: '-100%'
})))
```

 

```typescript
@Entry
@Component
struct ComAnCase {
  @State
  showImage: boolean = false

  build() {
    Row() {
      Column({ space: 20 }) {
        Column() {
          if(this.showImage) {
            Image($r("app.media.handsome"))
              .width(100)
              .height(100)
              .borderRadius(50)
              .transition(TransitionEffect.OPACITY.animation({
                duration: 1000
              }).combine(TransitionEffect.rotate({
                angle: -180
              })).combine(TransitionEffect.translate({
                x: '-100%'
              })))
          }
        }
        .height(100)

       Button("显示/隐藏")
         .onClick(() => {
           this.showImage = !this.showImage
         })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

:::success
上图会从左侧翻转180度进行翻滚进去，并会以相同方式翻滚出去

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711083083850-a947cac3-6039-49c2-b36d-584b6e012157.png)



:::success
假如想要自己控制进入和出去的效果，比如从上面进入，下面出去，可以使用TransitionEffect.<font style="color:rgba(0, 0, 0, 0.9);">asymmetric方法，第一个设置进入时的动画，第二个设置离开时的动画</font>

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711084309991-b56ed4d7-925a-49ea-8976-0b8cf1b13503.png)

:::

+ 实现上面进来，下面出去的效果

```typescript
@Entry
@Component
struct ComAnCase {
  @State
  showImage: boolean = false

  build() {
    Row() {
      Column({ space: 20 }) {

      Row() {
        Button("显示/隐藏")
          .onClick(() => {
            this.showImage = !this.showImage
          })
      }
        .width('100%')

        Column() {
          // if(this.showImage) {
          //   Image($r("app.media.handsome"))
          //     .width(100)
          //     .height(100)
          //     .borderRadius(50)
          //     .transition(TransitionEffect.SLIDE.animation({
          //       duration: 1000
          //     }).combine(TransitionEffect.rotate({
          //       angle: -180
          //     })).combine(TransitionEffect.translate({
          //       x: '-100%'
          //     })))
          // }
          if(this.showImage) {
            Image($r("app.media.handsome"))
              .width(100)
              .height(100)
              .borderRadius(50)
              .transition(
                TransitionEffect.asymmetric(
                  TransitionEffect.OPACITY.animation({
                    duration: 1000
                  }).combine(
                    TransitionEffect.move(TransitionEdge.TOP)

                  ),
                  TransitionEffect.OPACITY.animation({
                    duration: 1000
                  }).combine(
                    TransitionEffect.move(TransitionEdge.BOTTOM)
                  )
                )
              )
          }
        }
        .height(100)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

+ 页面元素共享

:::success
<font style="color:rgba(0, 0, 0, 0.9);">当路由进行切换时，可以通过设置组件的 sharedTransition 属性将该元素标记为共享元素并设置对应的共享元素转场动效。</font>

:::

A页面

```typescript
import { router } from '@kit.ArkUI';

@Entry
@Component
struct AImage {
  @State message: string = 'Hello World';

  build() {
    Row() {
      Column() {
         Image($r("app.media.handsome"))
           .width(200)
           .height(200)
           .borderRadius(50)
           .sharedTransition("myImage", {
             duration: 400
           })
           .onClick(() => {
             router.pushUrl({
               url: 'pages/04/BImage'
             })
           })
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

B页面

```typescript
@Entry
@Component
struct BImage {
  @State message: string = 'Hello World';

  build() {
     Column() {
       Image($r("app.media.handsome"))
         .width('100%')
         .height('50%')
         .sharedTransition("myImage", {
           duration: 400
         })
     }
    .width('100%')
    .height('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711088197405-b300d9da-28d5-4e6e-b547-313bce5b9d44.png)![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711088223810-6fa7de06-4803-4a1b-adb9-14242270d002.png)



<h1 id="qno1b">手势处理</h1>
:::success
<font style="color:rgba(0, 0, 0, 0.9);">为组件绑定不同类型的手势事件，并设置事件的响应方法。</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711088438133-e6d535ca-dc61-4121-ba1c-a8f9adb35ff7.png)

:::success
一般情况下 使用组件的gesture即可

:::

+ 手势类型

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711088524875-7efda164-083c-4b17-bfce-f25d4d97f198.png)

:::success
我们这里学习两个，长按手势和平移手势

语法

 .gesture( LongPressGesture().onAction(() => {})  )

:::

+ 长按手势LongPressGesture

:::success
![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711338730833-877625a6-3f05-43ec-80bc-88116b7d8684.png)

:::

:::success
基本上所有的手势都会有这三个事件

:::

+ 实现一个功能-长按语音按钮，显示语音录制框

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711350167183-98fc6331-37fd-41a6-915b-f4d5ba1b25f0.png)



```typescript
import { util } from '@kit.ArkTS'

@Entry
@Component
struct GestureCase {
  @State
  showVoice: boolean = false

  @Builder
  getContent() {
    Column() {
      Row() {
        Row() {
          Text("删")
            .fontColor(Color.White)
            .fontSize(30)
        }
        .justifyContent(FlexAlign.Center)
        .width(80)
        .height(80)
        .borderRadius(40)
        .backgroundColor(Color.Gray)
        .rotate({
          angle: -10
        })
        Row() {
          Text("文")
            .fontColor(Color.White)
            .fontSize(30)
        }
        .justifyContent(FlexAlign.Center)
        .width(80)
        .height(80)
        .borderRadius(40)
        .backgroundColor(Color.Gray)
        .rotate({
          angle: 10
        })
      }
      .height(80)
      .width('100%')
      .padding({
        left: 40,
        right: 40
      })
      .justifyContent(FlexAlign.SpaceBetween)
    }
    .justifyContent(FlexAlign.Center)
    .width('100%')
    .height('100%')
    .backgroundColor("rgba(0,0,0,0.4)")
  }

  build() {
    Row() {
      Column() {
        Button("语音")
          .width('100%')
          .type(ButtonType.Normal)
          .gesture(
            LongPressGesture()
              .onAction(() => {
                this.showVoice = true
              })
              .onActionEnd(() => {
                this.showVoice = false
              })
          )
      }
      .padding(20)
      .width('100%')
    }
    .height('100%')
    .bindContentCover($$this.showVoice, this.getContent,
      {
        modalTransition: ModalTransition.NONE
      })
  }
}
```

+ 拖动手势PanGesture

:::success
![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711350317178-93119507-3f2b-4555-9bbc-6111b0068f69.png)

:::

结合原来的长按，长按基础上，拖动实现删除或者文本按钮的选中

:::success
此时需要使用组合手势，因为是长按和拖动手势的集合

组合手势<font style="color:rgba(0, 0, 0, 0.9);">GestureGroup(mode: GestureMode, ...gesture: GestureType[])</font>

<font style="color:rgba(0, 0, 0, 0.9);">GestureMode </font>

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711350470684-c6d18483-0255-4782-9849-712b907919ef.png)



GestureEvent的事件参数

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711350829781-3e45a180-2684-41dc-bf34-2c27438fcb0c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711350842208-e4d4ca85-ea8a-404c-9775-8ce77d4c7aa5.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711350852638-b61f2a51-890f-4e03-9589-d306cf4000a9.png)

:::

+ 手指的坐标信息

:::success
![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711352014142-19c24952-e7cb-4413-860e-12a27675449d.png)

:::



:::success
判断逻辑，只要发现x坐标在中线偏左，左边就选中，中线偏右右边选中

:::

+ 声明一个枚举类型

```typescript
enum SelectType {
  DElETE,
  TEXT,
  NONE
}
```

+ 通过onAreaChange的值事件拿宽度

```typescript
screenWidth: number = 0

  .onAreaChange((oldArea: Area, newArea: Area) => {
      this.screenWidth = newArea.width as number
    })
```

+ 在拖动更新事件中判断坐标落点

```typescript
 PanGesture()
                .onActionUpdate((event) => {
                  if(event.fingerList[0].globalX < this.screenWidth / 2) {
                    this.currentMode = SelectType.DElETE
                  }else {
                    this.currentMode = SelectType.TEXT
                  }
                })
                .onActionEnd(() => {
                  this.currentMode = SelectType.NONE
                })
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711354214863-c0a85b5f-4cb8-44c2-bb5d-44699e7c1075.png)



:::success
完成代码

:::

```typescript
import { util } from '@kit.ArkTS'
import {  deviceInfo } from '@kit.BasicServicesKit'
import { display, promptAction } from '@kit.ArkUI'

@Entry
@Component
struct GestureCase {
  @State
  showVoice: boolean = false
  screenWidth: number = 0
  @State
  currentMode: SelectType = SelectType.NONE
  @Builder
  getContent() {
    Column() {
      Row() {
        Row() {
          Text("删")
            .fontColor(Color.White)
            .fontSize(30)
        }
        .justifyContent(FlexAlign.Center)
        .width(80)
        .height(80)
        .borderRadius(40)
        .backgroundColor(this.currentMode === SelectType.DElETE ? Color.Red  : Color.Gray)
        .rotate({
          angle: -10
        })
        Row() {
          Text("文")
            .fontColor(Color.White)
            .fontSize(30)
        }
        .justifyContent(FlexAlign.Center)
        .width(80)
        .height(80)
        .borderRadius(40)
        .backgroundColor(this.currentMode === SelectType.TEXT ? Color.Red  : Color.Gray)
        .rotate({
          angle: 10
        })
      }
      .height(80)
      .width('100%')
      .padding({
        left: 40,
        right: 40
      })
      .justifyContent(FlexAlign.SpaceBetween)
    }
    .justifyContent(FlexAlign.Center)
    .width('100%')
    .height('100%')
    .backgroundColor("rgba(0,0,0,0.4)")
  }

  build() {
    Row() {
      Column() {
        Button("语音")
          .width('100%')
          .type(ButtonType.Normal)
          .gesture(
            GestureGroup(GestureMode.Parallel,
              LongPressGesture()
              .onAction(() => {
                this.showVoice = true
              })
              .onActionEnd(() => {
                this.showVoice = false
              }),
              PanGesture()
                .onActionUpdate((event) => {
                  if(event.fingerList[0].globalX < this.screenWidth / 2) {
                    this.currentMode = SelectType.DElETE
                  }else {
                    this.currentMode = SelectType.TEXT
                  }
                })
                .onActionEnd(() => {
                  this.currentMode = SelectType.NONE
                })
            )

          )
      }
      .padding(20)
      .width('100%')
    }
    .width('100%')
    .height('100%')
    .bindContentCover($$this.showVoice, this.getContent,
      {
        modalTransition: ModalTransition.NONE
      })
    .onAreaChange((oldArea: Area, newArea: Area) => {
      this.screenWidth = newArea.width as number
    })
  }
}

enum SelectType {
  DElETE,
  TEXT,
  NONE
}
```



:::success
获取屏幕宽度

+ 页面最外层的组件onAreaChange 拿到最新的宽高

display的能力 需要模拟器

  display.getAllDisplays() 拿到所有展示的屏幕的宽高

:::

+ 实现图片预览-可放大-拖动-双击

```arkts
@Entry
@Component
struct PreviewImageGesture {
  @State
  scaleValue: number = 1
  @State
  translateX: number = 0
  @State
  translateY: number = 0

  build() {
    RelativeContainer() {
      Image($r("app.media.handsome"))
        .width("100%")
        .alignRules({
          center: {
            anchor: "__container__",
            align: VerticalAlign.Center
          }
        })
        .scale({
          x: this.scaleValue,
          y: this.scaleValue
        })
        .translate({
          x: this.translateX,
          y: this.translateY
        })
        .gesture(
          GestureGroup(GestureMode.Parallel,
            PinchGesture()
              .onActionUpdate(event => {
                if (event.scale > 1) {
                  this.scaleValue = event.scale
                }
              }),
            PanGesture()// 利用偏移量
              .onActionUpdate((event) => {
                if (this.scaleValue > 1) {
                  this.translateX = event.offsetX
                  this.translateY = event.offsetY
                }
              }),
            TapGesture({ count: 2 })
              .onAction(() => {
                if (this.scaleValue > 1) {
                  animateTo({ duration: 500 }, () => {
                    this.scaleValue = 1
                    this.translateX = 0
                    this.translateY = 0
                  })

                } else {
                  animateTo({ duration: 500 }, () => {
                    this.scaleValue = 2
                  })

                }
              })

          ),


        )
    }
    .height('100%')
    .width('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1725382022454-4a370e23-5b76-4878-b294-71f2251016ab.png)

<h1 id="ZG9pL">沙箱文件操作</h1>
:::success
<font style="color:rgba(0, 0, 0, 0.9);">应用沙箱是一种以安全防护为目的的隔离机制，避免数据受到恶意路径穿越访问。在这种沙箱的保护机制下，应用可见的目录范围即为“应用沙箱目录”。</font>

+ <font style="color:rgb(36, 39, 40);">对于每个应用，系统会在内部存储空间映射出一个专属的“应用沙箱目录”，它是“</font>[应用文件目录](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/app-sandbox-directory-0000001774280086#ZH-CN_TOPIC_0000001774280086__%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%BA%94%E7%94%A8%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84)<font style="color:rgb(36, 39, 40);">”与一部分系统文件（应用运行必需的少量系统文件）所在的目录组成的集合。</font>
+ <font style="color:rgb(36, 39, 40);">应用沙箱限制了应用可见的数据的最小范围。在“应用沙箱目录”中，应用仅能看到自己的应用文件以及少量的系统文件（应用运行必需的少量系统文件）。因此，本应用的文件也不为其他应用可见，从而保护了应用文件的安全。</font>
+ <font style="color:rgb(36, 39, 40);">应用可以在“应用文件目录”下保存和处理自己的应用文件；系统文件及其目录对于应用是只读的；而应用若需访问</font>[用户文件](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides/user-file-overview-0000001774120430)<font style="color:rgb(36, 39, 40);">，则需要通过特定API同时经过用户的相应授权才能进行。</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711354452197-ad288b41-5cf3-49d1-80d2-ced431adb0db.png)

:::success
<h2 id="glVpv"><font style="color:rgba(0, 0, 0, 0.9);">应用文件目录与应用文件路径</font></h2>
<font style="color:rgba(0, 0, 0, 0.9);">如前文所述，“应用沙箱目录”内分为两类：应用文件目录和系统文件目录。</font>

<font style="color:rgba(0, 0, 0, 0.9);">系统文件目录对应用的可见范围由系统预置，开发者无需关注。</font>

<font style="color:rgba(0, 0, 0, 0.9);">在此主要介绍应用文件目录，如下图所示。应用文件目录下某个文件或某个具体目录的路径称为应用文件路径。应用文件目录下的各个文件路径，具备不同的属性和特征。</font>

**<font style="color:rgba(0, 0, 0, 0.9);">图3</font>**<font style="color:rgba(0, 0, 0, 0.9);"> 应用文件目录结构图</font>

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711355110852-924f1e1a-e546-4021-8daf-d892567a5e06.png)

+ 获取沙箱目录

:::success
getContext().cacheDir

getContext().fileDir

getContext().tempDir

:::

+ 文件操作

:::success
harmonyOS提供文件操作的API，相当于nodejs的中的fs操作

值得注意的是： 在API9中 使用fs

在当前的API11和API12中官方又提供了 fileIo的基础方法，用法和fs基本一致

open 打开文件

close 关闭文件

write写入文件

copy 复制文件

unlink 删除文件

mkdir 创建文件夹

上述方法均支持promise并提供有对应的同步方法

想要操作一个文件，首先要打开一个文件，读取一个文件的buffer或者fd，通过fd进行文件的buffer进行相应的操作

:::

+ 从相册尝试拷贝一个图片到我们的沙箱

```arkts
import { photoAccessHelper } from '@kit.MediaLibraryKit'
import fileIo from '@ohos.file.fs'
import fs from '@ohos.file.fs'
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct FileOperateCase {
  @State
  list: string[] = []

  async selectPhoto() {
    const picker = new photoAccessHelper.PhotoViewPicker()
    const result = await picker.select({
      maxSelectNumber: 9
    })
    // this.list = result.photoUris // 相册地址
    // 需要完成相册的图片到沙箱的操作
    // 以后每次进来 自动加载沙箱的图片
    this.saveLocal(result.photoUris)

  }

  aboutToAppear(): void {
    this.getListByHard()
  }

  // 保存到沙箱
  saveLocal(list: string[]) {
    // 想建立个子目录
    const rootPath = getContext().filesDir
    const childName = "images" // 目录名称
    if (!fileIo.listFileSync(rootPath).includes(childName)) {
      fileIo.mkdirSync(rootPath + "/" + childName) // 自动创建了files目录下images
    }
    list.forEach(item => {
      // item 是相册的地址 和应用没关系 应用只是能够预览
      // 先得到文件对象
      const file = fileIo.openSync(item, fileIo.OpenMode.READ_ONLY)
      // 要将file拷贝到沙箱目录下
      // 需要知道图片的目标路径
      const destFileName = rootPath + "/" + childName + "/" + file.name
      if (!fileIo.listFileSync(rootPath + "/" + childName).includes(file.name)) {
        // 如果包含同名文件就不要操作
        // const desFile = fileIo.openSync(destFileName, fileIo.OpenMode.CREATE | fileIo.OpenMode.READ_WRITE)
        fileIo.copyFileSync(file.fd, destFileName) // fd://35
      }
      fileIo.closeSync(file.fd)
    })
    // 其实已经完成了拷贝
    // 再做一件事
    // 从磁盘中遍历得到所有的图片
    this.getListByHard()

  }

  // 通过磁盘分析得到列表地址
  getListByHard() {
    const rootPath = getContext().filesDir + "/images"
    this.list = fileIo.listFileSync(rootPath).filter(item => {
      return ["JPG", "PNG", "GIF", "BMP"].includes(item.substring(item.lastIndexOf(".") + 1).toUpperCase())
    })
      .sort()
      .map(item => {
        return `${rootPath}/${item}`
      })

  }

  async delFile(path: string) {
    const res = await promptAction.showDialog({
      message: '确定要删除该文件吗?',
      buttons: [{
        text: '取消',
        color: '#000'
      }, {
        text: '确定',
        color: '#000'
      }]
    })
    if (res.index === 1) {
      fileIo.unlinkSync(path)
      this.getListByHard()
    }

  }

  build() {
    Column({ space: 20 }) {
      Button("选择照片")
        .onClick(() => {
          this.selectPhoto()
        })
      Grid() {
        ForEach(this.list, (item: string) => {
          GridItem() {
            Stack({ alignContent: Alignment.TopEnd }) {
              Image("file://" + item)
                .width("100%")
                .height("100%")
                .borderRadius(4)

              Image($r("sys.media.ohos_ic_public_drawer_close"))
                .width(30)
                .aspectRatio(1)
                .onClick(() => {
                  this.delFile(item)
                })
            }
          }
          .height(200)
        })
      }
      .columnsTemplate("1fr 1fr")
      .columnsGap(20)
      .rowsGap(20)
      .width("100%")
      .padding(20)
      .layoutWeight(1)
    }
    .width("100%")
    .height("100%")
  }
}
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1725958170767-6f9282f5-dbc7-48fd-bab3-db86278236af.png)

+ 下载上传

:::color1
+ 下载直接下载到沙箱- 直接告诉路径即可
+ 写入相册两种途径-安全组件/向华为申请最高权限（发邮件-审核-包名提交）

:::

+ 试着下载一个图片到我们的沙箱路径，并且显示在页面上（模拟器）

```typescript
import { request } from '@kit.BasicServicesKit'
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct DownloadImg {
  @State
  tempPath: string = ''
  netImgUrl: string = 'http://dingyue.ws.126.net/2024/0209/8ec94ea3g00s8l8ki00ytd200f0008cg00it00ag.gif'
  async downLoad () {
    let path = getContext().cacheDir + '/' + Date.now() + ".jpg"
    const task = await request.downloadFile(getContext(),{
      url: this.netImgUrl,
      filePath:  path // 存在哪里
    })
    task.on("progress", (process,total) => {
       promptAction.showToast({
         message:  process + '-' + total
       })
    })
    task.on("complete", () => {
      this.tempPath = path
      AlertDialog.show({
        message: '下载成功'
      })
    })

  }
  build() {
    Row() {
      Column({ space: 20 }) {
        Image(this.netImgUrl)
          .width(100)
          .height(100)
        Button("下载图片")
          .onClick(() => {
             this.downLoad()
          })
        if(this.tempPath) {
          Image("file://"+this.tempPath)
            .width(100)
            .height(100)
        }
      }
      .width('100%')
    }
    .height('100%')
  }
}
```



![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711355874322-c8aba498-345e-4c30-9f34-7f9dd3fb7ecb.png)



:::success
沙箱目录的内容 图片或者web组件要去访问的，需要使用文件协议

file://  文件协议

http://

https://

:::





+ 混合开发中的热更新操作

:::success
HyBrid 混合开发

原生应用 + web前端

原生壳子webview + SDK

:::

:::success
现在线上有个压缩包，是我们的h5页面，可以正常通过浏览器访问，我们需要在应用中进行下载解压到我们的沙箱目录下，并且下载完成能够正常访问

:::

+ 准备可访问的网络资源(压缩包)

:::success
[https://gitee.com/shuiruohanyu/toutiao_net/raw/master/resources/toutiao.zip](https://gitee.com/shuiruohanyu/toutiao_net/raw/master/resources/toutiao.zip)

:::

+ 实现下载方法

```typescript
import { request } from '@kit.BasicServicesKit'
import { fileIo } from '@kit.CoreFileKit'
import { promptAction } from '@kit.ArkUI'

@Entry
@Component
struct HyBridHotLoad {
  @State
  showLoading: boolean = false
  @State
  currentValue: number = 0
  @State
  totalValue: number = 0

  async downLoad() {
    this.showLoading = true
    const fileName = "toutiao.zip"
    // 判断一下 我们的目录是否已经有了这个
    const filePath = getContext().filesDir + '/' + fileName
    // file cache temp
    if (fileIo.listFileSync(getContext().filesDir).includes(fileName)) {
      // 沙箱目录下已经有了这个文件
      // 备份
      fileIo.renameSync(filePath, getContext().filesDir + '/toutiao.bak.zip')
    }
    const task = await request.downloadFile(getContext(), {
      url: 'https://gitee.com/shuiruohanyu/toutiao_net/raw/master/resources/toutiao.zip',
      filePath
    })
    task.on("progress", (current, total) => {
      this.currentValue = current
      this.totalValue = total
    })
    task.on("fail", (error) => {
       AlertDialog.show({ message: error.toString() })
    })
    task.on("complete", () => {
      this.showLoading = false
      promptAction.showToast({ message: '下载成功' })
    })
  }

  @Builder
  getContent() {
    Column() {
      Progress({
        value: this.currentValue,
        total: this.totalValue
      })
        .width('100%')
    }
    .justifyContent(FlexAlign.Center)
    .width('100%')
    .height('100%')
    .backgroundColor("rgba(0,0,0,0.5)")
  }

  build() {
    Row() {
      Column() {
        Button("热更新")
          .onClick(() => {
            this.downLoad()
          })
      }
      .width('100%')
    }
    .height('100%')
    .bindContentCover($$this.showLoading, this.getContent, {
      modalTransition: ModalTransition.NONE
    })
  }
}
```



![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711358155578-8651a0d4-120f-45ab-8ae5-998835af4ab7.png)

+ 解压zip包

:::success
使用zlib模块

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711359763487-2d52a18b-9e89-453e-b42e-21f3e1cbd1d2.png)

:::

```typescript
// 解压文件
  async decompressFile () {
    try {
      await zlib.decompressFile(this.filePath, getContext().filesDir)
    }catch(error) {
      AlertDialog.show({
        message: error.message
      })
    }
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711359894759-67f45661-a15b-4bba-89cd-1c629367dcbc.png)

+ 解压后跳转到拥有web组件的页面

```typescript
// 解压文件
  async decompressFile () {
    try {
      await zlib.decompressFile(this.filePath, getContext().filesDir)
      router.pushUrl({
        url: 'pages/06/WebCase'
      })
    }catch(error) {
      AlertDialog.show({
        message: error.message
      })
    }
  }
```

+ web端页面内容

```typescript
import { webview } from '@kit.ArkWeb'

interface res {
  url: string;
  message: string;
  result: JsResult;
}

@Entry
@Component
struct WebCase {
  webController: webview.WebviewController = new webview.WebviewController()



  build() {
    Column() {
      Web({
        controller: this.webController,
        src: "file://" + getContext().filesDir + '/toutiao/index.html'
      })
        .fileAccess(true)
        .domStorageAccess(true)
        .width('100%')
        .height("100%")
    }
    .width("100%")
    .height('100%')

  }
}
```

:::success
注意： 因为默认web里面的内容是不开启本地存储的，所以需要使用domStorageAccess属性将允许本地存储的属性开启，否则我们的h5里面的内容就不被允许执行了，会报错， API12开始必须开启fileAccess属性

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711368260292-bc03fd82-ed22-4346-846c-66d0f3e959ab.png)



:::success
这里普及个冷知识，在模拟器中的页面同样可以调试，需要使用hdc命令

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711425530775-736d53f3-c810-4979-9eb9-2c05ef94dea4.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711425544324-4d2ed48a-5f73-4337-b8d4-bb0ed434f9de.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711425557875-b71096b5-dd99-471d-bf6c-2f619566ff42.png)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1711425570213-7e74309a-a3cd-4a05-8c46-55f9a2fb4359.png)

:::

<h1 id="6fccaf89">原生能力</h1>
<h3 id="Y1RI4">1. 音视频播放</h3>
+ 视频播放

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703128765275-10d09c30-d3af-4a84-a2ee-ea216a34fa46.png)

:::color2
arkUI提供了Video组件可以直接播放视频，并提供自带的播放-暂停 全屏，拖动进度等功能

用法

+ Video提供构造参数  Video({ src: string | Resource }) 
+ src支持在线路径-和本地资源路径

:::

+ 示例

```typescript
  Video({
          src: 'https://vd3.bdstatic.com/mda-pmj5ajqd7p4b6pgb/576p/h264/1703044058699262355/mda-pmj5ajqd7p4b6pgb.mp4?auth_key=1703138418-0-0-618ea72b33be241c96c6cff86c06e080&bcevod_channel=searchbox_feed&cr=1&cd=0&pd=1&pt=4&logid=0018430194&vid=9762003448174112444&abtest=all'
        })
          .width('100%')
          .aspectRatio(1.4)
```

:::color2
版权说明： 上述代码中的视频链接为参考学习，并非用作商业用途，请同学们自行放置的外链视频链接

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703127887030-aa0cd64a-608b-4375-b736-a405444e52f6.png)

+ 放映本地视频

:::color2
本地视频我们需要放置在资源目录的原始文件中rawfile目录下，使用$rawfile函数来获取路径进行赋值即可

:::

```typescript
 Video({
            src: $rawfile('travel.mp4')
          })
            .width('100%')
            .aspectRatio(1.4)
```

+ 完整代码

```typescript
@Entry
@Component
struct VideoCase {
  @State message: string = 'Hello World'

  build() {
    Row() {
      Tabs() {
        TabContent() {
          Column() {
            Video({
              src: 'https://vd3.bdstatic.com/mda-pmj5ajqd7p4b6pgb/576p/h264/1703044058699262355/mda-pmj5ajqd7p4b6pgb.mp4?auth_key=1703138418-0-0-618ea72b33be241c96c6cff86c06e080&bcevod_channel=searchbox_feed&cr=1&cd=0&pd=1&pt=4&logid=0018430194&vid=9762003448174112444&abtest=all'
            })
              .width('100%')
              .aspectRatio(1.4)
          }
          .width('100%')
        }.tabBar("在线视频")
        TabContent() {
          Video({
            src: $rawfile('travel.mp4')
          })
            .width('100%')
            .aspectRatio(1.4)
        }
        .tabBar("本地视频")
      }
      .animationDuration(300)

    }
    .height('100%')
  }
}
```



+ 视频控制-播放-暂停--倍速-全屏-进度

:::color2
我们可以通过构造函数传入<font style="color:rgba(0, 0, 0, 0.9);">currentProgressRate 控制倍速，它来自PlaybackSpeed的枚举，目前支持</font>

<font style="color:rgba(0, 0, 0, 0.9);">0.75-1-1.25-1.75-2倍速设置</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">同时我们可以通过传入VideoController来获取视频播放的控制权</font>

:::

+ 实现控制倍速播放

```typescript
@Entry
@Component
struct VideoCase {
  @State
  speed: number = 1

  build() {
    Row() {
      Tabs() {
        TabContent() {
          Column({ space: 20 }) {
            Video({
              currentProgressRate: this.speed,
              src: 'https://vd3.bdstatic.com/mda-pmj5ajqd7p4b6pgb/576p/h264/1703044058699262355/mda-pmj5ajqd7p4b6pgb.mp4?auth_key=1703138418-0-0-618ea72b33be241c96c6cff86c06e080&bcevod_channel=searchbox_feed&cr=1&cd=0&pd=1&pt=4&logid=0018430194&vid=9762003448174112444&abtest=all'
            })
              .width('100%')
              .aspectRatio(1.4)
            Slider({
              value: this.speed,
              min: 0.75,
              step: 0.25,
              max: 2,
              style: SliderStyle.InSet
            })
              .showSteps(true)
              .onChange(value => {
                this.speed = value
              })
            Text(this.speed+"倍速").fontSize(14).textAlign(TextAlign.Center).width('100%')

          }
          .width('100%')
        }.tabBar("在线视频")
        TabContent() {
          Video({
            src: $rawfile('travel.mp4')
          })
            .width('100%')
            .aspectRatio(1.4)
        }
        .tabBar("本地视频")
      }
      .animationDuration(300)

    }
    .height('100%')
  }
}
```

+ 实现通过controller控制视频 暂停- 播放- 移动进度

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703130407258-82b179f8-469e-4b81-b888-d568c1055188.png)

:::color1
controller 是组件背后的示例

:::

```typescript
controller: VideoController = new VideoController() // 定义controller


Row({ space: 20 }) {
              Button("播放")
                .onClick(() => {
                  this.controller.start()
                })
              Button("暂停")
                .onClick(() => {
                  this.controller.pause()
                })
              Button("移动进度")
                .onClick(() => {
                  this.controller.setCurrentTime(30) // 单位为秒
                })
              Button("结束")
                .onClick(() => {
                  this.controller.stop()
                })
            }
```



:::color2
同理- 如果我们想播放一段音频-用同样的方式给到我们的Video的src属性就可以了Video同时支持

:::



:::color2
以下是完整代码

:::

```typescript
@Entry
@Component
struct VideoCase {
  @State
  speed: number = 1
  controller: VideoController = new VideoController()
  build() {
    Row() {
      Tabs() {
        TabContent() {
          Column({ space: 20 }) {
            Video({
              controller: this.controller,
              currentProgressRate: this.speed,
              src: 'https://vd3.bdstatic.com/mda-pmj5ajqd7p4b6pgb/576p/h264/1703044058699262355/mda-pmj5ajqd7p4b6pgb.mp4?auth_key=1703138418-0-0-618ea72b33be241c96c6cff86c06e080&bcevod_channel=searchbox_feed&cr=1&cd=0&pd=1&pt=4&logid=0018430194&vid=9762003448174112444&abtest=all'
            })
              .width('100%')
              .aspectRatio(1.4)
            Slider({
              value: this.speed,
              min: 0.75,
              step: 0.25,
              max: 2,
              style: SliderStyle.InSet
            })
              .showSteps(true)
              .onChange(value => {
                this.speed = value
              })
            Text(this.speed+"倍速").fontSize(14).textAlign(TextAlign.Center).width('100%')
            Row({ space: 20 }) {
              Button("播放")
                .onClick(() => {
                  this.controller.start()
                })
              Button("暂停")
                .onClick(() => {
                  this.controller.pause()
                })
              Button("移动进度")
                .onClick(() => {
                  this.controller.setCurrentTime(30) // 单位为秒
                })
              Button("结束")
                .onClick(() => {
                  this.controller.stop()
                })
            }
          }
          .width('100%')
        }.tabBar("在线视频")
        TabContent() {
          Video({
            src: $rawfile('travel.mp4')
          })
            .width('100%')
            .aspectRatio(1.4)
        }
        .tabBar("本地视频")
        TabContent(){
          Video({
            src: 'https://m701.music.126.net/20231221132430/02dcbfb2c719c30dbfc644dcc82e8bf2/jdyyaac/obj/w5rDlsOJwrLDjj7CmsOj/31912317338/8cf5/3009/5531/0dbdd12cef8ea1c3f1d00a23bb26becb.m4a'
          }).width('100%')
            .aspectRatio(1.4)

        }.tabBar("音频")
      }
      .animationDuration(300)

    }
    .height('100%')
  }
}
```



<h3 id="SvRVz">2.抖音小案例</h3>
:::color2
+ 接下来我们尝试做一个刷视频的抖音小案例
+ 版权声明-我们以学习参考的目的使用了抖音自媒体的一些短视频，不会用做商用。

:::



:::success
Swiper-可以左右滑动 也可以上下滑动

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703160884204-fa65df5a-1fae-4851-9c60-78c6f986e361.png)

+ 声明类型和数据

```typescript
class VideoItem {
  videoUrl: string = ''
  imgUrl: ResourceStr = ''
  title: string = ""
}

const allData: VideoItem[] = [
  {
    imgUrl: $r('app.media.back'),
    videoUrl: 'https://vd4.bdstatic.com/mda-pmia5y0htmibjej2/576p/h264/1702970058650094297/mda-pmia5y0htmibjej2.mp4?auth_key=1703155514-0-0-a92de0b6c32239b242d0e51b151ee2d6&bcevod_channel=searchbox_feed&cr=1&cd=0&pd=1&pt=4&logid=2714832517&vid=9811936085320099438&abtest=all',
    title: '我们只是拿某站的数据进行一下测试'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '请大家自行准备在线素材',
    videoUrl: 'https://vd4.bdstatic.com/mda-pmjxx4ccc8x719t3/hd/h264/1703111503445924222/mda-pmjxx4ccc8x719t3.mp4?auth_key=1703155561-0-0-e7c32efbedae026e0e17c900bbd0cf55&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2761194416&vid=7476642150019887968&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '你知道冬天的雪是什么颜色吗, 我猜你不知道',
    videoUrl: 'https://vd4.bdstatic.com/mda-pku9q3zt0rzybip0/hd/cae_h264/1701381974031001593/mda-pku9q3zt0rzybip0.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155589-0-0-133df5be4b625ce34e1a75fe3a4baabf&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2789259407&vid=4775310688475056528&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '宝子们，我当众社死了，我竟然在众目睽睽之下完成了自己人生中的第一段程序',
    videoUrl: 'https://vd2.bdstatic.com/mda-pkkf9qb7zksdaqs9/576p/h264/1700564765354260319/mda-pkkf9qb7zksdaqs9.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155630-0-0-9a47a2910e8d5d90b47ba709fa530b5e&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2830328412&vid=8335346471874826776&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '其实老高最爱的是文学，可以在寂静的夜用曼妙的文字勾勒出关于人生，职场，感情的诸多情绪，无奈此生当为程序员',
    videoUrl: 'https://vd2.bdstatic.com/mda-pj8qa65bc9r1v1cf/576p/h264/1696871444324088416/mda-pj8qa65bc9r1v1cf.mp4?auth_key=1703155654-0-0-fdc0ca9c37ec26be3da9809b89e6151c&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2854467125&vid=5483608480722064830&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '当你阅读到这段文字的时候，我早已入睡，当我在睡梦中惊醒，你却早已安然睡去',
    videoUrl: 'https://vd2.bdstatic.com/mda-pmexhyfui3e6rbmd/hd/cae_h264/1702705379314308540/mda-pmexhyfui3e6rbmd.mp4?auth_key=1703155684-0-0-5b0145fb4c2ec2f0d1bbd525ddb3d592&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2884962294&vid=3059586091403538183&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '每个人的内心都有一段独处的幽闭，不可诉说的窒息感孤独感在每当我们沉静下来的时候变愈发强烈',
    videoUrl: 'https://vd3.bdstatic.com/mda-pmbgjjpkihkf7tjd/576p/h264/1702381478247675613/mda-pmbgjjpkihkf7tjd.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155722-0-0-ea3c2453fbbb2cca66b12e9afe3d419f&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2922207105&vid=9050628586030215591&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '如果在未来的某一天，某一个早晨 晚上 瞬间，你会偶然想起多年前的一段往事，其实并不是我们有多怀旧，只是因为我们走过了太多的路',
    videoUrl: 'https://vd2.bdstatic.com/mda-pj7ktq9euqchetdc/cae_h264/1696824500894354779/mda-pj7ktq9euqchetdc.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155751-0-0-fccb0f110a3b447af67eb0feeabf06ad&bcevod_channel=searchbox_feed&pd=1&cr=0&cd=0&pt=4&logid=2951492012&vid=12162674818438199896'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '什么是知己，有个网红说，当你理解所有人的时候，你一定不能被所有人理解，每个人都或多或少的自私，只是或多或少而已',
    videoUrl: 'https://vd3.bdstatic.com/mda-pmh5hr95fg6u8u0k/hd/cae_h264/1702877143957184120/mda-pmh5hr95fg6u8u0k.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155785-0-0-5cfc2be95d00306082c7875a747dd998&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2985314718&vid=2720370579167170031&abtest=all'
  }
]



```

:::color2
上述的imgUrl同学们需要放置一个**<font style="color:#DF2A3F;">back.png和播放图标ic_public_play</font>**在你的resources/base/media目录下

:::



+ 实现代码

```typescript
@Entry
@Component
struct Douyin {
  @State
  list: VideoItem[] = allData
  @Provide
  activeIndex: number  = 0
  build() {
    Swiper() {
      // 循环的数据 抖音的列表数据
      ForEach(this.list, (item: VideoItem, index: number) => {
        // 封装单独的组件实现 Video组件
        PlayVideo({ item, index })
      })
    }
    .index($$this.activeIndex)
    .cachedCount(3)
    .loop(false)
    .indicator(false)
    .vertical(true)
    .width('100%')
    .height('100%')
  }
}

@Component
struct PlayVideo {
  item: VideoItem = new VideoItem()
  index: number = -1
  @Consume
  @Watch("updateActiveIndex")
  activeIndex: number
  controller: VideoController = new VideoController()

  @State
  playIng: boolean = false
  updateActiveIndex () {
    if(this.activeIndex === this.index) {
      // 轮到我播放了
      this.controller.start()
      this.playIng = true
    }else {
      // 否则我不播放
      this.controller.pause()
      this.playIng = false
    }
  }
  build() {
    Stack({ alignContent: Alignment.Bottom }) {
      Column () {
        Video({
          src: this.item.videoUrl,
          controller: this.controller
        }).width('100%')
          .autoPlay(this.index === 0)
          .aspectRatio(1.4)
          .controls(false)
          .onClick(() => {
             if(this.playIng) {
               this.controller.pause()
             }else {
               this.controller.start()
             }
            this.playIng = !this.playIng
          })
      }
      .justifyContent(FlexAlign.Center)
      .backgroundColor(Color.Black)
      .width('100%')
      .height('100%')

      Row () {
        Text(this.item.title)
          .fontColor(Color.White)
          .width('100%')
          .padding(20)
          .fontSize(20)
          .height(150)
          .lineHeight(30)
      }
    }
    .height('100%')
    .width('100%')
  }
}
class VideoItem {
  videoUrl: string = ''
  imgUrl: ResourceStr = ''
  title: string = ""
}

const allData: VideoItem[] = [
  {
    imgUrl: $r('app.media.back'),
    videoUrl: 'https://vd4.bdstatic.com/mda-pmia5y0htmibjej2/576p/h264/1702970058650094297/mda-pmia5y0htmibjej2.mp4?auth_key=1703155514-0-0-a92de0b6c32239b242d0e51b151ee2d6&bcevod_channel=searchbox_feed&cr=1&cd=0&pd=1&pt=4&logid=2714832517&vid=9811936085320099438&abtest=all',
    title: '我们只是拿某站的数据进行一下测试'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '请大家自行准备在线素材',
    videoUrl: 'https://vd4.bdstatic.com/mda-pmjxx4ccc8x719t3/hd/h264/1703111503445924222/mda-pmjxx4ccc8x719t3.mp4?auth_key=1703155561-0-0-e7c32efbedae026e0e17c900bbd0cf55&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2761194416&vid=7476642150019887968&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '你知道冬天的雪是什么颜色吗, 我猜你不知道',
    videoUrl: 'https://vd4.bdstatic.com/mda-pku9q3zt0rzybip0/hd/cae_h264/1701381974031001593/mda-pku9q3zt0rzybip0.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155589-0-0-133df5be4b625ce34e1a75fe3a4baabf&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2789259407&vid=4775310688475056528&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '宝子们，我当众社死了，我竟然在众目睽睽之下完成了自己人生中的第一段程序',
    videoUrl: 'https://vd2.bdstatic.com/mda-pkkf9qb7zksdaqs9/576p/h264/1700564765354260319/mda-pkkf9qb7zksdaqs9.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155630-0-0-9a47a2910e8d5d90b47ba709fa530b5e&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2830328412&vid=8335346471874826776&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '其实老高最爱的是文学，可以在寂静的夜用曼妙的文字勾勒出关于人生，职场，感情的诸多情绪，无奈此生当为程序员',
    videoUrl: 'https://vd2.bdstatic.com/mda-pj8qa65bc9r1v1cf/576p/h264/1696871444324088416/mda-pj8qa65bc9r1v1cf.mp4?auth_key=1703155654-0-0-fdc0ca9c37ec26be3da9809b89e6151c&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2854467125&vid=5483608480722064830&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '当你阅读到这段文字的时候，我早已入睡，当我在睡梦中惊醒，你却早已安然睡去',
    videoUrl: 'https://vd2.bdstatic.com/mda-pmexhyfui3e6rbmd/hd/cae_h264/1702705379314308540/mda-pmexhyfui3e6rbmd.mp4?auth_key=1703155684-0-0-5b0145fb4c2ec2f0d1bbd525ddb3d592&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2884962294&vid=3059586091403538183&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '每个人的内心都有一段独处的幽闭，不可诉说的窒息感孤独感在每当我们沉静下来的时候变愈发强烈',
    videoUrl: 'https://vd3.bdstatic.com/mda-pmbgjjpkihkf7tjd/576p/h264/1702381478247675613/mda-pmbgjjpkihkf7tjd.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155722-0-0-ea3c2453fbbb2cca66b12e9afe3d419f&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2922207105&vid=9050628586030215591&abtest=all'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '如果在未来的某一天，某一个早晨 晚上 瞬间，你会偶然想起多年前的一段往事，其实并不是我们有多怀旧，只是因为我们走过了太多的路',
    videoUrl: 'https://vd2.bdstatic.com/mda-pj7ktq9euqchetdc/cae_h264/1696824500894354779/mda-pj7ktq9euqchetdc.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155751-0-0-fccb0f110a3b447af67eb0feeabf06ad&bcevod_channel=searchbox_feed&pd=1&cr=0&cd=0&pt=4&logid=2951492012&vid=12162674818438199896'
  },
  {
    imgUrl: $r('app.media.back'),
    title: '什么是知己，有个网红说，当你理解所有人的时候，你一定不能被所有人理解，每个人都或多或少的自私，只是或多或少而已',
    videoUrl: 'https://vd3.bdstatic.com/mda-pmh5hr95fg6u8u0k/hd/cae_h264/1702877143957184120/mda-pmh5hr95fg6u8u0k.mp4?v_from_s=hkapp-haokan-hbf&auth_key=1703155785-0-0-5cfc2be95d00306082c7875a747dd998&bcevod_channel=searchbox_feed&pd=1&cr=1&cd=0&pt=4&logid=2985314718&vid=2720370579167170031&abtest=all'
  }
]



```



<h3 id="WuoND">3.绘画能力-画布组件（根据视频自学）</h3>
:::color2
+ ArkUI里面的画布和前端的Canvas的用法基本一致
+ 使用方法

    1. 放置Canvas组件-给宽和高

    2. 初始化画笔对象 CanvasRenderingContext2D，将画笔对象作为构造参数传递给Canvas组件

    3. 可以在Canvas的onReady事件中进行动态绘制

    4. [绘制方法官方文档](https://developer.harmonyos.com/cn/docs/documentation/doc-references-V3/ts-canvasrenderingcontext2d-0000001478181441-V3)

:::

+ 准备好需要的要素

```typescript
@Entry
@Component
struct MyCanvas {
  context: CanvasRenderingContext2D = new CanvasRenderingContext2D()
  build() {
    Row() {
      Column({ space: 20 }) {
         Canvas(this.context)
           .width('100%')
           .aspectRatio(1.2)
           .backgroundColor(Color.Gray)
      }
      .width('100%')
    }
    .height('100%')
  }
}
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703217566688-86012bd7-8f09-4f3f-a4c4-0aa15482166c.png)

+ 尝试画线-画圆-画矩形

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703217622355-4ecf893c-3810-4c63-8200-f64df39f83df.png)

:::color2
+ 因为Canvas的默认起始点坐标是0,0, 其位于画布的左上角，所以我们想要在某个位置画线的时候，需要移动我们的起始坐标点，比如  this.context.moveTo(0,50)，表示将起始坐标点向下移动50个vp

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703226365815-ff01c30c-8c38-4a30-8bd1-88e9fa8b3270.png)

+ 假如我们想要一个闭环的路径-不受任何其他绘制的影响-我们需要在画线之前调用 beginPath表示开始一段绘制- 那么结束之后，我们需要调用closePath表示当前绘制结束，不会把线连到下一个图形中

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703402231212-144fe4fc-1c91-4b2b-b1b2-99c3769f7047.png)

```typescript
  Row({ space: 20 }) {
       Button("画线")
         .onClick(() => {
           // 闭环隔离  开始绘制-结束绘制
           this.context.beginPath()
            this.context.lineWidth = 4 // 线的宽度
            this.context.strokeStyle = 'blue'
            this.context.moveTo(50, 50)
            this.context.lineTo(250, 200)
            this.context.stroke()  // 
           this.context.closePath() // 结束绘制

           this.context.beginPath()
            // 绘制红线
           this.context.strokeStyle = "red"
           this.context.moveTo(50, 240)
           this.context.lineTo(250, 240)
           this.context.stroke()
           this.context.closePath() // 结束绘制
         })
     }
```

:::color2
stroke方法表示进行边框绘制操作-我们连线之后，需要该方法完成最终的绘制

:::

+ 清空面板

```typescript
 Button("清空面板")
            .onClick(() => {
              this.context.clearRect(0, 0, 360,300)
            })
```



+ 画圆

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703226671307-07e40723-a00c-452f-a824-fa58e1d8ea4d.png)

```typescript
  Button("画圆")
            .onClick(() => {
                this.context.lineWidth = 4
                this.context.strokeStyle = "#fff"
                this.context.arc(100, 100, 100, 0, 360)
                this.context.stroke()
            })
```

+ 画矩形

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703227528458-b5fea461-26a3-4402-a7fa-1c7bf363232e.png)

```typescript
  Button("画矩形")
            .onClick(() => {
              this.context.beginPath()
              this.context.lineWidth = 4
              this.context.strokeStyle = "#fff"
              this.context.rect(150, 150, 100, 100)
              this.context.stroke()
              // this.context.fill()
              this.context.closePath()
            })
```

:::color2
因为默认使用画的图当内容过大时，会出现锯齿，我们可以给画笔设置一个属性，实现抗锯齿处理

:::

```typescript
  context: CanvasRenderingContext2D = new CanvasRenderingContext2D(new RenderingContextSettings(true))

```



<h3 id="evdZV">4.你画我猜小游戏（根据视频自学）</h3>


![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703231583349-1d173080-8bef-4ccc-9091-ebb978f1b609.png)



:::color2
接下来，我们来做一个之前qq里面的你画我猜的小游戏，它既是一个签字板，又可以在另一个画板上复原我们在画板上的绘画轨迹

:::

+ 新建一个Page页面，放置上下两块画板

```typescript
@Entry
@Component
struct GuessCanvas {

  build() {
     Column ({ space: 20 }) {
       Canvas()
         .width(360)
         .height(300)
         .backgroundColor(Color.Grey)
       Canvas()
         .width(360)
         .height(300)
         .backgroundColor(Color.Red)

     }
  }
}
```



![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703227975831-3ba2cc6f-7031-49e5-8e6e-e111d0c8827a.png)

:::color2
+ 我们需要在上面的面板作画，所以给上面的画布初始化画笔，加上抗锯齿处理

:::

```typescript
  context: CanvasRenderingContext2D = new CanvasRenderingContext2D(new RenderingContextSettings(true))
  build() {
     Column ({ space: 20 }) {
       Canvas(this.context)
         .width(360)
         .height(300)
         .backgroundColor(Color.Grey)
```

:::color2
+ 接下来需要处理什么时候开始在画板上画的时机问题了
+ Canvas有一个onTouch事件， 里面包含 按下，抬起，移动等事件，我们认为按下，表示开始画，抬起表示动作结束，移动表示正式绘制，尝试用事件来测试一下

:::

```typescript
Canvas(this.context)
         .width(360)
         .height(300)
         .backgroundColor(Color.Grey)
         .onTouch((event: TouchEvent) => {
           if(event.type === TouchType.Down) {
             promptAction.showToast({ message: '开始绘画' })
           }
           if(event.type === TouchType.Move) {
             promptAction.showToast({ message: '绘画中' })
           }
           if(event.type === TouchType.Up) {
             promptAction.showToast({ message: '结束绘画' })
           }
         })
```

:::color2
事件绘画的机制明白之后，我们设置一个状态来控制是否画

:::

```typescript
  drawIng: boolean = false

```

```typescript
  .onTouch((event: TouchEvent) => {
           if(event.type === TouchType.Down) {
             this.drawIng = true
           }
           if(event.type === TouchType.Move) {
             if(this.drawIng) {
               promptAction.showToast({ message: '绘画中' })
             }
           }
           if(event.type === TouchType.Up) {
             this.drawIng = false
           }
         })
```



:::color2
接下来，我们还需要两个变量来记录上一次移动到的画布的坐标点

:::

```typescript
  lastX: number = 0
  lastY: number = 0
```

:::color2
接下来实现一个画线的方法

:::

```typescript
drawLine (x: number, y: number) {
    this.context.moveTo(this.lastX, this.lastY) // 先将线移动到上一个点
    this.context.lineTo(x, y)
    this.lastX = x // 将当前内容的x记录
    this.lastY = y // 将当前的y记录
    this.context.stroke()
  }
```

:::color2
实现该方法之后，我们需要在开始画的时候，beginPath，在结束画的时候，closePath，并且在开始画的时候，把上一个坐标点记录下来，代码如下

:::

```typescript
  Canvas(this.context)
         .width(360)
         .height(300)
         .backgroundColor(Color.Grey)
         .onTouch((event: TouchEvent) => {
           if(event.type === TouchType.Down) {
             this.lastX = event.touches[0].x
             this.lastY = event.touches[0].y
             this.drawIng = true
             this.context.beginPath()
           }
           if(event.type === TouchType.Move) {
             if(this.drawIng) {
               this.drawLine(event.touches[0].x, event.touches[0].y)
             }
           }
           if(event.type === TouchType.Up) {
             this.drawIng = false
             this.context.closePath()
           }
         })
         .onReady(() => {
           this.context.lineWidth = 4
           this.context.strokeStyle = "#fff"
         })
```

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703229149751-c687b958-5eeb-4e11-bd23-ed20d396a91c.png)



:::color2
接下来实现你画我猜-在我们上方画的时候，可以把标点存入一个数组，然后下面的绘画利用从坐标点取参数进行绘制

:::

+ 定义一个坐标点class

```typescript
class PointClass {
  x: number = 0
  y: number = 0
  reset?: boolean = false
}
```

+ 声明一个存储坐标点的状态数据-不用State修饰符

```typescript
  pointList: PointClass[] = []

```

+ 在画点时将点画进去，同时还要记录当前是不是重新开始一个路径

:::color2
因为上面的画板的绘制有可能是不连续的，会导致绘画是不连续的动作，所以需要给我们的class一个属性，标记为是否需要重新开始路径

:::

```typescript
 .onTouch((event: TouchEvent) => {
           if(event.type === TouchType.Down) {
             this.lastX = event.touches[0].x
             this.lastY = event.touches[0].y
             this.drawIng = true
             this.context.beginPath()
             this.pointList.push({
               x: this.lastX,
               y: this.lastY,
               reset: true
             })
           }
           if(event.type === TouchType.Move) {
             if(this.drawIng) {
               this.pointList.push({
                 x: event.touches[0].x,
                 y: event.touches[0].y,
                 reset: false
               })
               this.drawLine(event.touches[0].x, event.touches[0].y)
             }
           }
           if(event.type === TouchType.Up) {
             this.drawIng = false
             this.context.closePath()
           }
         })
```

:::color2
+ 我们需要当上方绘制开始的时候，就启动下面的模仿图
+ 给下面的画布同样的一个画笔对象，同样的抗锯齿处理

:::

```typescript
  guessContext: CanvasRenderingContext2D = new CanvasRenderingContext2D(new RenderingContextSettings(true))

```

+ 实现一个延时函数，从我们的数组中开始取坐标，进行绘制

```typescript
gLastX: number = 0
gLastY: number = 0
timer: number = -1
drawGuess() {
    if (this.pointList.length && this.timer === -1) {
      this.timer = setInterval(() => {
        if (this.pointList.length === 0) {
           clearInterval(this.timer)
          this.timer = -1
          return
        }
        let p: PointClass = this.pointList.shift()
        this.guessLine(p)
      }, 100)
    }
  }
  guessLine (p: PointClass) {
    if(p.reset) {
      this.guessContext.closePath()
      this.guessContext.beginPath()
      this.gLastX = p.x
      this.gLastY = p.y
    }else {
      this.guessContext.moveTo(this.gLastX, this.gLastY) // 先将线移动到上一个点
      this.guessContext.lineTo(p.x, p.y)
      this.gLastX = p.x // 将当前内容的x记录
      this.gLastY = p.y // 将当前的y记录
      this.guessContext.stroke()
    }
  }
```



:::color2
+ 等到上方结束绘制之后，下面还是模仿

:::

```typescript
 if(event.type === TouchType.Up) {
             this.drawIng = false
             this.context.closePath()
             // 开始模仿
             this.drawGuess()
           }
```



:::color2
+ 实现清理画布和存储图片方法

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703231280573-e2363888-b860-4798-9690-913c3ba526bc.png)



+ 清屏方法

```typescript
 Button("清屏")
           .onClick(() => {
             this.context.clearRect(0,0, 360,300)
             this.guessContext.clearRect(0,0, 360,300)
             this.pointList = []
           })
```

+ 存储图片

:::color2
存储图片是将canvas转化成base64

:::

![](https://cdn.nlark.com/yuque/0/2023/png/8435673/1703231501594-a75bfad4-be04-4be5-9145-ff54a418239c.png)

```typescript
 Button("存储图片")
          .onClick(() => {
            this.imgStr = this.context.toDataURL("image/jpeg")
          })
```



+ 完整代码

```typescript
import promptAction from '@ohos.promptAction'

@Entry
@Component
struct GuessCanvas {
  context: CanvasRenderingContext2D = new CanvasRenderingContext2D(new RenderingContextSettings(true))
  guessContext: CanvasRenderingContext2D = new CanvasRenderingContext2D(new RenderingContextSettings(true))
  drawIng: boolean = false
  lastX: number = 0
  lastY: number = 0
  gLastX: number = 0
  gLastY: number = 0
  pointList: PointClass[] = []
  timer: number = -1
  @State
  imgStr: string = ""

  drawLine(x: number, y: number) {
    this.context.moveTo(this.lastX, this.lastY) // 先将线移动到上一个点
    this.context.lineTo(x, y)
    this.lastX = x // 将当前内容的x记录
    this.lastY = y // 将当前的y记录
    this.context.stroke()
  }

  drawGuess() {
    if (this.pointList.length && this.timer === -1) {
      this.timer = setInterval(() => {
        if (this.pointList.length === 0) {
           clearInterval(this.timer)
          this.timer = -1
          return
        }
        let p: PointClass = this.pointList.shift()
        this.guessLine(p)
      }, 100)
    }
  }

  guessLine(p: PointClass) {
    if (p.reset) {
      this.guessContext.closePath()
      this.guessContext.beginPath()
      this.gLastX = p.x
      this.gLastY = p.y
    } else {
      this.guessContext.moveTo(this.gLastX, this.gLastY) // 先将线移动到上一个点
      this.guessContext.lineTo(p.x, p.y)
      this.gLastX = p.x // 将当前内容的x记录
      this.gLastY = p.y // 将当前的y记录
      this.guessContext.stroke()
    }
  }

  build() {
    Scroll() {
      Column({ space: 20 }) {
        Canvas(this.context)
          .width(360)
          .height(300)
          .backgroundColor(Color.Grey)
          .onTouch((event: TouchEvent) => {
            if (event.type === TouchType.Down) {
              this.lastX = event.touches[0].x
              this.lastY = event.touches[0].y
              this.drawIng = true
              this.context.beginPath()
              this.pointList.push({
                x: this.lastX,
                y: this.lastY,
                reset: true
              })

            }
            if (event.type === TouchType.Move) {
              if (this.drawIng) {
                this.pointList.push({
                  x: event.touches[0].x,
                  y: event.touches[0].y,
                  reset: false
                })
                this.drawLine(event.touches[0].x, event.touches[0].y)
              }
            }
            if (event.type === TouchType.Up) {
              this.drawIng = false
              this.context.closePath()
              // 开始模仿
              this.drawGuess()
            }
          })
          .onReady(() => {
            this.context.lineWidth = 4
            this.context.strokeStyle = "blue"
          })
        Canvas(this.guessContext)
          .width(360)
          .height(300)
          .backgroundColor(Color.Red)
          .onReady(() => {
            this.guessContext.lineWidth = 4
            this.guessContext.strokeStyle = "#fff"
          })
        Row({ space: 20 }) {
          Button("清屏")
            .onClick(() => {
              this.context.clearRect(0, 0, 360, 300)
              this.guessContext.clearRect(0, 0, 360, 300)
              this.pointList = []
            })
          Button("存储图片")
            .onClick(() => {
              this.imgStr = this.context.toDataURL("image/jpeg")
            })
        }

        if (this.imgStr) {
          Image(this.imgStr)
            .width(360)
            .height(300)
        }
      }
    }

  }
}

class PointClass {
  x: number = 0
  y: number = 0
  reset?: boolean = false
}
```

<h1 id="lvJ19"></h1>
