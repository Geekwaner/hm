:::color1
上课代码完整仓库：[https://gitee.com/shuiruohanyu/heima_cloud_music](https://gitee.com/shuiruohanyu/heima_cloud_music)

基础模板仓库地址:  [https://gitee.com/shuiruohanyu/music_player_template](https://gitee.com/shuiruohanyu/music_player_template)

:::

<h1 id="feAbV">项目演示</h1>
1. 广告页

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705489945803-26118a94-df29-4ae4-84d4-fa3f90b31e7c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [x] 5秒倒计时，进入首页
2. 首页

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705490028010-ae566d99-04c5-49af-9d8d-0dbad5fad45c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [x] 展示搜索框
        - [x] 展示轮播图
        - [x] 展示每日推荐列表
        - [x] 展示推荐歌单列表
        - [ ] 支持背景播放，点击背景播放进入播放页面
3. 发现

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705490039873-3fa87eb4-724f-436b-8da2-8fe65c7f7210.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [x] 展示发现列表歌曲
        - [ ] 点击列表歌曲播放整个列表歌曲
        - [ ] 支持背景播放，点击背景播放进入播放页面
4. music

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705490058903-8307f39d-f6d6-4a5a-bd6f-aa44406d0d2e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [x] 展示我喜欢的音乐
        - [ ] 点击列表歌曲播放单首歌曲
        - [ ] 点击播放全部播放列表歌曲
        - [ ] 支持背景播放，点击背景播放进入播放页面
5. 动态

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705494838760-e6be6347-ceff-4920-beae-5b46cd81be17.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [x] 展示动态列表
        - [ ] 点击动态歌曲播放单首歌曲
        - [ ] 支持背景播放，点击背景播放进入播放页面
6. 我的

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705494911236-c4742723-f54d-4ff6-93ba-b5e8cc88fb61.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [x] 展示我的页面
        - [x] 展示4列历史播放歌曲
        - [x] 每列歌曲随机排序，支持滚动
        - [ ] 点击歌曲封面可以播放单首歌曲
        - [ ] 当前播放歌曲展示播放中状态
7. 播放

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705494953653-3a4fc448-e528-41f7-9b98-c9b692f47079.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [ ] 展示当前播放歌曲信息
        - [ ] 播放歌曲是背景霓虹灯效果，文字破坏风效果
        - [ ] 支持暂停、播放切换
        - [ ] 支持歌曲切换，进度切换，播放模式切换
        - [ ] 点击显示当前播放列表，可以左滑删除列表歌曲
8. 卡片

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705495036200-9fdc2a74-6e2b-457f-ba36-b4b170738e49.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_12%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

功能描述：

        - [ ] 支持添加应用卡片
        - [ ] 展示当前播放信息
        - [ ] 应用切换歌曲，卡片更新
        - [ ] 点击歌曲封面可以进入应用
        - [ ] 可以切换上一首，下一首

<h1 id="ANOuY">核心技术</h1>
+ 播放功能
    - 播放：播放当前正在播放的歌曲
    - 暂停：暂停播放当前正在播放的歌曲
    - 上一首：切换列表上一首歌曲（只有一首重复播放）
    - 下一首：切换列表下一首歌曲（只有一首重复播放）
    - 播放模式：支持列表循环、单曲播放、随机播放三种模式
    - 进度切换：可以拖拽或点击控制歌曲播放的时间节点
    - 单曲播放：支持添加一首歌进行播放
    - 列表播放：支持添加列表进行播放
    - 播放列表：可以添加，删除播放列表中的歌曲
+ 卡片功能
    - 应用数据展示：展示当前播放歌曲信息
    - 网络图片展示：网络图片下载工具封装，下载网络图片到卡片展示
    - 卡片通信机制：卡片与应用持久化双向通信模型



**大厂APP对比**：

| 应用名称 | 鸿蒙端 | 卡片 | 通信 | 断点续播 | 个性化 |
| :---: | :---: | :---: | :---: | :---: | :---: |
| 网易云 | - [x]  | - [x]  | - [ ]  | - [x]  | - [ ]  |
| 酷狗 | - [x]  | - [x]  | - [x]  | - [ ]  | - [ ]  |
| 汽水 | - [ ]  | - [ ]  | - [ ]  | - [ ]  | - [x]  |
| 黑马云 | - [x]  | - [x]  | - [x]  | - [x]  | - [x]  |




<h1 id="cXWvY">进度安排</h1>
+ 项目搭建+功能分析+播放功能+线程通信
+ 卡片开发+下载工具封装+进程通信

<h1 id="Emxfu">起步-项目搭建</h1>
:::success
基础交互+跳转+动画 在模板中已经给大家准备好

:::

为了在有限的时间，能讲更多的干货，静态界面的使用准备好的工程

:::color2
基础模板地址：[https://gitee.com/shuiruohanyu/cloud_music_templatge.git](https://gitee.com/shuiruohanyu/cloud_music_templatge.git)

:::



**注意：****<font style="color:rgba(194,0,17,1);">下载的目录路径不能含中文</font>**

<h3 id="fuCUA">结构预览</h3>
准备好基本项目工程-预览基本结构



:::color2
ets

   --components             #公共组件

   --constant                  #常量

       --MusicContstants.ets # 静态音乐数据

   --entryability               #ability

       --EntryAbility.ets     #入口Ability

   --entryformability        #ability

       --EntryFormAbility   #卡片Ability

   --models                    #类型

       --index.ets              #管理统一导出

       --music.ets             #音乐类型

   --pages                      #页面

       --Find                     #发现

       --Index                   #首页

       --Mine                    #我的

       --Moment                #动态

       --Play                      #播放

       --Recommend          #推荐

       --SongList               #music

       --Start                    #广告页

  

:::

<h3 id="TuP2D">起步-功能分析</h3>
预览各个页面的核心共能后发现，播放几乎贯穿了整个项目

:::color2
之前微信项目的播放是采用pcm音频的录制和播放，并且采用了avplayer播放常见音频，音乐播放器的播放和之前有何不同呢？

<font style="color:rgba(194,0,17,1);">音乐播放器，需要暂停，指定进度播放，播放多资源，切换资源等，功能更复杂了</font>

以我们单纯的用AVPlayer已经不能支持我们的业务复杂度了，需要自己进行二次封装

:::

在开始前，先想好我们的**播放器**都有哪些东西，避免前期设计缺陷导致后面功能无法拓展![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715658308754-a3eed381-5475-4e6f-86ac-6722a460771d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705816897719-cf7121ac-61ea-4640-9cb5-c9848635a23f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_25%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705816950948-d2914eba-38ab-4c14-8f1a-7ab5d4699dc8.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_24%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)



> **<font style="color:rgba(194,0,17,1);">整个播放器的功能梳理完成后，我们还要想清楚，播放器应该存放在哪里？</font>**
>

:::color2
播放功能几乎各个页面都用到了，而且都是双向控制的，所以我们应该设计一个通用的播放器，让各个页面能进行导入使用，这里更适合**单例模式**

:::

+ 创建播放器文件

:::color2
采用单例模式，创建utils/AvPlayerManager.ets的单例播放类

:::

```arkts
// 播放器静态类
export default class AvPlayerManager {
    
}
```

+ 功能实现思路

整个播放器的**功能**和**属性**非常的多，如果一上来就在工具类中声明过多的属性和方法容易影响我们的思路，所以我们应该**由易到难**的实现功能，从而不断丰富我们的工具类

:::color2
实现**思路分析**：

1. 播放功能
2. 获取歌曲播放信息
3. 歌曲列表和播放序号
4. 更新播放信息至各页面
5. 播放时的动画
6. 暂停/播放
7. 切换播放进度
8. 切换播放模式
9. 上一首/下一首
10. 切换和删除列表中的歌曲
11. 缓存播放信息
12. 功能完善
13. 性能优化
14. 搭建卡片页面
15. 卡片ID存储
16. 播放器通知卡片
17. 下载网络图片至卡片
18. 卡片通知应用

:::



<h1 id="P7L7A">开发-播放功能</h1>
1. **技术选型**

要想实现音频播放功能，目前支持的解决方案有：**Video、AVPlayer、AudioRenderer、OpenSL ES**

| 名称 | 优势 | 劣势 | 是否选择 |
| :---: | --- | :---: | :---: |
| **Video** | 简单易上手 | 更适合视频播放 | - [ ]  |
| **AVPlayer** | 流程完整，易上手 | 多音频合并，录音等功能支持不完善 | - [x]  |
| **AudioRenderer** | 最全面的音乐解决方案 | 适合有开发经验的人，过于重量级 | - [ ]  |
| **OpenSL ES** | 跨平台、<font style="color:rgba(0, 0, 0, 0.9);">免费</font> | HarmonyOS当前仅实现部分接口 | - [ ]  |




> 通过分析对比，这里我们选择**<font style="color:#DF2A3F;">AVPlayer</font>**来进行音频的播放
>



先来认识一下AVPlayer的工作流程，下图是官方给的示例：

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705819539286-53c5c161-542e-4e70-bf40-bc411f4a2133.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_42%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)





翻译一下：

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705958133093-af1a7468-c787-495a-b71b-b7d69df59cee.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_29%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**总结：**

前提：需要先创建播放器

核心：监听播放器状态，在对应的状态执行达成下一步的动作



2. **创建播放器**

回到播放器工具类中，进行播放器的创建

```arkts
import media from '@ohos.multimedia.media'

export class AvPlayerManager {
  // 创建的播放器应该存在我们的工具类上，这样才能被导出使用
  static player: media.AVPlayer | null = null
  // 创建播放器的方法
  static async  init() {
    if(!AvPlayerManager.player) {
      AvPlayerManager.player = await media.createAVPlayer()
    }
  }
}
```

+ 在进入应用时初始化音乐播放器

```arkts
 onWindowStageCreate(windowStage: window.WindowStage) {
    // Main window is created, set main page for this ability
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageCreate');
    AvPlayerManager.init()
   
  }
```



此时我们已经完成了播放器的创建，播放器的状态为闲置，接下来可以进行播放源的设置了



3. **播放歌曲**

准备一个播放的方法，设置播放的`url`，点击列表时进行调用

设置完播放源后播放器会进入**准备**状态，此时我们需要执行**播放**的动作，如何知道**当前的状态**呢？

**<font style="color:rgba(194,0,17,1);">需要让播放器进行状态监听！</font>**

```arkts
// 用来播放音乐 切换音乐 暂停音乐 进度调整 后台播放音乐
import media from '@ohos.multimedia.media'
import { songItemType } from '../models'

export class AvPlayerManager {
  static player: media.AVPlayer | null = null // 播放器对象
  // 初始化播放器
  static async init() {
    // 保证当前只有一个播放器 不重复创建不浪费资源
    if (!AvPlayerManager.player) {
      AvPlayerManager.player = await media.createAVPlayer()
    }
    AvPlayerManager.player.on("stateChange", (state) => {
       switch (state) {
         case  "initialized":
           AvPlayerManager.player?.prepare() // 准备
         break;
         case "prepared":
           AvPlayerManager.player?.play() // 播放
         break;
       }
    })
  }

  // 点击某个歌曲播放
  static singlePlay(song: songItemType) {
    AvPlayerManager.player!.url = song.url // 赋值
  }
}
```

此时，我们就已经能进行单首歌曲的播放了

<h3 id="B75QL">获取歌曲播放信息</h3>
:::color2
在models/playState.ets中声明一个记录当前播放器当前歌曲的对象

:::

```typescript
// 传输数据的结构
import { songItemType } from './music';

export class PlayStateType {
  img: string = "" // 音乐封面
  name: string = "" // 音乐名称
  author: string = "" // 作者
  url: string = "" // 当前播放连接
  playIndex: number =  0 // 当前在播放列表中的播放索引
  time: number = 0 // 播放时间
  duration: number = 0 // 音乐的播放时长
  isPlay: boolean = false // 是否正在播放
  playMode: 'auto' | 'repeat' | 'random' = "auto" // 播放模式
  playList: songItemType[] = [] // 当前的播放列表
  cacheImg?: string // 缓存图片地址
}


```

+ 在models/index.ets中导出

```typescript
export * from './playState'
```

+ 在AvPlayer中声明一个记录当前歌曲的静态变量

```typescript
  static currentSong: PlayStateType = new PlayStateType()
```

:::color2
歌曲信息中并未包含歌曲的时长，我们需要知道如下信息

+ 歌曲时长
+ 当前播放时长
+ 播放器状态
+ 播放模式

:::

1. **获取歌曲时长**

获取歌曲时长的方式有两种：

:::color2
+ 直接从播放器中读取
+ 监听歌曲时长

:::



**因为当前播放的歌曲可能会****发生变化****，所以之间从播放器之前我们已经监听了播放器的播放状态，这里我们同样可以****监听****歌曲时长的状态**

```arkts
import media from '@ohos.multimedia.media'
import { songItemType, PlayStateType } from '../models/music'

export class AVPlayerClass {
  // 创建的播放器应该存在我们的工具类上，这样才能被导出使用
  static player: media.AVPlayer | null = null
  static currentSong: PlayStateType = new PlayStateType() // 当前歌曲的状态
  // 创建播放器的方法
  static async init() {
    if (!AVPlayerClass.player) {
      AVPlayerClass.player = await media.createAVPlayer()
    }
    // 监听状态
    AVPlayerClass.player.on('stateChange', (state) => {
      switch (state) {
      // 初始化
        case 'initialized':
          AVPlayerClass.player!.prepare()
          break
      // 准备
        case 'prepared':
          AVPlayerClass.player!.play()
          break
      }
    })
    //  监听歌曲时长
    AVPlayerClass.player.on('durationUpdate',(duration)=>{
      // 每次切换歌曲都会触发这个函数，更新即可
      AVPlayerClass.currentSong.duration = duration
    })
  }

  // 单首歌播放
  static singlePlay(song: songItemType) {
    AVPlayerClass.player!.url = song.url
  }
}
```

****

2. **获取当前播放时长**

同样的，我们也需要监听当前播放的时长，来进行更新

```arkts
import media from '@ohos.multimedia.media'
import { songItemType } from '../models/music'

export default class AvPlayerManager {
  // 创建的播放器应该存在我们的工具类上，这样才能被导出使用
  static player: media.AVPlayer | null = null
  static currentSong: PlayStateType = new PlayStateType() // 当前歌曲的状态

  // 创建播放器的方法
  static async init() {
    if (!AvPlayerManager.player) {
      AvPlayerManager.player = await media.createAVPlayer()
    }
    // 监听状态
    AvPlayerManager.player.on('stateChange', (state) => {
      switch (state) {
      // 初始化
        case 'initialized':
          AvPlayerManager.player!.prepare()
          break
      // 准备
        case 'prepared':
          AvPlayerManager.player!.play()
          AvPlayerManager.currentSong.isPlay = true // 播放状态
          break
      }
    })
     //  监听歌曲时长
    AvPlayerManager.player.on('durationUpdate', (duration) => {
      // 每次切换歌曲都会触发这个函数，更新即可
      AvPlayerManager.currentSong.duration = duration
    })
   //  监听播放时长
    AvPlayerManager.player.on('timeUpdate', (time) => {
      AvPlayerManager.currentSong.time = time
    })
  }
  // 单首歌播放
  static singlePlay(song: songItemType) {
    AvPlayerManager.player.url = song.url
  }
}
```



<h3 id="Dch0Q">开发-歌曲列表和播放序号</h3>
:::color1
需要同步给页面的还有歌曲的名称，作者，图片等信息，但是这些不需要记录在播放器中，这些信息可以在歌曲信息中找到，那我们要记录当前播放的歌曲信息吗？

是，但不只是记录当前，播放过的歌曲应该被记录进**播放列表**中，我们只要知道播放的是列表中的**第几首歌**，就能找到这首歌的信息了

:::



![](https://cdn.nlark.com/yuque/0/2024/gif/34522383/1705934221834-3a9d1ec6-b360-4fe5-a98d-0f2718447cc7.gif)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715690852599-ff3dc8e7-d0d3-43f3-b15e-80cacc724e1d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

1. **记录当前播放的顺序和判断播放重复**

```arkts
  // 单首歌播放
  static singlePlay(song: songItemType) {
    // 添加到播放列表中，再进行播放
    const isList = AvPlayerManager.currentSong.playList.some((item: songItemType) => item.id === song.id)
    if (isList) {
      // 是不是正在播放的
      if (AvPlayerManager.player!.url === song.url) {
        // 重新播放（切换当前播放索引的歌曲）
        // 如果是同一首 则继续播放
        AvPlayerManager.player?.play()
        AvPlayerManager.currentSong.isPlay = true
      } else {
        // 切换歌曲(更新播放索引切换歌曲)
        AvPlayerManager.currentSong.playIndex = AvPlayerManager.currentSong.playList.findIndex((item: songItemType) => item.id === song.id)
        AvPlayerManager.changePlay()
      }
    } else {
      AvPlayerManager.currentSong.playList.unshift(song)
      AvPlayerManager.currentSong.playIndex = 0
      AvPlayerManager.changePlay()
    }

  }

// 切换歌曲
  static async changePlay() {
    // 重置播放器状态至初始化,异步方法
    await AvPlayerManager.player!.reset()
    // 重置播放状态
    AvPlayerManager.currentSong.duration = 0
    AvPlayerManager.currentSong.time = 0
    AvPlayerManager.player!.url =   AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex].url
    AvPlayerManager.currentSong.img =   AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex].img
    AvPlayerManager.currentSong.name =   AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex].name
    AvPlayerManager.currentSong.author =   AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex].author
    AvPlayerManager.currentSong.url =   AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex].url
  }
```





****

**<font style="color:rgba(194,0,17,1);">思考2：如果我们点击已经添加过的歌曲不是会再添加一次？如果添加的正在播放的歌曲呢？</font>**

我们需要在**添加**的时候进行判断，**是否为列表中的歌曲**，**和播放的歌曲是否为同一首歌**

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1705961817625-8ebc7cc1-0d9c-4b07-a8e8-492df06893f3.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_23%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

<h3 id="Yoqmu">开发-更新播放信息至各页面</h3>
:::color1
鸿蒙官方文档说：建议不要用AppStorage替代emitter来使用、

因为播放器同时只能播放一首歌曲

:::

:::color2
使用AppStorage将状态更新到全局状态-保证全局状态只有一个正在播的歌曲和其相关信息

:::

+ 设置一个常量用于当前歌曲的状态更新

```typescript
export const SONG_KEY: string = "song_key"
```

+ 由于页面需要实时展示歌曲的播放进度，所以我们应该在监听到播放进度发生变化时就通知页面

```typescript
  //  监听播放时长
      AvPlayerManager.player.on('timeUpdate', (time) => {
        AvPlayerManager.currentSong.time = time
      AppStorage.setOrCreate<PlayStateType>(SONG_KEY, AvPlayerManager.currentSong) // 更新全局状态
    })
```

+ 播放的时候更新状态到全局状态

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1716881067326-e5af8518-1959-45dc-8c6b-0e2197beb3ef.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_70%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 在playNav播放组件中接收播放状态

```arkts
  @StorageLink(SONG_KEY)
  playState: PlayStateType = new PlayStateType()
```

:::color2
根据状态进行判断播放组件是否显示

+ 当前播放列表长度不为0
+ 当前tab不是我的页面

:::

```arkts
 // 背景播放
        PlayerNav()
          .translate({ y: -60 })
          .onClick(() => {
            router.pushUrl({
              url: 'pages/Play/Play'
            })
          })
          .visibility(this.playState.playList.length > 0 && this.currentName !== 'mine' ? Visibility.Visible : Visibility.Hidden)
```

+ 根据当前是否播放控制显示图片

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715759211655-d9bf0697-781f-43af-951a-0b68aaaf2fe1.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_65%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

<h3 id="cPvmu">开发-暂停/播放</h3>
:::color2
播放组件

:::

+ 给AvPlayerManager添加一个pause方法

```arkts
// 暂停播放
  static pause(){
      AvPlayerManager.player!.pause()
    // 更新播放器状态
      AvPlayerManager.currentSong.isPlay = false
    AppStorage.set<PlayStateType>(SONG_KEY,   AvPlayerManager.currentSong) // 更新到
  }
```

+ 播放组件进行播放或者暂停的切换

```arkts
 Image(this.playState.isPlay ? $r('app.media.ic_paused') : $r('app.media.ic_play'))
          .fillColor('#4cafc6')
          .width(20)
          .onClick(() => {
            if(!this.playState.isPlay) {
                AvPlayerManager.singlePlay(this.playState.playList[this.playState.playIndex])
            }else {
                AvPlayerManager.pause()
            }

    })
```

:::color2
播放页面 pages/Play/Play.ets

:::

+ 使用全局状态

```arkts
@StorageLink(SONG_KEY)
  @Watch('changeAnimate')
  playState: PlayStateType = new PlayStateType()
```

+ 播放音乐/暂停音乐/开始动画/暂停动画

```arkts
 Image(this.playState.isPlay ? $r('app.media.ic_paused') : $r('app.media.ic_play'))
                  .fillColor(Color.White)
                  .width(50)
                  .onClick(() => {
                    // 如果能点才执行逻辑
                    if (!this.playState.isPlay) {
                        AvPlayerManager.singlePlay(this.playState.playList[this.playState.playIndex])
                      this.animatorResult.play()
                    } else {
                        AvPlayerManager.pause()
                      this.animatorResult.pause()
                    }
                  })
```

+ 初始化判断播放状态，如果正在播放，则开始动画

```typescript
async aboutToAppear() {
    // 从首选项加载数据
    if(this.playState.isPlay) {
       this.animatorResult.play()
    }
    this.animatorResult.onframe = (val) => {
      this.rotateAngle = val
    }

  }
```

+ 监听动画处理-如果正在播放-随机改变背景色-如果暂停-暂停动画

```typescript
 @StorageLink(SONG_KEY)
  @Watch("changeAnimate")
  playState: PlayStateType = new PlayStateType()

  changeAnimate() {
    if (this.playState.isPlay) {
      // 播放状态
      this.randomColor =
        `rgb(${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)})`
      this.randomShakenX = 2 - Math.random() * 4
      this.randomShakenY = 2 - Math.random() * 4
    } else {
      this.randomColor = 'rbg(0,0,0)'
      this.randomShakenX = 0
      this.randomShakenY = 0
      this.animatorResult.pause()
    }
  }

```

<h3 id="rX99t">开发-进度处理</h3>
+ 给Slider赋值当前的进度和整体时长

```typescript
 Slider({
                  value: this.playState.time,
                  min: 0,
                  max: this.playState.duration
                })
```

+ 拖动进度时，通过avplayer的seek方法拖动进度

```typescript
 Slider({
                  value: this.playState.time,
                  min: 0,
                  max: this.playState.duration
                })
                  .layoutWeight(1)
                  .blockColor(Color.White)
                  .selectedColor(Color.White)
                  .trackColor('#ccc5c5c5')
                  .trackThickness(2)
                  .onChange((val) => {
                      AvPlayerManager.player!.seek(val)
                  })
```

+ 显示音乐整体时长

```typescript
  Text(this.number2time(this.playState.duration))
                  .fontSize(12)
                  .fontColor(Color.White)
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715764204004-5951395d-d478-45f0-9a0d-2345ded5680e.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)



<h3 id="dLiGH">开发-切换播放模式</h3>
+ 点击切换模式

```arkts
if (this.playState.playMode === 'auto') {
                  Image($r("app.media.ic_auto"))
                    .fillColor(Color.White)
                    .width(30)
                    .onClick(() => {
                      this.playState.playMode = 'repeat'
                    })
                } else if (this.playState.playMode === 'repeat') {
                  Image($r("app.media.ic_repeat"))
                    .fillColor(Color.White)
                    .width(30)
                    .onClick(() => {
                      this.playState.playMode = 'random'
                    })
                } else if (this.playState.playMode === 'random') {
                  Image($r("app.media.ic_random"))
                    .fillColor(Color.White)
                    .width(30)
                    .onClick(() => {
                      this.playState.playMode = 'auto'
                    })
                }
```

+ 播放列表中点击播放

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715769202148-f3a3fefa-2f8f-403a-ae8b-41294a8a3d65.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_45%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)



<h3 id="r7Leb">开发-上一首/下一首</h3>
:::color2
根据播放模式的不同，切换的结果也有不同

:::

+ 封装上一首和下一首的方法

```arkts
  // 上一首
  static prevPlay() {
    // 如果是随机播放
    if (AvPlayerManager.currentSong.playMode === "random" &&  AvPlayerManager.currentSong.playList.length) {
      AvPlayerManager.currentSong.playIndex = Math.floor(Math.random() * AvPlayerManager.currentSong.playList.length)
    } else {
      AvPlayerManager.currentSong.playIndex--
      // 有可能减到负数
      AvPlayerManager.currentSong.playIndex =
        (AvPlayerManager.currentSong.playIndex + AvPlayerManager.currentSong.playList.length) %
        AvPlayerManager.currentSong.playList.length
    }
    AvPlayerManager.singlePlay(  AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex])
  }

  // 下一首
  static nextPlay(repeat?: boolean) {
    if (!AvPlayerManager.currentSong.playList.length) {
      return
    }
    if(!repeat) {
      if (AvPlayerManager.currentSong.playMode === "random" &&   AvPlayerManager.currentSong.playList.length) {
        AvPlayerManager.currentSong.playIndex = Math.floor(Math.random() * AvPlayerManager.currentSong.playList.length)
      } else {
        AvPlayerManager.currentSong.playIndex++
        // 有可能减到负数
        AvPlayerManager.currentSong.playIndex =
          (AvPlayerManager.currentSong.playIndex +   AvPlayerManager.currentSong.playList.length) %
          AvPlayerManager.currentSong.playList.length
      }
    }

    AvPlayerManager.singlePlay(AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex])
  }
```



:::color2
上述代码是手动切换，当我们的音乐播放完毕时，其实要自动切换，所以监听下播放状态，自动切换

:::

```typescript
   AvPlayerManager.player.on('stateChange', (state) => {
      switch (state) {
      // 初始化
        case 'initialized':
            AvPlayerManager.player!.prepare()
          break
      // 准备
        case 'prepared':
            AvPlayerManager.player!.play()
            AvPlayerManager.currentSong.isPlay = true // 播放状态
          break
        case "completed":
            AvPlayerManager.nextPlay(AvPlayerManager.currentSong.playMode === "repeat")
          break
      }
    })
```

+ 在
+ 在播放页面切换上一首-下一首

```typescript
// 前一首
                Image($r('app.media.ic_prev'))
                  .fillColor(Color.White)
                  .width(30)
                  .onClick(() => {
                      AvPlayerManager.prevPlay()
                  })
 // 下一首
                Image($r('app.media.ic_next'))
                  .fillColor(Color.White)
                  .width(30)
                  .onClick(() => {
                      AvPlayerManager.nextPlay()
                  })
```

+ 播放组件切换上一首-下一首

```typescript
 Image($r("app.media.ic_prev"))
          .width(20)
          .aspectRatio(1)
          .fillColor('#4cafc6')
          .onClick(() => {
              AvPlayerManager.prevPlay()
          })

 Image($r('app.media.ic_next'))
          .width(20)
          .aspectRatio(1)
          .fillColor('#4cafc6')
          .onClick(() => {
              AvPlayerManager.nextPlay()
          })
```

<h3 id="Y0FX3">开发-切换和删除列表中的歌曲</h3>
:::color2
删除播放列表的歌曲

:::

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715830020669-b28f63d4-cbd4-4973-b363-685ad20ee6b0.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 在工具播放中定义删除方法

```typescript
  // 删除播放
  static async remove (index: number) {
    if (AvPlayerManager.currentSong.playIndex === index) {
      // 是否删除正在播放的歌曲
      if(AvPlayerManager.currentSong.playList.length > 1) {
        // 如果当前的歌曲列表超过两个
          AvPlayerManager.currentSong.playList.splice(index, 1)
          AvPlayerManager.currentSong.playIndex = (  AvPlayerManager.currentSong.playIndex +   AvPlayerManager.currentSong.playList.length) %   AvPlayerManager.currentSong.playList.length
          AvPlayerManager.singlePlay(  AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex])
      }else {
        await   AvPlayerManager.player!.reset()
          AvPlayerManager.currentSong = new PlayStateType() // 重置数据
        router.back()
      }

    }else {
      // 如果不是
      if (AvPlayerManager.currentSong.playIndex > index) {
          AvPlayerManager.currentSong.playIndex--
      }
        AvPlayerManager.currentSong.playList.splice(index, 1)
    }
    AppStorage.setOrCreate<PlayStateType>(SONG_KEY,   AvPlayerManager.currentSong) // 更新全局状态

  }
```

+ 在Play组件中点击删除时调用

```typescript
@Builder
  deleteButton(index: number) {
    Button('删除')
      .backgroundColor($r('app.color.primary_light'))
      .fontColor('#fff')
      .width(80)
      .height('100%')
      .type(ButtonType.Normal)
      .onClick(() => {
          AvPlayerManager.remove(index) // 删除歌曲
      })

  }
```

<h3 id="qwu56">开发-后台播放</h3>
:::color2
Next版本的音乐播放只要应用退出到后台，音乐播放就会停止，此时我们接入系统控制中心，并申请长时后台任务，保证退出后台之后可以正常播放

:::

+ 在module.json5中申请长时后台任务

```typescript
 {
        "name": "ohos.permission.KEEP_BACKGROUND_RUNNING"
},
```

+ 在ability中配置backgroundModes

```typescript
 "backgroundModes": [
          "audioPlayback"
  ]
```



<h3 id="EfnON">![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715832622398-350462cf-f364-4be0-a021-fe4f0e76efee.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_46%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)</h3>
:::color2
请注意： ![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715832672694-c49897b7-6ed0-49c9-b080-c04674190cea.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

:::

:::info
我们首先接入控制中心的媒体会话，才可以可以实现音频的后台长时任务播放

:::

+ 具体流程

:::info
+ 接入控制中心- Next系统的媒体控制（可以在手机屏幕上开关暂停音乐）
+ 控制中心接入 播放-暂停-上一首-下一首-拖动进度-
+ 申请后台长时任务

:::

+ 新建媒体会话的管理类utiis/AvSessionManager

```typescript
export default class AvSessionManager {
  
}
```

+ 初始化会话对象和控制器

```typescript
import AvSession from '@ohos.multimedia.avsession'

export default class AvSessionManager {
  static session: AvSession.AVSession
  static controller: AvSession.AVSessionController
  // 初始化媒体会话
  static async init(context: Context) {
    AvSessionManager.session = await AvSession.createAVSession(context, 'bgPlay', 'audio') // 拿到会话对象
    AvSessionManager.controller = await AvSessionManager.session.getController() // 拿到会话控制器
  }
}
```

+ 在播放器对象中声明一个开启后台任务的方法

```typescript
  // 开启后台任务
  static async startBackgroundTask() {
    if(AvSessionManager.session.sessionId) {
      // 如果有会话id 则不用开启后台任务
      return
    }
    try {
      let wantAgentInfo: wantAgent.WantAgentInfo = {
        wants: [
          {
            bundleName: "com.example.heimacloudmusic",
            abilityName: "EntryAbility"
          }
        ],
        operationType: wantAgent.OperationType.START_ABILITY,
        requestCode: 0,
        wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
      };
      const want = await wantAgent.getWantAgent(wantAgentInfo) // 获取want信息
      await backgroundTaskManager.startBackgroundRunning(getContext(),
        backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK,
        want)
    } catch (error) {
      // 错误消息
      AlertDialog.show({ message: error.message })
    }

  }
```

+ 在播放单曲时，开启任务

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715850339271-a47039e8-5828-4aa3-a172-80c1ca0c1d36.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_51%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 在ability中初始化AvSession的对象

```typescript
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
    AvPlayerManager.init() // 直接初始化播放器
    AvSessionManager.init(this.context)
  }
```

<h3 id="IJwqP">设置会话对象</h3>
:::success
在AvSessionManager中声明一个方法，设置媒体中心的资源

:::

```typescript
// 设置媒体资源
  static async setAvMetaData (song: songItemType) {
    await AvSessionManager.session.setAVMetadata({
      assetId: song.id,
      title: song.name,
      artist: song.author,
      mediaImage: song.img,
      duration:   AvPlayerManager.currentSong.duration
    })
  }
```

+ 监听播放时长改变-调用该方法

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715851208379-ee0470c3-193e-4c56-8197-0f4b5ac2523f.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_78%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715851228130-2ba12e2d-17b9-4862-bf3c-15287f6b9323.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_14%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**<font style="color:#DF2A3F;"></font>**

<h3 id="mKNfL">同步播放进度和状态</h3>
:::success
设置播控中心的音乐状态和音频

:::

+ 在AvSessionManager添加一个设置状态的方法

```typescript
// 设置状态方法
  static async setAVPlaybackState() {
    AvSessionManager.session.setAVPlaybackState({
      state: AvPlayerManager.currentSong.isPlay ? AvSession.PlaybackState.PLAYBACK_STATE_PLAY :
      AvSession.PlaybackState.PLAYBACK_STATE_PAUSE,
      position: {
        elapsedTime:   AvPlayerManager.currentSong.time,
        updateTime: (new Date()).getTime(),
      },
      speed: 1.0,
      duration:   AvPlayerManager.currentSong.duration
    })
  }
```

:::success
播放/暂停/时移时 进行不断更新状态

:::

+ 播放时更新

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715851916141-eb41a60c-24f3-4bbd-b4f8-0cc691b90f27.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_66%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 暂停时更新

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715851949184-517824d5-8a69-4f66-aa8c-46e68dd39506.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_45%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 时移时更新

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715851972376-f1b83bd8-66ae-4ad1-b5bf-225db06d98c2.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_67%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715851734568-b6041d22-4e9d-4691-be01-eeeecfbad29b.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)



<h3 id="WOIHr">控制中心播控处理</h3>
:::success
当点击播控中心的播放-下一首-上一首时进行处理

:::

+ 在AvSessionManager声明一个注册函数

```typescript
static async registerEvent () {
    AvSessionManager.session.on('play', () => {
      AvPlayerManager.singlePlay(AvPlayerManager.currentSong.playList[  AvPlayerManager.currentSong.playIndex])
    })
    AvSessionManager.session.on('pause', () => {
      AvPlayerManager.pause()
    })
    AvSessionManager.session.on('stop', () => {
    })
    AvSessionManager.session.on('playNext', () => {
      AvPlayerManager.nextPlay()
    })
    AvSessionManager.session.on('playPrevious', () => {
      AvPlayerManager.prevPlay()
    })
    AvSessionManager.session.on('seek', (time) => {
      AvPlayerManager.player!.seek(time)
    })
    AvSessionManager.session.activate()
  }
```

+ 在init之后进行注册函数

```typescript
// 初始化媒体会话
  static async init(context: Context) {
    AvSessionManager.session = await AvSession.createAVSession(context, 'bgPlay', 'audio') // 拿到会话对象
    AvSessionManager.controller = await AvSessionManager.session.getController() // 拿到会话控制器
    AvSessionManager.registerEvent()
  }
```



![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715853454039-ad314196-2846-41d0-a2f5-0d85b3db8b34.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_15%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)



<h1 id="Cf2My">卡片通信</h1>
:::success
使用现有的卡片模板完成

+ 卡片播放
+ 卡片暂停
+ 上一首
+ 下一首

:::

:::danger
**卡片是一个单独的Ability，但是卡片的页面****<font style="color:rgba(194,0,17,1);">不允许导入模块</font>****，****<font style="color:rgba(194,0,17,1);">不允许写定时器</font>**

**并且，****<font style="color:rgba(194,0,17,1);">卡片执行能力只存活有5秒-10秒</font>**

:::

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1706098586821-bbfb0a7d-6a5a-49cf-b2f8-04134ef34d09.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_33%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

****

![](https://cdn.nlark.com/yuque/0/2024/png/34522383/1706098657801-ace5ecb1-99c6-4893-a924-1efdf4200fb9.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

**<font style="color:rgba(194,0,17,1);">应用至卡片：</font>**

**每张卡片在创建的时候都有自己唯一的ID，应用想要给卡片通信，就要记住这个ID，卡片只会创建一次，应用会打开关闭无数次，所以需要将ID记录在首选项中！**

**<font style="color:rgba(194,0,17,1);">卡片至应用：</font>**

**应用可以订阅卡片发布的消息，当点击卡片按钮时进行消息的发布，从而在应用中接收消息后进行相应的操作**

<h3 id="lN1mP">新建一个存储卡片id的首选项管理对象</h3>
+ utils/FormIdManager.ets

```typescript
import { preferences } from '@kit.ArkData'
import { Context } from '@kit.AbilityKit'

export default class FormIdManager {
  static context: Context
  // 获取store
  static getStore() {
    return preferences.getPreferencesSync(FormIdManager.context || getContext(), {
      name: "music_formId"
    })
  }
  // 存储卡片ID
  static async addFormId(formId: string) {
    const store = FormIdManager.getStore()
    const list = FormIdManager.getFormIdList()
    if(!list.some(id => id === formId)) {
      list.push(formId)
    }
    store.putSync("music_formId_key", JSON.stringify(list))
    await store.flush()
  }

  // 获取卡片ID数组
  static getFormIdList() {
    const store = FormIdManager.getStore()
    return JSON.parse(store.getSync("music_formId_key", '[]') as string) as string[]
  }
  static async delFormId(formId: string) {
    const store = FormIdManager.getStore()
    const list = FormIdManager.getFormIdList()
    const index = list.findIndex(id => id === formId)
    list.splice(index, 1)
    store.putSync("music_formId_key", JSON.stringify(list))
    await store.flush()
  }
}
```

+ 在ability中设置上下文

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1715857405127-db73708e-73f0-4458-9343-6554317cbae7.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_69%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 添加卡片时将formId提供给卡片

```typescript
onAddForm(want: Want) {
    // Called to return a FormBindingData object.
    let formId: string = want.parameters?.[formInfo.FormParam.IDENTITY_KEY] as string
    return formBindingData.createFormBindingData({
      formId
    });
  }
```

+ 在卡片中接收formId, 监听formId变化，通过call方式传递给ability

```typescript
 @LocalStorageProp('formId')
  @Watch("updateFormId")
  formId: string = ""

  updateFormId () {
    console.log("formId_card", this.formId)
    postCardAction(this, {
      action: 'call',
      abilityName: 'EntryAbility',
      params: {
        method: 'getFormId',
        formId: this.formId
      }
    })
  }
```

+ 引入rpc实现其类型

```typescript
import rpc from '@ohos.rpc';

class Params implements rpc.Parcelable {
  marshalling(messageSequence: rpc.MessageSequence): boolean {
    return true;
  }
  unmarshalling(messageSequence: rpc.MessageSequence): boolean {
    return true;
  }
}
```

+ 通过callee监听

```typescript
onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
    AvPlayerManager.init() // 直接初始化播放器
    AvSessionManager.init(this.context)
    class ParamsForm {
      formId: string = ""
    }
    // 监听formId
    this.callee.on("getFormId", (data) => {
      const res = JSON.parse(data.readString()) as ParamsForm
      FormIdManager.addFormId(res.formId)
      return new Params();
    })
  }
```

+ 在卡片中定义接收的数据类型

:::danger
其实类型和应用类型是一样的，但是卡片不允许导入内容，所以只能单独定义一遍

:::

```typescript
interface songItemType {
  img: string
  name: string
  author: string
  url: string
  id: string
}

export class PlayStateType {
  img: string = "" // 音乐封面
  name: string = "" // 音乐名称
  author: string = "" // 作者
  url: string = "" // 当前播放连接
  playIndex: number =  0 // 当前在播放列表中的播放索引
  time: number = 0 // 播放时间
  duration: number = 0 // 音乐的播放市场
  isPlay: boolean = false // 是否正在播放
  playMode: 'auto' | 'repeat' | 'random' = "auto" // 播放模式
  playList: songItemType[] = [] // 当前的播放列表
  cacheImg?: string // 缓存图片地址
}
```

+ 实现播放上一首-下一首

```typescript
 // 上一首
          Image($r('app.media.ic_prev'))
            .fillColor(Color.White)
            .width(30)
            .onClick(() => {
              //无法导入AVPlayerClass
              // 通知应用切换下一首
              postCardAction(this, {
                action: 'call',
                abilityName: 'EntryAbility',
                params: {
                  method: 'prev'
                }
              })
            })
  // 下一首
          Image($r('app.media.ic_next'))
            .fillColor(Color.White)
            .width(30)
            .onClick(() => {
              //无法导入AVPlayerClass
              // 通知应用切换下一首
              // 没有办法在页面使用发布类，但是Ability可以发布
              postCardAction(this, {
                action: 'call',
                abilityName: 'EntryAbility',
                params: {
                  method: 'next'
                }
              })
            })
```

+ 在ability中监听调用

```typescript
class Params implements rpc.Parcelable {
  marshalling(messageSequence: rpc.MessageSequence): boolean {
    return true;
  }
  unmarshalling(messageSequence: rpc.MessageSequence): boolean {
    return true;
  }
}

onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
    // 上一首
    this.callee.on("prev", () => {
        AvPlayerManager.prevPlay()
      return new Params();
    })
    // 下一首
    this.callee.on("next", () => {
        AvPlayerManager.nextPlay()
      return new Params();
    })
  }

```

+ 当接收到formId变化时，推送当前歌曲到卡片

```typescript
 // 监听formId
    this.callee.on("getFormId", (data) => {
      const res = JSON.parse(data.readString()) as ParamsForm
      formProvider.updateForm(res.formId, formBindingData.createFormBindingData({
        song: AppStorage.get(SONG_KEY)
      }))
      FormIdManager.addFormId(res.formId)
      return new Params();
    })
```

+ 在切歌时通知卡片更新

```typescript
// 切换播放的方法
  static async changePlay() {
    // 重置播放
    await AvPlayerManager.player?.reset() // 重置播放器 会将当前的音乐暂停
    AvPlayerManager.currentSong.duration = 0 // 归零
    AvPlayerManager.currentSong.time = 0 // 归零
    AvPlayerManager.currentSong.img = AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].img
    AvPlayerManager.currentSong.name = AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].name
    AvPlayerManager.currentSong.url = AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].url
    AvPlayerManager.currentSong.author =
      AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].author
    AvPlayerManager.player!.url = AvPlayerManager.currentSong.url // 之所以能播放 就是因为设置了地址

   const formIdList =  FormIdManager.getFormIdList()
    formIdList.forEach(formId => {
      formProvider.updateForm(formId, formBindingData.createFormBindingData({
        song: AvPlayerManager.currentSong
      }))
    })
  }
```



<h3 id="a1iAO">**将图片下载到沙箱-显示在卡片**</h3>
:::color1
因为卡片不支持展示网络图片，需要下载到内存再进行显示

:::

**下载工具类:**

```arkts
import { request } from '@kit.BasicServicesKit';
import { fileIo } from '@kit.CoreFileKit';

export default class ImageSave {
  static async saveFile(fileName: string, url: string, callBack: (path: string) => void) {
    try {
      let tempDir = getContext().getApplicationContext().tempDir;
      if (fileIo.listFileSync(tempDir).includes(fileName)) {
       return callBack(tempDir + "/" + fileName)
      }
      const task = await request.downloadFile(getContext(), {
        filePath: tempDir + "/" + fileName,
        url
      })
      task.on("complete", () => {
        let newPath = tempDir + "/" + fileName
        callBack(newPath)
      })
      task.on("fail", () => {
        AlertDialog.show({
          message: "下载异常"
        })
      })
    } catch (error) {
      AlertDialog.show({
        message: error.message
      })
    }

  }
}
```



+ 在切歌之后进行推送

```typescript
 static async pushImg() {
    ImageSave.saveFile(AVPlayerManger.currentSong.name + ".jpg",   AvPlayerManager.currentSong.img, async (filePath) => {
        AvPlayerManager.currentSong.cacheImg = filePath
      const formIdList = FormIdManager.getFormIdList()
      let fileInfo: Record<string, string | number> = {}
      let temFile = fileIo.openSync(  AvPlayerManager.currentSong.cacheImg)
      fileInfo[AVPlayerManger.currentSong.cacheImg!] = temFile.fd
      const data = formBindingData.createFormBindingData({
        song:   AvPlayerManager.currentSong,
        fileName:   AvPlayerManager.currentSong.cacheImg,
        formImages: fileInfo
      })
      let index = 0
      while (index < formIdList.length) {
        await formProvider.updateForm(formIdList[index], data) // 更新数据
        index++
      }
    })
  }
```

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1716176374965-100552ef-0784-4407-b52a-a58290bd8346.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_80%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 在ability中监听卡片添加事件

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1716176425791-69aa80bb-d59f-4148-a242-9ec42082c9cd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_61%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

<h3 id="oXU8D">持久化播放列表</h3>
:::color1
将当前播放的歌曲及歌单缓存到首选项，等到初始化之后重新赋值

:::

+ 新建utils/SongManager.ets

```typescript
import { preferences } from '@kit.ArkData'
import { Context } from '@kit.AbilityKit'
import { PlayStateType } from '../models'

export default class SongManager {
  static context: Context

  // 获取store
  static getStore() {
    return preferences.getPreferencesSync(SongManager.context || getContext(), {
      name: "song_cache"
    })
  }
  // 更新音乐
  static async updateSong(song: string) {
    const store = SongManager.getStore()
    store.putSync("song_cache_key", song)
    await store.flush()
  }
  static async getSong() {
    const store = SongManager.getStore()
    return JSON.parse(store.getSync("song_cache_key", JSON.stringify(new PlayStateType())) as string) as PlayStateType
  }
}
```

+ 在ability初始化时赋值

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1716908534802-26895089-672a-48f2-95c5-918ebc73958c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_59%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 处理首次播放时时长为0的情况

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1716908570330-770f9431-22a6-4199-850a-3685d561bf4c.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_55%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)

+ 更新状态时，写入首选项

![](https://cdn.nlark.com/yuque/0/2024/png/8435673/1716177093968-4c7bca9b-0b2a-4ea2-b52b-2c21b40b4dd5.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_79%2Ctext_6buR6ams56iL5bqP5ZGY%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10)





<h1 id="SXngt">完整代码</h1>
+ EntryAbility

```typescript
import { AbilityConstant, UIAbility, Want } from '@kit.AbilityKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { window } from '@kit.ArkUI';
import { SONG_KEY } from '../constants';
import { AvPlayerManager } from '../utils/AvPlayerManager';
import { AvSessionManager } from '../utils/AvSessionManager';
import FormIdManager from '../utils/FormIdManager';
import rpc from '@ohos.rpc';
import { formBindingData, formProvider } from '@kit.FormKit';
import SongManager from '../utils/SongManager';

class Params implements rpc.Parcelable {
  marshalling(messageSequence: rpc.MessageSequence): boolean {
    return true;
  }

  unmarshalling(messageSequence: rpc.MessageSequence): boolean {
    return true;
  }
}

class ParamsForm {
  formId: string = ""
}

export default class EntryAbility extends UIAbility {
  onCreate(want: Want, launchParam: AbilityConstant.LaunchParam): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onCreate');
    AvPlayerManager.init() // 直接初始化播放器
    AvSessionManager.init(this.context)

    this.callee.on("getFormId", (data) => {
      const res = JSON.parse(data.readString()) as ParamsForm
      FormIdManager.addFormId(res.formId).then(() => {
        AvPlayerManager.pushImage() // 硬推一次
      }) // 加入formId
      // 先推一次
      // formProvider.updateForm(res.formId, formBindingData.createFormBindingData({
      //   song: AvPlayerManager.currentSong // 当前歌曲推过去
      // }))
      return new Params() // 只是为了不报错
    })
    this.callee.on("prev", (data) => {
      AvPlayerManager.prevPlay()
      return new Params() // 只是为了不报错
    })
    this.callee.on("next", (data) => {
      AvPlayerManager.nextPlay()
      return new Params() // 只是为了不报错
    })
  }

  onDestroy(): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onDestroy');
  }

  async onWindowStageCreate(windowStage: window.WindowStage): Promise<void> {
    const win = await windowStage.getMainWindow()
    win.setWindowLayoutFullScreen(true)
    AppStorage.setOrCreate("topHeight", px2vp(win.getWindowAvoidArea(window.AvoidAreaType.TYPE_SYSTEM)
      .topRect.height))
    AppStorage.setOrCreate("bottomHeight", px2vp(win.getWindowAvoidArea(window.AvoidAreaType.TYPE_NAVIGATION_INDICATOR)
      .bottomRect.height))
    const childWin = await windowStage.createSubWindow("ad_win") // 创建广告子窗口
    await childWin.showWindow()
    await childWin.setUIContent("pages/Start/Start")
    FormIdManager.context = this.context // 给首选项存储formId的首选项赋值上下文
    // 从首选项读取缓存的播放列表
    SongManager.context = this.context
    const currentSong = await SongManager.getSong() // 给播放器
    currentSong.isPlay = false // 不论什么情况 肯定都是关着呢
    AvPlayerManager.currentSong = currentSong // 并没有给到duration
    if(AvPlayerManager.currentSong.url) {
      AvPlayerManager.player!.url = AvPlayerManager.currentSong.url // 会自动播放
      AppStorage.setOrCreate("firstplay", 1) // 首次播放
    }
    AppStorage.setOrCreate(SONG_KEY, AvPlayerManager.currentSong) // 更新全局状态
    windowStage.loadContent("pages/Index/Index")
  }

  onWindowStageDestroy(): void {
    // Main window is destroyed, release UI related resources
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onWindowStageDestroy');
  }

  onForeground(): void {
    // Ability has brought to foreground
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onForeground');
  }

  onBackground(): void {
    hilog.info(0x0000, 'testTag', '%{public}s', 'Ability onBackground');
  }
}

```

+ EntryFormAbility.ets

```typescript
import { formBindingData, FormExtensionAbility, formInfo } from '@kit.FormKit';
import { Want } from '@kit.AbilityKit';
import { PreferencesClass } from '../utils/PreferencesClass';
import { SubscriberClass } from '../utils/SubscriberClasss';
import { PublishEventType } from '../constants/EventContants';
import FormIdManager from '../utils/FormIdManager';
import AvPlayerManager from '../utils/AvPlayerManager';
import { SONG_KEY } from '../constants';

export default class EntryFormAbility extends FormExtensionAbility {
  onAddForm(want: Want) {
    // Called to return a FormBindingData object.
    let formId: string = want.parameters?.[formInfo.FormParam.IDENTITY_KEY] as string
    return formBindingData.createFormBindingData({
      formId
    });
  }

  onCastToNormalForm(formId: string) {
    // Called when the form provider is notified that a temporary form is successfully
    // converted to a normal form.

  }

  onUpdateForm(formId: string) {
    // Called to notify the form provider to update a specified form.
  }

  onChangeFormVisibility(newStatus: Record<string, number>) {
    // Called when the form provider receives form events from the system.
  }

  onFormEvent(formId: string, message: string) {
    console.log("current_params", message)
    // Called when a specified message event defined by the form provider is triggered.
  }

  onRemoveForm(formId: string) {
    // Called to notify the form provider that a specified form has been destroyed.
  }

  onAcquireFormState(want: Want) {
    // Called to return a {@link FormState} object.
    return formInfo.FormState.READY;
  }
};
```

+ 卡片

```typescript
interface songItemType {
  img: string
  name: string
  author: string
  url: string
  id: string
}

export class PlayStateType {
  img: string = "" // 音乐封面
  name: string = "" // 音乐名称
  author: string = "" // 作者
  url: string = "" // 当前播放连接
  playIndex: number = 0 // 当前在播放列表中的播放索引
  time: number = 0 // 播放时间
  duration: number = 0 // 音乐的播放市场
  isPlay: boolean = false // 是否正在播放
  playMode: 'auto' | 'repeat' | 'random' = "auto" // 播放模式
  playList: songItemType[] = [] // 当前的播放列表
}

const localStorage = new LocalStorage()
@Entry(localStorage)
@Component
struct WidgetCard {
  @State
  randomColor: string = 'rgb(0,0,0)'
  @LocalStorageProp('song')
  @Watch('updateState')
  playState: PlayStateType = new PlayStateType()

  @LocalStorageProp('formId')
  @Watch("updateFormId")
  formId: string = ""

  updateFormId () {
    console.log("formId_card", this.formId)
    postCardAction(this, {
      action: 'call',
      abilityName: 'EntryAbility',
      params: {
        method: 'getFormId',
        formId: this.formId
      }
    })
  }
  updateState() {
    this.randomColor =
      `rgb(${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)},${Math.floor(Math.random() * 255)})`
  }

  // 图片
  @LocalStorageProp('fileName')
  fileName: string = ''

  build() {
    Row() {
      Column() {
        Row() {
          Row() {
            Image('memory://' + this.fileName)
              .width('60%')
              .borderRadius(400)
          }
          .shadow({
            radius: 30,
            color: this.randomColor
          })
          .animation({
            duration: 1000,
            onFinish: () => {
              this.randomColor = 'rgb(0,0,0)'
            }
          })
          .backgroundImage($r('app.media.ic_cd'))
          .backgroundImageSize(ImageSize.Cover)
          .justifyContent(FlexAlign.Center)
          .width('80%')
          .margin(10)
          .borderRadius(400)
          .aspectRatio(1)
          .translate({
            y: 10
          })
          .onClick(() => {
            postCardAction(this, {
              action: 'router',
              abilityName: 'EntryAbility'
            })
          })
        }
        .width('100%')
        .height('80%')
        .justifyContent(FlexAlign.Center)


        Row() {
          // 上一首
          Image($r('app.media.ic_prev'))
            .fillColor(Color.White)
            .width(30)
            .onClick(() => {
              //无法导入AVPlayerClass
              // 通知应用切换下一首
              postCardAction(this, {
                action: 'call',
                abilityName: 'EntryAbility',
                params: {
                  method: 'prev'
                }
              })
            })
          Text(this.playState.name)
            .fontColor(Color.White)
            .fontSize(12)
            .textOverflow({
              overflow: TextOverflow.Ellipsis
            })
            .width("50%")
            .textAlign(TextAlign.Center)

          // 下一首
          Image($r('app.media.ic_next'))
            .fillColor(Color.White)
            .width(30)
            .onClick(() => {
              //无法导入AVPlayerClass
              // 通知应用切换下一首
              // 没有办法在页面使用发布类，但是Ability可以发布
              postCardAction(this, {
                action: 'call',
                abilityName: 'EntryAbility',
                params: {
                  method: 'next'
                }
              })
            })
        }
        .width('100%')
        .height('20%')
        .padding({ left: 10, right: 10 })
        .justifyContent(FlexAlign.SpaceBetween)
      }
    }
    .width('100%')
    .height('100%')
    .backgroundImage('memory://' + this.fileName)
    .backgroundImageSize(ImageSize.Cover)
    .backgroundBlurStyle(BlurStyle.BACKGROUND_ULTRA_THICK)
    .backgroundColor('#ec5c87')

  }
}
```

+ AvPlayerManager.ets

```typescript
// 用来播放音乐 切换音乐 暂停音乐 进度调整 后台播放音乐
import media from '@ohos.multimedia.media'
import { SONG_KEY } from '../constants'
import { songItemType, PlayStateType } from '../models'
import { router } from '@kit.ArkUI'
import { AvSessionManager } from './AvSessionManager'
import { backgroundTaskManager } from '@kit.BackgroundTasksKit'
import { wantAgent } from '@kit.AbilityKit'
import FormIdManager from './FormIdManager'
import { formBindingData, formProvider } from '@kit.FormKit'
import ImageSave from './ImageSave'
import { fileIo } from '@kit.CoreFileKit'
import SongManager from './SongManager'

export class AvPlayerManager {
  static player: media.AVPlayer | null = null // 播放器对象
  static currentSong: PlayStateType = new PlayStateType() // 记录当前的歌曲
  // 初始化播放器
  static async init() {
    // 保证当前只有一个播放器 不重复创建不浪费资源
    if (!AvPlayerManager.player) {
      AvPlayerManager.player = await media.createAVPlayer()
    }
    AvPlayerManager.player.on("stateChange", (state) => {
      switch (state) {
        case "initialized":
          AvPlayerManager.player?.prepare() // 准备
          break;
        case "prepared":
          if(AppStorage.get("firstplay") === 1) {
            // 说明上次的直接来播放了// 只会进来一次
            AppStorage.setOrCreate("firstplay", 0)
          }else {
            AvPlayerManager.currentSong.isPlay = true // 表示正在播放
            AvPlayerManager.player?.play() // 播放
          }

          break;
        case "completed":
          AvPlayerManager.nextPlay(AvPlayerManager.currentSong.playMode === "repeat") // 直接调用下一首播放
          break
      }
    })
    // 播放器可以监听播放时长的变化
    AvPlayerManager.player.on("durationUpdate", (duration) => {
      AvPlayerManager.currentSong.duration = duration // 记录当前歌曲的时长
      AppStorage.setOrCreate<PlayStateType>(SONG_KEY, AvPlayerManager.currentSong) // 将状态设置到全局
      AvSessionManager.setAvMetaData(AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex])
    })
    // 需要知道歌曲播到哪里了
    AvPlayerManager.player.on("timeUpdate", (time) => {
      AvPlayerManager.currentSong.time = time
      AppStorage.setOrCreate<PlayStateType>(SONG_KEY, AvPlayerManager.currentSong) // 将状态设置到全局
      AvSessionManager.setAVPlayBackState() // 设置状态
    })
    AvPlayerManager.player.on("error", (error) => {
      AlertDialog.show({ message: error.message })
    })
  }

  // 点击某个歌曲播放
  static singlePlay(song: songItemType) {
    AvPlayerManager.startBackgroundTask() // 开启后台任务
    // AvPlayerManager.player!.url = song.url // 赋值
    // 做判断
    // 判断歌曲在不在播放列表里
    const inList = AvPlayerManager.currentSong.playList.some(item => item.id === song.id)
    if (inList) {
      // 在列表里
      if (AvPlayerManager.currentSong.url === song.url) {
        // 如果点的和当前播的是同一个
        AvPlayerManager.player?.play() // 播放
        AvPlayerManager.currentSong.isPlay = true // 正在播放
      } else {
        // 点的和正在播的不是同一个
        AvPlayerManager.currentSong.playIndex =
          AvPlayerManager.currentSong.playList.findIndex(item => item.id === song.id)
        AvPlayerManager.changePlay() // 切换播放
      }
    } else {
      AvPlayerManager.currentSong.playList.unshift(song) // 在顶部追加
      AvPlayerManager.currentSong.playIndex = 0 // 播第一个
      AvPlayerManager.changePlay() // 切换播放
    }
    AppStorage.setOrCreate<PlayStateType>(SONG_KEY, AvPlayerManager.currentSong) // 将状态设置到全局
    AvSessionManager.setAVPlayBackState() // 设置状态
  }

  // 切换播放的方法
  static async changePlay() {
    // 重置播放
    await AvPlayerManager.player?.reset() // 重置播放器 会将当前的音乐暂停
    AvPlayerManager.currentSong.duration = 0 // 归零
    AvPlayerManager.currentSong.time = 0 // 归零
    AvPlayerManager.currentSong.img = AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].img
    AvPlayerManager.currentSong.name = AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].name
    AvPlayerManager.currentSong.url = AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].url
    AvPlayerManager.currentSong.author =
      AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex].author
    AvPlayerManager.player!.url = AvPlayerManager.currentSong.url // 之所以能播放 就是因为设置了地址

    // 只要切歌就应该推送图片
    AvPlayerManager.pushImage() // 这里就需要推送图片
    SongManager.updateSong(JSON.stringify(AvPlayerManager.currentSong))

  }
  // 推送图片
  static  pushImage () {
    ImageSave.saveFile(AvPlayerManager.currentSong.name+".jpg", AvPlayerManager.currentSong.img, (filePath) => {
      // filePath就是文件的路径
      // 下载成功  并不是每次都下载
      const formIdList =  FormIdManager.getFormIdList()
      let fileInfo: Record<string, number> = {} // 定义健值对类型
      fileInfo[filePath] = fileIo.openSync(filePath).fd // { key(沙箱路径): 沙箱文件对应的fd的值  }
      formIdList.forEach(formId => {
        formProvider.updateForm(formId, formBindingData.createFormBindingData({
          song: AvPlayerManager.currentSong,
          formImages: fileInfo,  // 这个是必须要写的
          fileName: filePath // 传递需要的路径
          // 需要把filePath给到卡片
          // formImages: { key(沙箱路径): 沙箱文件对应的fd的值  }
        }))
      })
    })

  }
  // 暂停
  static pause() {
    AvPlayerManager.player?.pause() // 播放器暂停
    AvPlayerManager.currentSong.isPlay = false // 状态更新
    AppStorage.setOrCreate<PlayStateType>(SONG_KEY, AvPlayerManager.currentSong) // 将状态设置到全局
    AvSessionManager.setAVPlayBackState() // 设置状态
  }

  // 上一首播放
  static prevPlay() {
    // 判断一个情况 当前的播放模式
    if (AvPlayerManager.currentSong.playMode === "random") {
      // 通过随机数找一个歌曲
      AvPlayerManager.currentSong.playIndex = Math.floor(Math.random() * AvPlayerManager.currentSong.playList.length)
    } else {
      // 除了随机播放之外 都是要切到前一个
      AvPlayerManager.currentSong.playIndex--
      // 要知道 有可能为-1
      // 保证要有数据
      AvPlayerManager.currentSong.playIndex =
        (AvPlayerManager.currentSong.playIndex + AvPlayerManager.currentSong.playList.length) %
        AvPlayerManager.currentSong.playList.length
    }
    AvPlayerManager.singlePlay(AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex])
    // 播放当前歌曲

  }

  // 下一首播放
  static nextPlay(repeat?: boolean) {
    if (!repeat) {
      // 这个逻辑是 不是单曲循环的自动播放
      // 如果不是单曲循环 就需要切下一首
      if (AvPlayerManager.currentSong.playMode === "random") {
        // 通过随机数找一个歌曲
        AvPlayerManager.currentSong.playIndex = Math.floor(Math.random() * AvPlayerManager.currentSong.playList.length)
      } else {
        // 除了随机播放之外 都是要切到前一个
        AvPlayerManager.currentSong.playIndex++
        // 要知道 有可能为-1
        // 保证要有数据
        AvPlayerManager.currentSong.playIndex =
          (AvPlayerManager.currentSong.playIndex + AvPlayerManager.currentSong.playList.length) %
          AvPlayerManager.currentSong.playList.length
      }
    }
    AvPlayerManager.singlePlay(AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex])
    // 播放当前歌曲
  }

  // 删除歌曲
  static remove(index: number) {
    // 如果删除的是正在播的歌曲
    if (index === AvPlayerManager.currentSong.playIndex) {
      if (AvPlayerManager.currentSong.playList.length > 1) {
        AvPlayerManager.currentSong.playList.splice(index, 1) // 先删除
        // 说明至少还有一个
        AvPlayerManager.currentSong.playIndex =
          (AvPlayerManager.currentSong.playIndex + AvPlayerManager.currentSong.playList.length) %
          AvPlayerManager.currentSong.playList.length
        AvPlayerManager.singlePlay(AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex])
      } else {
        // 说明已经删除干净了
        router.back()
        AvPlayerManager.currentSong = new PlayStateType() // 因为歌曲都删除光了
        AvPlayerManager.player?.reset() // 因为歌曲都没有了 直接重置
      }
    } else {
      // 如果删除的歌曲的索引小于 正在播的歌曲
      if (AvPlayerManager.currentSong.playIndex > index) {
        AvPlayerManager.currentSong.playIndex--
      }
      AvPlayerManager.currentSong.playList.splice(index, 1) // 删除掉这个选项
    }
    AppStorage.setOrCreate<PlayStateType>(SONG_KEY, AvPlayerManager.currentSong) // 将状态设置到全局
    // 更新全局状态
  }

  // 开启后台长时任务
  static async startBackgroundTask() {
    // 会话对象只要有就说明不用开启了
    if (AvSessionManager.session.sessionId) {
      // 如果已经有会话了那就不用开启了
      return
    }
    try {
      // want的信息组成 目的是点击播控中心的时候 可以进入应用
      let wantAgentInfo: wantAgent.WantAgentInfo = {
        wants: [
          {
            bundleName: 'com.example.heimacloudmusic',
            abilityName: 'EntryAbility'
          }
        ],
        operationType: wantAgent.OperationType.START_ABILITIES,
        requestCode: 0,
        wantAgentFlags: [wantAgent.WantAgentFlags.UPDATE_PRESENT_FLAG]
      }
      const want = await wantAgent.getWantAgent(wantAgentInfo) // 申请want信息

      // 申请长时任务
      await backgroundTaskManager.startBackgroundRunning(getContext(),
        backgroundTaskManager.BackgroundMode.AUDIO_PLAYBACK,
        want
      )
    }catch (error) {
      AlertDialog.show({ message: error.message })
    }

  }
}
```

+ FormIdManager.ets

```typescript
import { preferences } from '@kit.ArkData'
import { Context } from '@kit.AbilityKit'

export default class FormIdManager {
  static context: Context
  // 获取store
  static getStore() {
    return preferences.getPreferencesSync(FormIdManager.context || getContext(), {
      name: "music_formId"
    })
  }
  // 存储卡片ID
  static async addFormId(formId: string) {
    const store = FormIdManager.getStore()
    const list = FormIdManager.getFormIdList()
    if(!list.some(id => id === formId)) {
      list.push(formId)
    }
    store.putSync("music_formId_key", JSON.stringify(list))
    await store.flush()
  }

  // 获取卡片ID数组
  static getFormIdList() {
    const store = FormIdManager.getStore()
    return JSON.parse(store.getSync("music_formId_key", '[]') as string) as string[]
  }
  static async delFormId(formId: string) {
    const store = FormIdManager.getStore()
    const list = FormIdManager.getFormIdList()
    const index = list.findIndex(id => id === formId)
    list.splice(index, 1)
    store.putSync("music_formId_key", JSON.stringify(list))
    await store.flush()
  }
}
```

+ SongManager.ets

```typescript
import { preferences } from '@kit.ArkData'
import { Context } from '@kit.AbilityKit'
import { PlayStateType } from '../models'

export default class SongManager {
  static context: Context

  // 获取store
  static getStore() {
    return preferences.getPreferencesSync(SongManager.context || getContext(), {
      name: "song_cache"
    })
  }
  // 更新音乐
  static async updateSong(song: string) {
    const store = SongManager.getStore()
    store.putSync("song_cache_key", song)
    await store.flush()
  }
  static async getSong() {
    const store = SongManager.getStore()
    return JSON.parse(store.getSync("song_cache_key", JSON.stringify(new PlayStateType())) as string) as  PlayStateType
  }
}
```

+ AvSessionManager.ets

```typescript
import AvSession from '@ohos.multimedia.avsession';
import { songItemType } from '../models';
import { AvPlayerManager } from './AvPlayerManager';

export class AvSessionManager {
  static session: AvSession.AVSession // 单例 媒体会话对象
  static controller: AvSession.AVSessionController // 控制器
  static async init (context: Context) {
    // 拿到会话对象
    AvSessionManager.session = await AvSession.createAVSession(context, "bgPlay", "audio")
    AvSessionManager.controller = await AvSessionManager.session.getController() // 拿到控制器
    AvSessionManager.registerEvent()
  }
  // 设置一些封面信息
  static async setAvMetaData (song: songItemType) {
    await AvSessionManager.session.setAVMetadata({
      assetId: song.id,
      title: song.name,
      artist: song.author,
      author: song.author,
      duration: AvPlayerManager.currentSong.duration,
      mediaImage: song.img
    })
  }
  // 不断的设置播放信息
  static async setAVPlayBackState () {
    AvSessionManager.session.setAVPlaybackState({
      state: AvPlayerManager.currentSong.isPlay ? AvSession.PlaybackState.PLAYBACK_STATE_PLAY
              : AvSession.PlaybackState.PLAYBACK_STATE_PAUSE,
      position: {
        elapsedTime: AvPlayerManager.currentSong.time, // 播到第几秒
        updateTime: new Date().getTime()
      },
      speed: 1,
      duration: AvPlayerManager.currentSong.duration
    })
  }

  // 注册会话对象传递过来的
  static registerEvent () {
    AvSessionManager.session.on("play", () => {
     AvPlayerManager.singlePlay(AvPlayerManager.currentSong.playList[AvPlayerManager.currentSong.playIndex])
    })
    AvSessionManager.session.on("pause", () => {
      AvPlayerManager.pause()
    })
    AvSessionManager.session.on("playPrevious", () => {
      AvPlayerManager.prevPlay()
    })
    AvSessionManager.session.on("playNext", () => {
      AvPlayerManager.nextPlay()
    })
    AvSessionManager.session.on("seek", (time) => {
      AvPlayerManager.player?.seek(time)
    })
    AvSessionManager.session.activate() // 激活这些注册
  }
}
```

+ playState.ets

```typescript
// 传输数据的结构
import { songItemType } from './music';

export class PlayStateType {
  img: string = "" // 音乐封面
  name: string = "" // 音乐名称
  author: string = "" // 作者
  url: string = "" // 当前播放连接
  playIndex: number =  0 // 当前在播放列表中的播放索引
  time: number = 0 // 播放时间
  duration: number = 0 // 音乐的播放市场
  isPlay: boolean = false // 是否正在播放
  playMode: 'auto' | 'repeat' | 'random' = "auto" // 播放模式
  playList: songItemType[] = [] // 当前的播放列表
  cacheImg?: string // 缓存图片地址
}


```

